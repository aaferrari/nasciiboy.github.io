<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Docu on ⋲ᴹ∧cₛ ℜø∁κ§</title>
    <link>https://nasciiboy.land/tags/docu/</link>
    <description>Recent content in Docu on ⋲ᴹ∧cₛ ℜø∁κ§</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>es</language>
    <copyright>GPL v3.0</copyright>
    <lastBuildDate>Mon, 01 Oct 2018 20:59:05 -0500</lastBuildDate>
    
        <atom:link href="https://nasciiboy.land/tags/docu/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>Oxido</title>
      <link>https://nasciiboy.land/prog/oxido/</link>
      <pubDate>Mon, 01 Oct 2018 20:59:05 -0500</pubDate>
      
      <guid>https://nasciiboy.land/prog/oxido/</guid>
      <description>

&lt;p&gt;Ultimamente pocas cosas de las que hago al dia logran clasificar como
&amp;ldquo;productivas&amp;rdquo; o &amp;ldquo;divertidas&amp;rdquo;. Sumado (o restado) a esto, por razones externas, me vi forzado
a buscar un material interesante con el cual aparentar alguna labor frente al
monitor con el extra de que fuera de interes y evitara en lo posible la somnolencia&lt;/p&gt;

&lt;p&gt;Toquetear &lt;a href=&#34;https://www.rust-lang.org/es-ES/&#34;&gt;rust&lt;/a&gt; fue la ocupacion que logro
mantener las apariecias los ultimos 2 dias. Uno de ellos fue
satisfactorio e divertido, y el otro&amp;hellip; algo decepcionante (spoiler).&lt;/p&gt;

&lt;p&gt;Pero, por que Rust?&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;es FOSS,&lt;/li&gt;
&lt;li&gt;no es de microsoft,&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://dtrace.org/blogs/bmc/2018/09/18/falling-in-love-with-rust/&#34;&gt;propaganda&lt;/a&gt;,&lt;/li&gt;
&lt;li&gt;compilacion estatica,&lt;/li&gt;
&lt;li&gt;se promociona como rapido y seguro,&lt;/li&gt;
&lt;li&gt;no apesta en lentitud como &lt;s&gt;Python&lt;/s&gt;,&lt;/li&gt;
&lt;li&gt;en apariencia tiene una saludable comunidad que crea herramientas y librerias,&lt;/li&gt;
&lt;li&gt;no es TAB-indentado,&lt;/li&gt;
&lt;li&gt;tiene bloques de alcance delimitados por &lt;code&gt;{ }&lt;/code&gt; y no por TABS o &lt;code&gt;end&lt;/code&gt;s, y&lt;/li&gt;
&lt;li&gt;su libro es de libre difusion y ademas cuenta con traducciones al español&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;comentare un poco sobre las traducciones, y el libro oficial.&lt;/p&gt;

&lt;p&gt;Primero, la &lt;a href=&#34;https://goyox86.github.io/elpr/&#34;&gt;version uno del libro traducida al español&lt;/a&gt;
esta buena (creo). El libro en si, es un paseo por las caracteristicas del
lenguaje. Esto viene a significar, que si consideras que sabes programar y
vienes de un lenguaje tipo C++ seria suficiente para conocer el catalogo de
posibilidades. Aun con esto, lo considero muy, muy basico y falto de la
claridad suficiente para aquellos que requerimos manuales para dummys&lt;/p&gt;

&lt;p&gt;Por su parte la &lt;a href=&#34;https://github.com/ManRR/rust-book-es/&#34;&gt;version dos traducida al español&lt;/a&gt;
fue algo dificil de encotrar. Si, esta completa. No es del todo precisa o
revisada, aunque es lo suficientemente entendible, pero sus defectos resaltan a
simple vista. Por ejemplo, que una funcion este traducida y en el siguiente
parrafo se presente en ingles, o que el palabro sea traducible al español, pero
se quede en ingles. Esta traduccion esta en un git y por lo que se, no tiene
version web&lt;/p&gt;

&lt;p&gt;las intrucciones para generar la version web, son estas:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;git clone https://github.com/ManRR/rust-book-es/
cd rust-book-es/second-edition/es
cargo install mdbook
mdbook build
mi-navegador-web book/index.html
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;el unico sitio donde he visto señas de esta traduccion es un issue en el
repositorio en english del libro&amp;hellip; un issue sin respuestas ni atencion, como el
repo mismo. Si no pueden o no quieren generar la version web, la he colocado en,
&lt;a href=&#34;https://nasciiboy.land/book4all/rust-2nd/&#34;&gt;aqui&lt;/a&gt;. Esta tal cual se genera
(excepto por que cambie el tamaño y ancho del texto). Por lo demas, tiene
fuentes de google y js que le permite ocultar cosas y cambiar el tema (me gusta
el &lt;em&gt;ayu&lt;/em&gt;). Si son rust-fancys pasar por el repo, darle like y colaborar.&lt;/p&gt;

&lt;p&gt;Segun su repositorio, la ultima vez que se toco fue hace 4 meses. Parece algo
desfasada de la version en ingles, pese a ello, es mas extensa y detallada que
lo contenido en la version uno. Esta es la que recomendaria para hispanos.&lt;/p&gt;

&lt;p&gt;(el colega tiene otra traduccion &lt;a href=&#34;https://github.com/ManRR/rust-ffi-omnibus-es&#34;&gt;https://github.com/ManRR/rust-ffi-omnibus-es&lt;/a&gt;
que parece ser una github-wiki, no estoy seguro que sea o si este terminada, ni
como hacer una exportacion a html)&lt;/p&gt;

&lt;p&gt;(el camarada no tiene web o correo. Dejando de lado las licencias, le deje una issue pidiendo permiso para
colgarla en este antro. Tres dias despues, ante el silencio asumo un si)&lt;/p&gt;

&lt;p&gt;&amp;hellip;&lt;/p&gt;

&lt;p&gt;Finalmente, tenemos la &lt;a href=&#34;https://doc.rust-lang.org/book/second-edition/index.html&#34;&gt;version en englis de la version dos&lt;/a&gt;
la mas completa, extensa y actualizada si te entiendes con el lenguaje.&lt;/p&gt;

&lt;p&gt;(En el manual oficial en ingles, por alguna razon colocan el repo &lt;a href=&#34;https://github.com/thecodix/book&#34;&gt;https://github.com/thecodix/book&lt;/a&gt;
como la version traducida al español&amp;hellip; zzzz, apenas y esta traducida la introduccion&amp;hellip;)&lt;/p&gt;

&lt;h2 id=&#34;rust-vs-go&#34;&gt;rust VS go&lt;/h2&gt;

&lt;p&gt;(&amp;hellip; Recordar que solo lo he sobrevolado el lenguaje por dos dias)&lt;/p&gt;

&lt;p&gt;me preguntaba si rust contaria con mejores herramientas para plasmar mi codigo
de manera mas &amp;ldquo;organica&amp;rdquo; y (spoiler) he descubierto que cuenta con mas y
complejas construcciones, pero me costaria decir que son mejores. Interesantes?
si, Armoniosas? n-o-p, Cripticas? segun quien.&lt;/p&gt;

&lt;p&gt;Haber, que tenga punto y coma al final de las declaraciones a lo C se puede
olvidar facilmente y el compilador te lo recordara, ja, ja,
ja. Sorprendentemente, cuando no pones los punto y comas las declaraciones se
comportan como lisp, y eso, eso mola!&lt;/p&gt;

&lt;p&gt;La declaracion de variables, por otro lado es fastidiosa, go es mucho mas
compacto y agradable&lt;/p&gt;

&lt;p&gt;mmm, el manejo de memoria con dueños, pertenecias y prestamos, esta interesante,
parece fastidioso, pero me gustaria ver un Go sin recolector de basura
implementando este concepto&lt;/p&gt;

&lt;p&gt;La forma de dividir el codigo en librerias, modulos y determinar el acceso a
metodos/cosas, me corto totalmente el buen rollo inicial con rust, (・_・ヾ es muy
confuso. Dividir el codigo en modulos, que pueden estar en ficheros o dentro del
mismo modulo, cada uno con acceso publico o no, y como acceder a estos modulos
desde codigo dentro del mismo proyecto y/o carpeta fue algo que no pude
hacer. En verdad es bastante confuso y molesto, parece una chapuza a medio hacer.&lt;/p&gt;

&lt;p&gt;la dinamica del mono-repo de go es mas clara y sencilla, que tu &amp;ldquo;modulo&amp;rdquo; se
aplique a la carpeta actual y puedas invocarla de manera sencilla con su mera ruta y
a su vez se comporte como un (pseudo) obejeto, mola un webo. Rust, aun saliendo
un añito mas tarde no tiene algo tan bonico.&lt;/p&gt;

&lt;p&gt;slices y vectores&amp;hellip; mierda, por que rust? por que se parecen tanto a C++/Java
(lo de los modulos tambien esta muy java). El acceso a metodos/cosas en modulos
tambien muy java&amp;hellip; y los limites de lo que incluyen las macros por defecto o la
libreria estandar tampoco es claro. Ni hablar del &lt;code&gt;&amp;amp;self&lt;/code&gt; en las estructuras o el
&lt;code&gt;&amp;amp;mod self&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&amp;ldquo;interfaces&amp;rdquo; en lugar de herencia, bien. Lo de las &lt;code&gt;&amp;lt;T&amp;gt;&lt;/code&gt;, las enumeraciones
&amp;ldquo;raras&amp;rdquo; y los &lt;code&gt;match&lt;/code&gt; no lo termino de tener claro&amp;hellip;&lt;/p&gt;

&lt;p&gt;documentar las funciones con &lt;strong&gt;markdown&lt;/strong&gt;, jo, jo, jo, que cagada. Dejalos
sueltos y te ponen etiquetas html a lo burro&amp;hellip;&lt;/p&gt;

&lt;p&gt;convertir funciones en funciones de prueba junto al codigo simplemente agregando
indicaciones &lt;code&gt;#[test]&lt;/code&gt;, fabuloso! Tener que incluir estas declaraciones dentro
de un modulo con otra indicacion extraña &lt;code&gt;#[cfg(test)]&lt;/code&gt; y seguir colocando el
&lt;code&gt;#[test]&lt;/code&gt; a cada prueba para que el compilador no las incluya en el binario
final&amp;hellip; una mierda!&lt;/p&gt;

&lt;p&gt;mmmm. esta bien que tengas bonitos poderes configuratorios para el compilador,
pero tienes un monton de posibilidades cripticas que con nada se pueden ir de
madre o ser utilizadas para acallar al compilador, por que? en serio, por que?&lt;/p&gt;

&lt;p&gt;&lt;code&gt;cargo&lt;/code&gt;, mehhh, regular. &lt;code&gt;go&lt;/code&gt; mola mas&lt;/p&gt;

&lt;p&gt;documentacion, supongo que configurando bien el editor con autocompletado y
ayudas debe ser sencillo. Pero &lt;code&gt;go doc&lt;/code&gt; ya solo por mostrarte los prototipos de
las funciones, variables y constantes en una libreria sin recurir a versiones
web es infinitamente mas comodo, ademas funciona sin &amp;ldquo;compilaciones&amp;rdquo; ni
naah. Esto junto a lo java/raro de la organizacion de librerias mataron mis
ansias por el oxido&lt;/p&gt;

&lt;p&gt;como conclusion, rust tiene muchas, muchas muchas herramientas, un lenguaje mas
a los que dare el calificativo de &lt;em&gt;katamari&lt;/em&gt;, un pegote de caracteristicas de
lisp, C++ y &amp;ldquo;cosas&amp;rdquo; que se sienten faltas de una coherencia planificada, como si
lo es Go, donde puedo visitar codigo ajeno casi con la certesa de comprender lo
que sucede&lt;/p&gt;

&lt;p&gt;pero no terminare totalmente desilucionado, me gustaron los comportamientos a lo
lisp y que sea de &amp;ldquo;estilo libre&amp;rdquo; en su escritura. Me jode que no tenga
operadores de (pre|pos)(in|de)cremento, tambien que no tenga &lt;code&gt;for&lt;/code&gt;s de dos/tres
campos y que las cosas distintas a cero no sean siempre verdadero. Oh, los valores
de 128 bits aprueban. No termine de enterarme sobre sus cadenas unicode 8, los
char y si estos son o no runas&amp;hellip;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>SistOp</title>
      <link>https://nasciiboy.land/prog/sistop/</link>
      <pubDate>Sun, 12 Aug 2018 20:00:08 -0500</pubDate>
      
      <guid>https://nasciiboy.land/prog/sistop/</guid>
      <description>

&lt;blockquote&gt;
&lt;p&gt;Este libro busca brindar a estudiantes y docentes de las carreras de
ingeniería en computación, informática, Ciencias de la Computación y similares
un material completo, general y autocontenido sobre la materia de sistemas
operativos. No se asume conocimiento previo sobre la temática, aunque se
utilizarán conceptos de estructuras de datos y algoritmos básicos &amp;ndash;systop&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&#34;fundamentos-de-sistemas-operativos&#34;&gt;Fundamentos De Sistemas Operativos&lt;/h2&gt;

&lt;p&gt;A diferencia de otras entregas con infriccion de &lt;strong&gt;&amp;ldquo;¢ø-π →&amp;rdquo;&lt;/strong&gt; incluido, esta
ocacion he hojeado un material libre como la libertad de tintes
marcadamente a-c-a-d-e-m-i-c-o-s (sin chistes, jocosidad y definitiamente poca
diversion&amp;hellip; exepto cuando es divertido).&lt;/p&gt;

&lt;p&gt;El material ademas de incitar a la copia explicitamente, por su licencia y libre
descarga, tambien tiene un repo desde donde se puede optener el codigo fuente
horneado con una base de org-mode sasonado con LaTeX&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;git clone https://github.com/gwolf/sistop
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;aunque tambien es recomendable asistir a su website (&lt;a href=&#34;http://sistop.org/&#34;&gt;http://sistop.org/&lt;/a&gt;) para
descargar una version en PDF, el codigo fuente de algunos ejercicios (aunque no
es necesario) y/o comprar el libro en formato de arbol muerto o de manera digital.&lt;/p&gt;

&lt;h2 id=&#34;temario&#34;&gt;Temario&lt;/h2&gt;

&lt;p&gt;El texto esta divido en 7 temas principales&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;1. Punto de partida.&lt;/li&gt;
&lt;li&gt;2. Relación con el hardware.&lt;/li&gt;
&lt;li&gt;3. Administración de procesos.&lt;/li&gt;
&lt;li&gt;4. Planificación de procesos.&lt;/li&gt;
&lt;li&gt;5. Administración de memoria.&lt;/li&gt;
&lt;li&gt;6. Organización de archivos.&lt;/li&gt;
&lt;li&gt;7. Sistemas de archivos.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;y tres apendices con contenido concentrado&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;A. Software libre y licenciamiento&lt;/li&gt;
&lt;li&gt;B. Virtualizacion&lt;/li&gt;
&lt;li&gt;C. El medio fisico y el almacenamiento.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;pero podrian considerarse tambien como temas principales&lt;/p&gt;

&lt;p&gt;Los primeros dos apartados, fueron leer un poco el rollo de siempre: &amp;ldquo;la pc&amp;rdquo;, la
evolucion del hardware, interfaces y esas cosas habituales.&lt;/p&gt;

&lt;p&gt;Con el tema 3 inicio lo interesante, pero eche de menos codigo jugoso,
divertido y funcional para ver de que hablaban, quiza por esto y por tratar &amp;ldquo;en
exceso&amp;rdquo; de la concurrencia me parecio pesado. Mas o menos sucedio lo mismo con
el tema 4.&lt;/p&gt;

&lt;p&gt;La divercion llego con la &lt;em&gt;Planificacion de Procesos&lt;/em&gt;, donde la cache, la ram y
cosas de &amp;ldquo;paginacion&amp;rdquo; eran las palabras habituales. No me quedo una vision clara
o precisa de como era aquello, aunque sirvio para ampliar el panorama visto en
incursiones anteriores al asm y sus instrucciones PC, LD, PUSH, POP pero ahora
en sistemas concurrentes tecnicolor!&lt;/p&gt;

&lt;p&gt;Me hubiera gustado una descripcion dedicadaa a exponer la interaccion del sistema
operativo, el juego de las caches y el SMT, con programitas y programitas
concurrentes en paralelo.&lt;/p&gt;

&lt;p&gt;es bastante bonito observar que el esquema de bibliotecas compartidas tiene
buenas y bastantes conveniencias, que me recuerdan a una camiseta&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://nasciiboy.land/img/country-unix.jpg&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;(una de las razones por las que tome C como primer lenguaje y por las que pese a
no hacer nada relevante o complejo en ese lenguaje, sus alumnos escupen en
precencia de las otras corrientes &amp;ldquo;filosoficas del silicio&amp;rdquo;)&lt;/p&gt;

&lt;p&gt;un lenguaje y utilidades de codigo en forma de librerias compartidas! &amp;hellip; pero,
aunque los cimientos siguen siendo esos, las paredes de python, js, javas, &amp;hellip;,
hechas de unicel me siguen generando repulsion cada vez que pienso en esos
lenguejes y sus modas. Todos esos framewors, engines y librerias que se perderan
como lagrimas en la lluvia, aprovechan (aunque sea mediante sucios bindings) las
librerias basicas del sistema? acaso alguno los nuevos lenguajes con sus
&lt;code&gt;packages&lt;/code&gt; e &lt;code&gt;imports&lt;/code&gt; funcionan de manera analoga a las librerias compartidas o
son un monton de instrucciones libertinas sin restricciones ni temor del sistema?
alguna vez surgira un lenguaje que modernice C (sin apaños) que sea base de un
nuevo unix (Go tiene defectirijillos&amp;hellip;) o la complejidad, en colaboracion con
la evolucion del hardware ocultaran los niveles de abstraccion y
heterogeniedades del software de manera &amp;ldquo;organica&amp;rdquo; como dice hacerlo lisp? o, el
navegador son las nuevas &amp;ldquo;librerias compartidas&amp;rdquo;?&lt;/p&gt;

&lt;p&gt;&amp;hellip;&lt;/p&gt;

&lt;p&gt;Los ultimos dos temas tambien son un poco rollo y los apendices, estan
bien&amp;hellip; bueno, todo esta bien, es un libro serio, a un cuarto del camino entre
un acercamiento y consultar la especificacion de un tema concreto.&lt;/p&gt;

&lt;p&gt;Como recomendacion, conocer es mejor que memorizar, la mejor manera de
memorizar es con el uso habitual y si es demaciado especifico como para no
utilizarlo nunca, mejor ir saltando de encabezado en encabezado.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>IntroARM</title>
      <link>https://nasciiboy.land/prog/introarm/</link>
      <pubDate>Thu, 19 Apr 2018 18:36:32 -0500</pubDate>
      
      <guid>https://nasciiboy.land/prog/introarm/</guid>
      <description>&lt;p&gt;&lt;strong&gt;&amp;ldquo;Introducción a la arquitectura de computadores con QtARMSim y Arduino&amp;rdquo;&lt;/strong&gt; es
un libro que encontre (el año pasado) en &lt;a href=&#34;https://openlibra.com/es/book/introduccion-a-la-arquitectura-de-computadores-con-qtarmsim-y-arduino&#34;&gt;openlibra&lt;/a&gt;
cuya insulsa portada (como casi todo lo de openlibra) oculta un material
bastante didactico (je, esto ultimo a consideracion&amp;hellip; respecto a los otros
titulos de openlibra), ameno, directo e
interesante sobre la arquitectura de computadoras.&lt;/p&gt;

&lt;p&gt;El libro centra su atencion en la arquitectura ARM de 32 bits desplegando
ejemplos en ensamblador (instrucciones Thumb Cortex-M0 estilo GNU) y luego
aplicando (mas o menos) practicamete los conocimentos sobre la placa
&lt;a href=&#34;https://www.arduino.cc/en/Guide/ArduinoDue&#34;&gt;Arduino Due&lt;/a&gt; [ATSAM3X8E]&amp;hellip; para
encender y apagar un led! (esto es si es un &amp;ldquo;hello word&amp;rdquo; bien rudo!)&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://nasciiboy.land/img/ArduinoDue.jpg&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;En realidad, ni el asm, ni la placa arduino tienen mucha importancia pues no
dejan de ser un conducto para mostrar los entresijos y filosofias relacionadas
con el funcionamiento conceptual de los procesadores, su programacion y luego
mas tarde su interaccion y gestion con dispositivos de entrada y salida
varios. De hecho, y aunque el ensamblador que nos muestra el libro es bastante
bonito (quitando su manera extrabagante de pasar datos de memoria a los registros y
viceversa), en todo el libro, no se expone ninguna razon para utilizar
ensamblador, mas alla (claro esta) de poder ver su funcionamiento en vivo y a
todo c-o-l-o-r.&lt;/p&gt;

&lt;p&gt;y bueno, el libro, codigo y herramientas necesarias para su estudio se
encuentran en la siguiente direccion (oficial): &lt;a href=&#34;http://lorca.act.uji.es/libro/introARM/&#34;&gt;http://lorca.act.uji.es/libro/introARM/&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;para que la programacion en asm no quede como un ejercicio autista donde
tenemos que imaginar que esta pasando, se propone utilizar una interfaz grafica
de un emulador de arm (&lt;code&gt;spim&lt;/code&gt;) llamada &lt;a href=&#34;http://lorca.act.uji.es/project/qtarmsim/&#34;&gt;QtARMSim&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;segun las intrucciones de la pagina tendriamos que seguir los siguientes pasos
para hacernos con &amp;ldquo;los programas&amp;rdquo;(, o asi los hice yo):&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;apt install gcc-arm-linux-gnueabi
apt install python3-pyside python3-pip ruby spin
pip3 install qtarmsim

# si se quiere actualizar
# pip3 install --upgrade qtarmsim
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&amp;hellip; es curioso, como un libro centrado en asm y que en sus propias paginas
expone la necesidad de hacer que la interaccion del usuario con un programa
tiene que ser practica, tubieron la brilante idea de implementar el entorno
grafico utilizando (asqueroso) python&amp;hellip; no es que la interfaz sea fea, cargada
o innecesaria ni mucho menos (mi mas sincera alabanza), sino que a la hora de interactuar con el editor de
texto incorporado, el lag puede ser insufrible (puto python). Otra cosa curiosa
del p-y-t-h-o-n, ocurre cuando instalas sus mierdas y luego al ejecutarlas en lugar de
&amp;ldquo;interpretar&amp;rdquo; los programas, te aparecen sendos mensajes de error, como me
sucedio en freidora 27. Tras varios intentos, apaños y busquedas por internet,
la solucion menos dolorosa fue utilizar una maquina virtual con debian e ir a
probar suerte&amp;hellip;&lt;/p&gt;

&lt;p&gt;no veia muy claro eso de instalar virtualbox, asi que por mera investigacion
prove con &lt;code&gt;gnome-boxes&lt;/code&gt; (que ya venia instalada). Baje la iso estable
(DVD|torrent) de debian 9.4.0 y segui la sujerencia de gnome-cajas en hacer una
instalacion rapida (o algo asi). Aproximadamente 15 minutos mas tarde,
unicamente ingresando el nombre de usuario, contraseña y dimencion de la
particion, tenia un debian fluido y eficiente corriento con 2 procesadores,
21GiB de disco y 1GiB de ram (con Gnome Shell) consumiendo ~500MiB de ram y muy
poco consumo de procesador&amp;hellip; hasta mover-una-ventana-con-el-raton-a-lo-loco!&lt;/p&gt;

&lt;p&gt;me sorprendio lo rapido que arranca una maquina virtual en (quemu) boxes, lo
ligerita que va, e igualmente lo rapido que se apaga. Como puntos negativos dire
que la captura del teclado nunca se hizo presente y que fue necesario
reconfigurar el teclado en la maquina virtual (a programmer dvorak), porque
venia en ingles; asi que todo lo ingresado estaba mal, mas al contar con un
portapapeles (de texto) compartido se puede escribir en la maquina anfitrion
e ir a pegar (con tecla de opciones(?)) en cualquier lado.&lt;/p&gt;

&lt;p&gt;pero bueno, todo esto no era sobre gnome-boxes, era sobre el libro. Tras probar
que el entorno funcionaba sin inconveniente alguno sobre debian y que el entorno era
intuitivo y despliga la informacion suficiente y de manera comoda, continuemos con la
travesia.&lt;/p&gt;

&lt;p&gt;Los ejercicios en ensamblador son pequeños, claros y lo suficientemente
explicados como para no perderse. Hecho en falta que en la pagina oficial, no se
incluya un comprimido con el codigo en ensamblador del libro, asi que
&lt;a href=&#34;https://nasciiboy.land/data/asm-code.zip&#34;&gt;aqui&lt;/a&gt; esta una compilacion en zip.&lt;/p&gt;

&lt;p&gt;A diferencia de lo que comentaba sobre el post del tutorial del
&lt;a href=&#34;../z80-spectrum/&#34;&gt;z80-speccy&lt;/a&gt; en este material se dedican varias secciones a
explicar estrategias y convenciones sobre el paso de parametros entre las
subrutinas. Ademas, como no podia ser de otra manera, el procesador y su
capacidades tambien evolucionaron. En este procesador tenemos 16 registros
ortogonales de 32 bits&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;r0-r3  &amp;gt; paso y recivo de parametros a subrutinas&lt;/li&gt;
&lt;li&gt;r4-r12 &amp;gt; libres para el programador&lt;/li&gt;
&lt;li&gt;r13    &amp;gt; SP (puntero de pila)&lt;/li&gt;
&lt;li&gt;r14    &amp;gt; LR (registro enlace)&lt;/li&gt;
&lt;li&gt;r15    &amp;gt; PC (putero del programa)&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;las instrucciones son menos complejas que las del z80, vastante mas comodas como
&lt;code&gt;add rn, rn, rn&lt;/code&gt; donde se pasan dos registros a sumar y un registro donde
depositar el resultado. Otro ejemplo seria la intruccion de uso de la pila &lt;code&gt;push
{rn, rn, rn-rn}&lt;/code&gt; y su complemento &lt;code&gt;pull {rn, rn, rn-rn}&lt;/code&gt; que no solo puede pasar
mas de un registro, tambien un rango entero de registros, wouau puro rock-and-roll!&lt;/p&gt;

&lt;p&gt;como comentaba al inicio, aun tomando la lectura sin intenciones de aplicar sus
enseñansas codificadoras, el enfoque didactico es muy estimulante para el que
tenga interes en conocer los entresijos rugosos de un &amp;ldquo;computador&amp;rdquo;, que por aca
ni se mitifica, ni se espanta al lector con leyendas medievales de complejidades
imposibles (como muchos hacen con los niñatos y les dicen que p-y-t-h-o-n &amp;ldquo;es
bonito y facil&amp;rdquo;, ha, una guerra es lo que les hace falta)&lt;/p&gt;

&lt;p&gt;La segunda parte del material continua su labor didactica ahora mostrando como
interactua el procesador con el mundo. Tambien pasa bastante tiempo liandola con
el ensamblador y el arduino, mas, no termino de enterarme a cuenta de
que. Aunque me parece genial que se pongan a educar sobre el asm, el arduino y
su entorno no tienen pinta de estar prestos a liarse a programar en otra cosa
que no sea C/C++, pero bueno, tampoco es que me enoje ni nada similar&amp;hellip; (por
que, no tomar una consola de videojuegos arm como conducto?&amp;hellip; si la hay&amp;hellip; o
es que no&amp;hellip;)&lt;/p&gt;

&lt;p&gt;de esta parte del libro, destaco las secciones de interrupciones y conocer al
(voz cavernosa y con eco) &lt;strong&gt;DMA&lt;/strong&gt; (/voz cavernosa y con eco) (Direct Memory Access)&lt;/p&gt;

&lt;p&gt;finalmente, el ultimo tercio del liblo, esta formado por una referencia (muy)
tecnica de las E/S, el reloc e interrupciones disponibles en el arduino. Luego
un par de resumenes del asm y tambien la infaltable seccion de sistemas de
numeracion, para finalmente cerrar con indices y cosas de libros&lt;/p&gt;

&lt;p&gt;Ahora, como con el tutorial del z80, muestran como declarar if&amp;rsquo;s, else&amp;rsquo;s, for&amp;rsquo;s y
while&amp;rsquo;s, pero donde esta el siempre amado y necesario &lt;strong&gt;&lt;code&gt;switch&lt;/code&gt;&lt;/strong&gt;?&lt;/p&gt;

&lt;p&gt;Para terminar, en open libra hay un material mas o menos relacionado, con un
temario algo similar &lt;a href=&#34;https://openlibra.com/es/book/arm-cortex-m-practico-introduccion-a-los-microcontroladores-stm32-de-st&#34;&gt;ARM Cortex-M práctico: Introducción a los microcontroladores STM32 de St&lt;/a&gt;
que va mas de C. Tiene el pecado de aplicar sus enseñansas sobre aplicaciones
ventaneras, pero rescato su explicacion sobre las ramas de los procesadores
ARM.&lt;/p&gt;

&lt;p&gt;Si os gustan los libros, ir a openlibra, poner 5 estrellas, like &amp;amp; subscribe&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Desing Patterns (GoF)</title>
      <link>https://nasciiboy.land/prog/gof/</link>
      <pubDate>Tue, 13 Mar 2018 20:55:49 -0600</pubDate>
      
      <guid>https://nasciiboy.land/prog/gof/</guid>
      <description>

&lt;p&gt;Cuando era &amp;ldquo;pequeño&amp;rdquo;, al oir &lt;em&gt;Patrones de diseño&lt;/em&gt;, lo unico que mi diminuta mente
consebia era a un grupo de programadores a tope de egocentrismo, gozosos de
inventarse terminos rimbombantes y pretenciosos, que solo ellos pudieran
entender mientras reian y con una mano sujetaban sus monoculos y con la otra
un a-y-h-p-a-d&lt;/p&gt;

&lt;p&gt;En aquella epoca de ignorancia, cada vez que iniciaba a programar algo
medianamente complejo, siempre me preguntaba si no existia algun escrito
perdido que proporcionara las herramientas para extructurar el codigo de forma
organica, audaz e inteligente, como si de diseñar un organismo se tratara, donde
todo funcionara en una armonica melodia y cada segmento de codigo tomara el
lugar de un instrumento musical identificable, a la vez que se mezclaba con
todos los demas.&lt;/p&gt;

&lt;p&gt;Resulta pues, que sin proponermelo, fuera por la disposicion del codigo de
ejemplo en los libros, por el uso de comandos del sistema o por necesidad y
cabezoneria de resolver ciertos problemas, algunas de estas formas misticas de
estructurar el codigo fueron apareciendo e incorporandose en forma de
experiencia practica, no muy racionalizada, pero aun asi interiorizada en los musculos&lt;/p&gt;

&lt;p&gt;mas sorprendente aun, fue descubrir, que estas &amp;ldquo;tecnicas para organizar codigo&amp;rdquo;
ya existian y no estaban ocultas. Resulta que aquella palabra extravagante
&lt;em&gt;Patron de diseño&lt;/em&gt; era eso mismo que estube buscando desde el inicio, &amp;ldquo;el metodo
para estructurar el codigo de una forma razonable, inteligente (y en ocaciones organica)&amp;rdquo;&lt;/p&gt;

&lt;p&gt;&amp;hellip; y el material donde se presentaron a sociedad los patrones lleba por nombre
&lt;em&gt;Desing Patterns: Elements of Reusable Object-Oriented Software&lt;/em&gt; o tambien
apodado como &lt;em&gt;GoF&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;&amp;hellip; y la mejor manera que encuentro para presentar el material, no es otra que
dejar unos extractos:&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Los estudios de programadores expertos de lenguajes convencionales muestran
 que el conocimiento y la experiencia no se organizan simplemente en torno a la
 sintaxis, sino en estructuras conceptuales mayores, tales como algoritmos,
 estructuras de datos y modismos, asi como en maneras de lograr un determinado
 objetivo. Los diseñadores probablemente no piensan en la notacion
 que estan usando para documentar su diseño, sino que intentan comparar la
 situacion actual de diseño con planos, algoritmos, estructuras de datos y
 modismos que han aprendido en el pasado.&lt;/p&gt;

&lt;p&gt;Los informaticos nominan y catalogan las estructuras de datos y algoritmos,
 pero no suelen dar nombre a otros tipos de patrones. Los patrones de diseño
 proporcionan un vocabulario comun que los diseñadores usan para comunicar,
 documentar y explorar alternativas de diseño. Los patrones de diseño hacen que
 un sistema parezca menos complejo, permitiendonos hablar de el con un mayor
 nivel de abstraccion del que permite una notacion de diseño o un lenguaje de
 programacion. Los patrones de diseño elevan el nivel en el que diseñamos y
 discutimos diseños con nuestros colegas.&lt;/p&gt;

&lt;p&gt;Una vez que haya absorbido los patrones de diseño, su
 vocabulario de diseño cambiara casi con toda seguridad. Hablara directamente
 en terminos de los nombres de los patronesde diseño. Se oira asi mismo decir
 cosas como &amp;ldquo;aqui deberiamos usar el patron Observer&amp;rdquo;, o &amp;ldquo;extraigamos una
 estrategia de estas clases&amp;rdquo;.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;tambien:&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Una de las mejores cosas de los patrones es que apartan las decisiones de
diseño del reino de la mera intuicion. Permiten que los autores sean
explicitos sobre las ventajas e inconvenientes que proporcionan, lo que
facilita ver los fallos de sus patrones y discutir con ellos.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;y finalmente la definicion misma de los patrones ::&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Un patron de diseño nomina, da los motivos y explica sistematicamente un
diseño general que resuelve un problema de diseño recurrente en los sistemas
orientados a objetos. Describe el problema, la solucion, cuando aplicar este
y sus consecuencias. Tambien ofrece trucos de implementacion y ejemplos. La
solucion es una disposicion general de clases y objetos que resuelven el
problema. Esta adaptada e implementada para resolver el problema en un
determinado contexto.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;imposible explicarlo mejor!&lt;/p&gt;

&lt;p&gt;Solo unas breves anotaciones personales para el yo del pasado:&lt;/p&gt;

&lt;p&gt;Primero, al libro le hace falta codigo &amp;ldquo;real&amp;rdquo; (almenos en la vercion que poseo.
La vercion en ingles menciona un CD con material, pero desconosco su alcance).
Se presentan fragmentos de codigo solo lo suficientemente desarrollados
como para (si se presta atencion y se guarda dicho codigo con avaricia) poder
crear una implementacion &amp;ldquo;basada en&amp;rdquo; y hacerla funcionar. Esto no cumple
demaciado con mis estadares didacticos para subnormal, pero es mejor que nada.&lt;/p&gt;

&lt;p&gt;Segundo, se utilizan diagramas algo cripticos con una sintaxis &amp;ldquo;inventada y
vieja&amp;rdquo;, asi que revisar el apendice que habla de ello, para darle algo de
sentido. Ademas para el codigo utilizan un C++ &amp;ldquo;primitivo&amp;rdquo; y algo de otro
lenguaje llamado smalltalk, que aunque sencillo (en el caso de tener un bagaje
minimo con C++) seguramente no sera donde termines aplicando los patrones&lt;/p&gt;

&lt;p&gt;y finalmente, La secciones de Implementacion, Codigo de Ejemplo y Usos Conocidos
de cada patron, en una primer lectura pueden abrumar y/o quedar en nada. Son
muchos patrones (aunque varios con aplicaciones &amp;ldquo;similares&amp;rdquo;), lo mas sensato es
enterarse donde, como y para que aplicarlos, asociarlos con su nombre y luego ya
si se da la oportunidad, investigar como implementar una vercion en codigo
practico y de ser posible, implementarla en el lenguaje donde te sientas comodo&lt;/p&gt;

&lt;p&gt;y ya esta, este jodido año estara en su mayoria dedicado a conocer, implementar
y adaptar patrones. Chahh, con esto y dominar las interfaces/composicion (y
canales) de Go sera mas que suficiente&amp;hellip; si no se cuela otro hobbie por
medio&amp;hellip; asm para gameboy (love2d, rust, (e)lisp, asm de arduino, haskell,
educacion escolarisada, trabajo(???)), no te acerces, alejate, a-l-e-j-a-t-e&lt;/p&gt;

&lt;h2 id=&#34;cobaya&#34;&gt;cobaya&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;git clone https://github.com/nasciiboy/GoF_Desing-Patterns
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Como cualquier material que me importe un poco, Patrones de Diseño (GoF) ha
valido una adaptacion al formato de marcas (siempre en desarrollo, lento, lento
desarrollo del) morg (patrones == mas-desarrollo).&lt;/p&gt;

&lt;p&gt;La mision comenzo a principios de noviembre (&amp;hellip; supongo, porque el primer commit
es del 2 de diciembre). El material de referencia fue un pdf
infecto en español de aquellos que traen &amp;ldquo;fotocopias&amp;rdquo;.&lt;/p&gt;

&lt;p&gt;Lo primero fue transcribir a mano alzada palabra a palabra. Al principio probe a
aplicar un ocr, pero la tecnologia esa aun entrega resultados bastante jodidos,
sobre todo si como en este caso el texto no se ve y esta dispuesto de forma
optima. Lo mas dificultoso, fueron las secciones finales del PDF, pues tenia paginas en
desorden, asi como algunos bordes de texto desaparecido.&lt;/p&gt;

&lt;p&gt;Luego de la mecanografiada vino una revision superficial, y al mismo tiempo (con
otro pdf algo infecto) la adaptacion del material en ingles al morg,
que es de donde se extraen las imagenes en el producto final. Al principio la
idea era hacer una version en SVGs de las imagenes, tanto para la version en
ingles como en español&amp;hellip; pero es mucho, mucho trabajo y en este momento no
tengo el interes (o necesidad) para hacerlo.&lt;/p&gt;

&lt;p&gt;ya terminada tanto la adaptacion en ingles (sin correccion alguna y apenas
uno que otro enfasis del texto, solo adaptacion) como la primer revision
del texto en español, llego el momento de leer a detalle el material y aprender
formalmente, o esa era la idea. En la segunda revision, se corrigieron muchas
distografias, algunas tan aberrantes como &lt;strong&gt;patrnose&lt;/strong&gt; (patrones), lol, como es
posible escribir de esa manera? digo, entiendo substituir un caracter por alguno
en su cercania en el teclado, pero cambiar varias letras de posicion unicamente
puede revelar desordenes cognitivos exacervados &amp;hellip; ademas de eso, se corrigieron &amp;ldquo;lineas
repetidas&amp;rdquo;, palabras &amp;ldquo;inventadas&amp;rdquo; y oraciones no incluidas.&lt;/p&gt;

&lt;p&gt;No todos los errores los inclui, algunos ya estaban presentes en el material
traducido y los deje tal cual.&lt;/p&gt;

&lt;p&gt;Para las regiones en el PDF que no estaban visibles, utilice el traductor y la
version en ingles&lt;/p&gt;

&lt;p&gt;Finalmente el repositorio cuenta con versiones en html de los materiales, solo
por que el exportador del morg lo permite y para que quien no concuerde con mi
vision de documentacion en texto plano disponible directamente en el &amp;ldquo;editor&amp;rdquo; de
texto (emacs (por el momento como apaño) y con un marcador de por medio) tambien pueda aprovecharlo.&lt;/p&gt;

&lt;p&gt;si te es de utilidad y ademas corriges algunos palabros y encima quieres
agregarlos al repo pero sin que quede registrado, puedes enviarme el texto
corregido tal cual por correo (ademas de la cuenta habitual (ver el fondo),
tengo cuenta en protonmail, tambien como nasciiboy), cifrar y tomar
consideraciones extra&amp;hellip; claro, solo si se considera que difundir la cultura (en
todas sus formas) es incorrecto.&lt;/p&gt;

&lt;p&gt;El resto, como revisar, enfatizar y corregir la version en ingles, asi como todo
lo relacionado con las imagenes, lo dejo en manos de las generaciones por venir&lt;/p&gt;

&lt;p&gt;(o coloque un mandelbrot como &amp;ldquo;caratula&amp;rdquo; del libro, porque no se&amp;hellip; hay algo que
diga mas patron y diseño que un mandelbrot?)&lt;/p&gt;

&lt;p&gt;happy typping!&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Java &amp; Me(h)</title>
      <link>https://nasciiboy.land/prog/javame/</link>
      <pubDate>Fri, 10 Nov 2017 14:57:41 -0600</pubDate>
      
      <guid>https://nasciiboy.land/prog/javame/</guid>
      <description>

&lt;p&gt;Por que &lt;a href=&#34;https://picodotdev.github.io/blog-bitix/2015/05/10-razones-para-seguir-usando-java/&#34;&gt;razones&lt;/a&gt;
concientes y sin coercion externa aprender java?&lt;/p&gt;

&lt;p&gt;en mi caso, hice un solemne juramento de no aprender java (y quiza python,
js&amp;hellip;) y en general nada 7 veces mas lento que C&amp;hellip; porque cualquier lenguaje un orden
de magnitud mas lento que C, es directamente una basura&amp;hellip; o tiene un ambito de uso
extremadamente especifico, como servir para crear extensiones o como
prompt. Fuera de este uso, nadie &amp;ldquo;serio&amp;rdquo; sacarlos deberia. Crear programas completos
directamente en esos lenguajes es una guarrada y una falta de
respeto por el espiritu que habita en el silicio. Por decir algo, es casi tan
aberrante como mi forma de escribir&amp;hellip;&lt;/p&gt;

&lt;p&gt;pero bueno, hace mucho tiempo que java merodea por el mundo, y en general es
unas 4-6 veces mas lento que C, asi que entra en la zona estelar de los lenguajes que
permiten la existencia de agua liquida. Entonces, por que mantenia una
resistencia interna a aprender java?&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;todas las cosas hechas con Java dan la sensacion de estar lagueadas. (Arde en el
infierto android)&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;deriva de C++ y C++ no es un lenguje agradable para programar (si tocas todas
sus posibilidades), por que tiene un monton de caracteristicas obscuras y
sutiles, que lo hacen absurdamente complejo, dificil de leer e imposible de
dominar (o no)&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;hiede a empresarial, y las cosas empresariales no son divertidas, y yo viene a
la programacion para estar cool (&amp;lt;== obscura referencia al manga GTO)&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;pero estonces, por que siquiera de estas explicaciones, que hechos se han
conjurado para ceder al mal?&lt;/p&gt;

&lt;p&gt;basicamente, mientras continuo el trepidante camino en la programacion
autodidacta sin tener idea (de mates, english o adonde dirigirme), y a medida
que va creciendo la complejidad de las cosas que &amp;ldquo;planeo&amp;rdquo; programar, la
intuicion y sentido comun me dice que muchos de esos secretos ancestrales se
encuentran alla afuera&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://nasciiboy.land/img/believer.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;o en el peor de los casos, estan cerca de ser ser promulgados, por alguien&amp;hellip;&lt;/p&gt;

&lt;p&gt;como apenas inicio mis andansas por el mundo de las mategicas y el engrish aun
es arido en sus detalles, para no desaprobechar ese regalo llamado ser el
fracasado treinton sin empleo que se queda en la pc todo el dia sin hacer nahhh
y que vive permanentemente en la banca rota&amp;hellip; mejor leer cosas programacionales
en español, un  inquietante campo superpoblado con material que utiliza a
java como lenguaje universal, asi que por el bien del mundo, a joderse!&lt;/p&gt;

&lt;h2 id=&#34;instalar-java&#34;&gt;Instalar Java&lt;/h2&gt;

&lt;p&gt;Casi todos los sistemas del Ñu traen un java instalado por defecto, como en el
caso de freidora el openjdk-1.8, pero con esto no nos vasta para comenzar a
&amp;ldquo;compilar&amp;rdquo; programos, hace falta instalar el paquete &lt;em&gt;devel&lt;/em&gt; para optener el
programa &lt;code&gt;javac&lt;/code&gt;. Ya que estamos (y por que en freidora 27 aparece en los repos)
pues mejor instalar lo ultimo de lo ultimo, por si lanzamos pestes, sus fancis no digan
que la causa es utilizar una version desfasada; ademas es casi completamente
compatible con el codigo vintage!&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;# paquetes del java-9
dnf -y install java-9-openjdk java-9-openjdk-devel

# le decimos al sistema que este va a ser el &amp;quot;java bueno&amp;quot;
# nos preguntara con un numero cual java poner por defecto
# el que tenga un =nueve= sera el efectivo
update-alternatives --config java

# lo mismo que el anterior pero para el javac
update-alternatives --config javac

# comprobamos que la version es correcta
java -version
javac -version

# no se que es esto, pero parece importante para el futuro
dnf -y install maven
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;luego, tenemos que configurar en nuestro shell las rutas donde el java buscara
las &amp;ldquo;librerias&amp;rdquo; para compilar sus cosas. Esto se hace estableciendo la variable &lt;code&gt;CLASSPATH&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;En &lt;code&gt;fish&lt;/code&gt; ha sido asi (&lt;code&gt;~/.config/fish/config.fish&lt;/code&gt;)&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;set --export CLASSPATH  &#39;/usr/share/java:.:/home/mi-usuario/.java&#39;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;solo acepta rutas absolutas. Las rutas se separan por dos puntos (&lt;code&gt;:&lt;/code&gt;).  La
primera es donde esta la libreria estandar (en freidora), la segunda, &amp;ldquo;el
punto&amp;rdquo;, es para que busque en el directorio actual, y la tercera, para colocar
cualquier libreria externa que me encuentre por el internet sin comprometer el
sistema demaciado, y para no hacer cosas de root con frecuencia, ademas es una
carpeta oculta para no molestar&lt;/p&gt;

&lt;p&gt;oh, como el java nueve es muy moderno, incluye un comando de tipo REPL, que
significa que podemos programar de forma interactiva. Solo hay que typear
&lt;code&gt;jshell&lt;/code&gt; y voala, a programar sin compilaciones y con mucho
l-a-a-g-g-g-g-g-g. Este tipo de cosillas y sus tiempos de respuesta me ponen
nostalgico, como que estubiera en otro tiempo y asi fuera programar &amp;ldquo;de verdad&amp;rdquo;,
fuera de sarcasmos, tiene su encanto!&lt;/p&gt;

&lt;p&gt;encontre sobre esto del &lt;code&gt;jshell&lt;/code&gt; en un libro (en ingles) llamado &amp;ldquo;Java 9
Programming By Example&amp;rdquo; de facil optecion, al menos en un sito llamado
&lt;em&gt;allitebooks&lt;/em&gt;. jo, jo, jo, que jocosos los de la editorial del libro, que te
insitan a informar si lo encuentras por la red, me dan ganas (si lo continuo y es
interesante) de cobayisarlo, ya veremos&lt;/p&gt;

&lt;h2 id=&#34;el-editor&#34;&gt;El editor&lt;/h2&gt;

&lt;p&gt;fuuuhh, aver, en emacs hay un modo para esto, es decir lo basico, resaltado e
indentacion, si quieres mas pues a buscar por vias alternas.&lt;/p&gt;

&lt;p&gt;Hay un modo externo que se llama &lt;strong&gt;jdee&lt;/strong&gt;, con resaltado de errores,
autocompletado, documentacion, dos espacios de indentacion por defecto y otras
promesas mas, aunque la instalacon en mi caso no fue bien, creo que es algo
relacionado con las rutas de java.&lt;/p&gt;

&lt;p&gt;Al ver que la cosa no iba muy fina, reverti los cambios y deje el emacs como al
inicio y toco ir por la segunda alternativa: un viscoso, (d)oloroso, consumista y
lentorro &lt;strong&gt;IDE&lt;/strong&gt;&amp;hellip; bueno la prueba se limito a &lt;strong&gt;eclipse&lt;/strong&gt;, la unica conclusion
que puedo dejar sobre la experiencia, es que mi maquina no es apta para correr
estas cosas para developers modernos&lt;/p&gt;

&lt;p&gt;asi que ha regresar al emacs &amp;ldquo;a pelo&amp;rdquo;&lt;/p&gt;

&lt;h2 id=&#34;documentacion&#34;&gt;Documentacion&lt;/h2&gt;

&lt;p&gt;Esto es un punto bastante jodido con java, no tengo ni puta idea sobre como se
organiza la libreria estandar, ni que tan lejos llega o como se utiliza. Para
volverlo aun mas complejo no hay documentacion en linea de comandos similar a
&lt;code&gt;man 3&lt;/code&gt; o &lt;code&gt;go doc&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;La opcion de emergencia fue bajar los docs de Java para &lt;code&gt;zeal&lt;/code&gt; y tampoco fue de
mucha ayuda, de nuevo no tengo idea de como se organiza|utiliza la libreria
estandar y abrir un libro (pdf en este caso) &lt;em&gt;especializado&lt;/em&gt; para averiguar que
clase se utiliza para tal cosa, o como hereda de tal otra, no es una opcion que pueda
contemplar&lt;/p&gt;

&lt;h2 id=&#34;thinking-in-java-2-da-edicion&#34;&gt;Thinking in JAVA, 2^da edicion&lt;/h2&gt;

&lt;p&gt;Vamos con la carnita, un libro viejuno de Java 2, de los años 2000, donde hablan
de las guerras de navegadores con el netscape vs el explorer y podian ejecutar
el java salvagemente con etiquetas html!&lt;/p&gt;

&lt;p&gt;Tome este libro por que el codigo del autor me parecio mas que bonito en su
libro de Piensa en C++ (era joven). Tambien por que fue lo que encontre en
español, por que tiene muchas paginas, por que sale rapido en una busqueda con
terminacion &lt;em&gt;pdf&lt;/em&gt; y por que el codigo fuente de los ejercios tiene &lt;em&gt;dos
espacios de indentacion&lt;/em&gt;, haci lo hacia Stallman, haci lo hacia este autor, haci
lo hago yo y haci lo haran mis decendientes sinteticos.&lt;/p&gt;

&lt;p&gt;El libro tiene una version 4, que data del 2006, en ingles asi que esta
descalificado, pero desde la pagina del autor pueden descargar el codigo de los
ejemplos y el libro (en ingles) en formato html de esta 2^da edicion. Aqui el &lt;a href=&#34;http://www.mindviewinc.com/downloads/TIJ-2nd-edition.zip&#34;&gt;enlace al
zip&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;o, y por si el enlace esta roto, bajarlo de &lt;a href=&#34;https://nasciiboy.land/data/TIJ-2nd-edition.zip&#34;&gt;aca&lt;/a&gt;,
a esta le aplique un &lt;code&gt;dos2unix&lt;/code&gt; a todos los ficheros, para no tener que ver el
&lt;em&gt;DOS&lt;/em&gt; en el emacs&lt;/p&gt;

&lt;p&gt;antes de continuar y si se quiere seguir el libro, es importante que
descomprinas el zip, tiene una carpeta con el libro y otra con el codigo fuente,
toma esta ultima y mueve/copia la carpeta &lt;code&gt;com&lt;/code&gt; a donde sea
que tengas apuntando la variable &lt;code&gt;CLASSPATH&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Una ves hecho esto vasta con entrar a la carpeta que se este estudiando y hacer
un &lt;code&gt;make&lt;/code&gt;, casi todos los ejemplos compilan, excepto en los capitulos (creo que)
12 en adelante, cuando se pone a hacer cosas con GUI y por que tiene una feo
fetichismo de incluir sus librerias en cada ocacion.&lt;/p&gt;

&lt;p&gt;Ahora si, que tal el libro?&lt;/p&gt;

&lt;p&gt;un libro con DLC&amp;hellip; el autor aprovecha cada ocacion que tiene para mencionar que
puedes bajar tal o cual material suyo en su web, y que por una modica cantidad
te ofrece &lt;del&gt;droga&lt;/del&gt; las respuestas a los ejercicios, el resto, por supuesto
[inserta aqui efecto de susurrar al oido] &lt;em&gt;es gratis&lt;/em&gt;. Algo molesto en mi opinion,
mas para venir en un libro comprado, con mencionarlo en el prefacio bastaba&lt;/p&gt;

&lt;p&gt;Los primeros capitulos (hasta antes de la aparicon de herecia e interfaces) son bastantes
llebaderos, explica de forma condesada y clara muchas cosas, como que jodidos es
un recolector de basura (junto con sus inconvenientes que dan miedo), que es un
hilo del sistema, por que java esta diseñado como esta diseñado, su evolucion,
carencias y defectos&lt;/p&gt;

&lt;p&gt;en el capitulo de la herencia las cosas se ponen turbias, te agobia con
un monton de caracteristicas obscuras. Fue entonces cuando el formato &amp;ldquo;Catalogo
de referencia&amp;rdquo; del libro salto a la conciencia. Seguramente por la propia
naturaleza ecleptica de java. El autor no duda en mencionar cada una de sus multiples
opciones y capacidades, lo que sumado a que el libro no te enseña a hacer nada
(por decirlo de alguna manera), hace dificil retener el sin numero de opciones&lt;/p&gt;

&lt;p&gt;Cuando la cantidad de informacion es abrumadora como en este caso, recomiendo
entrar en modo paseo por tienda, ver que hay y si el vendedor se acerca, decirle que no
moleste. Todas estas opciones solo se retienen en el cortex luego que se
presentan los problemas mientras se va programando, ese es el momento donde
saber que exite una cosa (aunque no como hacerlo) regresa a nuestro recuerdo y
podemos ejecutar el aprendizaje teorica y practimamente, y quiza si es posible
con aplicaciones recurrentes, memorizarlo&lt;/p&gt;

&lt;p&gt;cerca de la pagina 450 el material comenzo a parecer pesado.&lt;/p&gt;

&lt;p&gt;Ya que la principal motivacion de leer el libro era enterarme que estan
exponiendo en algun ejemplo corto de algun libro intereante, no dedicarme a
programar en java, me plantee dejar la lectura y pasar a otra cosa. Pero
continue al siguente capitulo y aparecieron cosas relevantes. Si tambien vas
en modo paseo, almenos lee el inicio de cada capitulo y alguna seccion relevante&lt;/p&gt;

&lt;p&gt;Como conclusion el libro es eso, un buen material de consulta.&lt;/p&gt;

&lt;p&gt;Sobre java:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;Es un lenguaje pegote (o katamari), se le adiere todo, un monton de
posibilades que incitan a hacer guarradas y no enterarte de lo que algun
programador con preferencias exquisitas este haciendo&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;La jerarquia, asociacion y documentacion de sus clases no es intuitiva&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&amp;ldquo;compilar&amp;rdquo; y &amp;ldquo;cargar&amp;rdquo; (&lt;code&gt;javac&lt;/code&gt;, &lt;code&gt;java&lt;/code&gt;) es un rollo y se siente lento&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;El lenguaje no esta diseñado, es 🌈evolutivo🌈. Toma la inco(nsist|her)ente base de C++, la simplifica,
y hace mas verbosa, un monton de clases, enfoques, palabras clave y especificadores con
multiples significados que enturbian la 🌈experiencia🌈&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;y ya! bienvenidos los insultos y duelos a muerte!&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>SICP (proyecto de traduccion)</title>
      <link>https://nasciiboy.land/prog/dot-slash-sicp2es/</link>
      <pubDate>Fri, 07 Jul 2017 18:27:56 -0500</pubDate>
      
      <guid>https://nasciiboy.land/prog/dot-slash-sicp2es/</guid>
      <description>

&lt;p&gt;&lt;img src=&#34;https://nasciiboy.land/img/jelly.jpg&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;o en otras palabras dadme pasta! (no en galletas)&lt;/p&gt;

&lt;h2 id=&#34;faq&#34;&gt;faq&lt;/h2&gt;

&lt;p&gt;&lt;strong&gt;por que?&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;para traducir un libro de muchas lineas al español, el &lt;strong&gt;Structure and
Interpretation of Computer Programs&lt;/strong&gt;, tambien conocido como &lt;em&gt;SICP&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;por que sicp?&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;en los listados de lecturas para programadores suele aparecer inevitablemente
y en los primeros puestos&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;puedo traducirlo y combrar por ello, sin romper ninguna ley (creo)&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;parece interesante y creo que enseñan a programar, ademas utilizan un derivado
de lisp: &lt;em&gt;Scheme&lt;/em&gt;&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;no lo he leido, ni lo entiendo en ingles&amp;hellip;&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;no entiendes ingles?&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;he, je, he, nop! de hecho ni la ortografia, ni transmitir un pensamiento por
escrito son &lt;em&gt;features&lt;/em&gt; que posea&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;uuuufff, de que vas?&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;de nah, el libro no esta traducido, y yo, sin saber ingles, puedo utilizar un
traductor, sentido comun y muchas horas para dejar un trabajo cuando menos
entendible, por no decir bueno (sin llegar a lo profecional), todo esto
respaldado en un nuevo &lt;a href=&#34;https://github.com/nasciiboy/morg/&#34;&gt;formato de documentacion&lt;/a&gt;
(actualizacion de readme en proceso) que estoy construyendo, mientras aprendo a
programar decentemente, capto un poco de ingles y me convierto en un miembro
productivo de la sociedad. Todo ello por un modico y nada extrabagante (pero
digno) sueldo de &lt;s&gt;tercer mundo&lt;/s&gt; un pais en vias de desarrollo&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;momento, seguro escapas con la pasta!&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&amp;hellip; palabra de boy scout, a menos que muera o me vea impedido fisicamente o
ambientalmente, y/o sea demandado por algun desacuerdo legal por alguna de mis
pasadas (y futuras) acciones informaticas, y como sinceramente no tengo nada
mejor, ni mas noble que hacer, &lt;em&gt;yo nasciiboy&lt;/em&gt; lo llevare a cabo&lt;/p&gt;

&lt;p&gt;en caso de no llegar a la meta finaciera, seguire adelante mientras mis parientes no me
echen a la calle, consiga empleo, pierda el interes o cualquier combinacion de estas&lt;/p&gt;

&lt;p&gt;cierto es que esta es la segunda vez que pido financiacion, anteriormente fue
para llevar a cabo la escritura
del &lt;a href=&#34;https://github.com/nasciiboy/raptor-book/&#34;&gt;libro del raptor&lt;/a&gt; + su revision
por alguien de letras. En esa ocacion, no optuve ni un centavo, aunque continua el desarrollo de la
libreria raptor, mas el nulo interes por esta, y la sensacion de no plasmar lo mejor
posible mis ideas, llevaron a un paron indefinido de tal labor&amp;hellip; pero esto es
distinto, verdad de la buena!&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;seguro?&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;si, seguro!&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;seguro, seguro?&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;que si, es mas, a diferencia de otros suplicantes de donacion que no ofrecen
nada de inicio, noblemente he realizado una maquetacion del libro al formato
morg (sin gluten, o aditivos), tambien incluyo una exportacion en html
en &lt;a href=&#34;https://github.com/nasciiboy/sicp/&#34;&gt;este repo&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;o puedes hacer una clonacion con&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;git clone https://github.com/nasciiboy/sicp.git
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;hay encontraras, el fichero fuente y su exportacion a html, ambas en
ingles. Probe la version html con firefox y con un spin de chromium, sin
aparente problema&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://nasciiboy.land/img/sicp-screeshot-a.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://nasciiboy.land/img/sicp-screeshot-b.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;extenso el material es, asi que probablemente contenga algunos errores&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;cuanto quieres?&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;em&gt;5,000&lt;/em&gt; dolares, una cantidad aproximada entre 70,000 y 100,000 pesos mexicanos,
para un periodo de entre 5 a 8 meses (ampliable a un año), que seria un sueldo
bajo-bueno-promedio anual&lt;/p&gt;

&lt;p&gt;en mas de lo que esperiria ganar en un empleo regular, pero oye, para algo que
puedo hacer ya seria mucho no valorarme, ademas podria gastar una suma
considerable en un par de buenos monitores, una nueva placa, un disco de 4TB, o
ser persona&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;donde deposito?&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;realmente nunca he echo un deposito, ni recivido dinero de internet, si quieres
hacerlo sin intermediarios ponte en contacto por correo, ya veremos si la
tarjeta bancaria maizoro que saque con 1 peso de saldo sirve para algo&lt;/p&gt;

&lt;p&gt;si por el contrario prefieres un intermediario, abri una cuenta en &lt;a href=&#34;https://es.liberapay.com/&#34;&gt;&lt;em&gt;liberapay&lt;/em&gt;&lt;/a&gt;,
que es algo asi como un patreon, pero sin fines de lucro, ni compromisos, basado
en software libre, tambien tiene un monton de usuarios registrados esperando
algo de pasta y su ultimo mes movieron poco mas de 1200 euros&amp;hellip; el
financiamiento de proyectos libres es complejo, nadie te da dinero si no eres un
chakal!&lt;/p&gt;

&lt;p&gt;el enlace a la cuenta para la financiacion, esta a fondo del blog, como sin
querer, mis unicos otros dos medios de contacto son el correo (tambien al fondo)
y en reddit, ambos con el usuario &lt;strong&gt;nasciiboy&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;y las (pegatinas|playeras|recompensas)?&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;no necesitas nada externo, las cosas bonitas las tienes dentro de ti, las mas
bonitas en el disco duro, si quieres
una baratija ya te la puedes comprar por tu cuenta he ir directo a #!eç¤¢¢
€¢#!¢e¤¢ $&amp;amp;~#@&amp;hellip;. desde el respeto&amp;hellip;&lt;/p&gt;

&lt;p&gt;lol, alimenta al troll&amp;hellip; bueno, por 10 dolares o asi, ya te pongo en el
&lt;em&gt;CONTRIBUTORS&lt;/em&gt; del repo, por 100 o mas en los agradecimientos del libro, y por
1000 al inicio del libro con el cargo ficticio (o real) que quieras! como &lt;em&gt;ninja
editor&lt;/em&gt;, o &lt;em&gt;Jr. revisor online ecologist superior chief developer master&lt;/em&gt;, etc.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;no tengo pasta, puedo colaborar?&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;esta en un repo, en texto plano, en internet, con una licencia libre (CC BY-SA
4.0), puedes hacer lo que te permita la ley o tu vision del mundo&amp;hellip;&lt;/p&gt;

&lt;p&gt;&amp;hellip; por supuesto que puedes colaborar, dar una revicion a las cosas que voy
haciendo (suelo subir una seccion/capitulo por commit), ponerte a traducir,
ofrecer tu opinion sobre el formato, programar morg, hacer una portada, una hoja
de estilo, &amp;hellip;&lt;/p&gt;

&lt;p&gt;no voy a quejarme, por tardar menos, menos aun si se hace mejor&lt;/p&gt;

&lt;p&gt;tambien si te gusta el formato, recivo encargos, ofertas de empleo, como tambien
propuestas para hacer esto de documentar rentable a corto plazo, armar una empresa hippie, etc.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;cuando inicia la traduccion?&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;obviamente, cuando vea la pasta&amp;hellip; en realidad puedo empezar inmediatamente,
aunque primero quiero programar un poco el exportador/visualizador/facilitador
del formato. Tengo por costumbre hacer un poco de esto y un poco de aquello,
en un mes subo (o no) una &lt;em&gt;pretraduccion&lt;/em&gt; (automatica, es decir del traductor) y/o
&lt;em&gt;premaquetacion&lt;/em&gt; de todo el material, esto lleva mucho mas tiempo que una simple
traduccion y por lo general no tiene un sentido entendible para humanos, pero es
la parte fundamental.&lt;/p&gt;

&lt;p&gt;Si deseo programar antes, es para automatizar la mayor parte de la labor, pese a
que esto tambien es una meta a largo plazo&lt;/p&gt;

&lt;h2 id=&#34;adaptacion-del-material&#34;&gt;adaptacion del material&lt;/h2&gt;

&lt;p&gt;Si he de clasificar la facilidad de adaptar un libro de un formato a otro, sin
duda, lo mas complejo seria partir del formato de arbol muerto, no obstante en
esa situacion la &amp;ldquo;libertad de ajuste&amp;rdquo;, es la mas grande, si no sabes
mecanografia, es un magnifico proyecto para aprender, e ir realizando la
adaptacion &amp;ldquo;al vuelo&amp;rdquo;, claro luego seran necesarias muchas pasadas cazando
fallos ortograficos&lt;/p&gt;

&lt;p&gt;el siguiente caso de complejidad seria un ocr o pdf &amp;ldquo;con letras&amp;rdquo;, primero se
vuelca el contenido y luego toca no solo maquetar desde el texto en bruto,
tambien transladar cualquier marca del original (bold, italica, enfasis,
codigo), asi como crear enlaces internos, si es el caso&lt;/p&gt;

&lt;p&gt;por ultimo temos la adaptacion partiendo de algun lenguaje de marcado, que
me gusta clasificar en dos subcategorias:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;em&gt;maquetado limpio&lt;/em&gt;, es decir, si es factible realizarlo con una herramienta
automatica o con un minimo de intervencion (a base de substitucion regexp y
macros) casi directamente&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;em&gt;maquetado ofuscado&lt;/em&gt;, jo, esto suele encontrarse en mayor medida en documentos
html, cuando la apnesia ataca los fundamentos estructurales del lenguaje, y
mediante una y otra etiqueta o las que hagan falta se optiene el aspecto
visual deseado; esta tecnica tambien se vale de romper los propositos de un
elemento dado, asi tambien como emular una caracteristica no implementada&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;los documentos en (*)TeX, suelen estar en el punto medio de ambas subcategorias,
para fortuna mia, la persona &lt;em&gt;Lytha Ayth&lt;/em&gt;, en el 2001 se dedico a maquetar sicp
a conciencia en el formato texinfo (formato oficial de documentacion del
proyecto GNU, con un mimo particular en Emacs). Tras una larga cadena de
aportaciones y correcciones, optube una copia desde el repositirio &lt;a href=&#34;https://github.com/sarabander/sicp&#34;&gt;sicp-pocket&lt;/a&gt;
que contiene todo el libro dentro de un solo fichero (&lt;code class=&#34;file&#34;&gt;sicp-pocket.texi&lt;/code&gt;)&lt;/p&gt;

&lt;p&gt;como este fichero tenia una estructura razonable, la mayoria pudo hacerse
mediante macros y substitucion de expresiones regulares, revision manual y
un poco de lavor para encajar algunas cosas, este proceso llevo algo asi como 15
seciones de tiempo ocioso y un par de dias a tiempo completo&lt;/p&gt;

&lt;p&gt;diria que lo mas complejo fue encontrar sentido al uso del comando &lt;code&gt;quotation&lt;/code&gt;,
que se utilizaba indiscriminadamente en cuelquier figura, codigo, ejemplo y
bloque ambiguo, tambien fue complejo decidir que hacer con las bloques de arte
ascii encerrados en comandos de compilacion condicional, que se utilizaban
principalmente para graficar diagramas y algunas formulas matematicas, en ese
aspecto tome una licencia artistica, substituir el arte ascii con &amp;ldquo;arte&amp;rdquo; unicode
cuando fuese apropiado (y cuando no) y tambien la nada grata tarea de substituir
sup/super indices (unicode) de todas las formulas matemagicas que fue posible,
creo solo quedaron 5-10 formulas en TeX puro&lt;/p&gt;

&lt;p&gt;cierto es que el texto incluia todas las formulas tanto en ascii como en TeX,
pero borre este ultimo, no por incapacidad del lenguaje morg (que aun no se
decanta por una sintaxis para formulas matemagicas), sino por ahorrar
procesamiento y por considerar que la representacion unicode cumplia de forma
satisfactoria, tanto (y principalmente) para leer el libro directamente del
fuente, como en alguna de sus exportaciones (de momento solo html) y una
no completa vision desde el terminal con el comando &lt;code&gt;morg tui sicp.morg&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;Para el par de formulas que no puedieron adaptarse, utilice el javascript de
MathJax, para la que tuve que incluir una opcion en el fuente, si desea
eliminarla, dentro del codigo fuente del documento (&lt;code class=&#34;file&#34;&gt;sicp.morg&lt;/code&gt;)
elimine la palabra &lt;code&gt;mathjax&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;el resaltado de syntaxis requiere tener instalado pygments. Dentro del documento
la palabra &lt;code&gt;pygments&lt;/code&gt; habilita dicho resaltado.&lt;/p&gt;

&lt;p&gt;Tome en cuenta que python es mas lento que morir por fumar, asi que desabilitese
para pruebas rapidas, lo mismo para &lt;code&gt;mathjax&lt;/code&gt;, la carga del javascript afecta el
rendimiento del navegador de mala, muy mala manera&lt;/p&gt;

&lt;p&gt;en los proximos dias pondre un readme al repo y una actualizacion al de morg&lt;/p&gt;

&lt;p&gt;happy hacking!&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>El Lenguaje De programacion Go</title>
      <link>https://nasciiboy.land/prog/tgpl/</link>
      <pubDate>Mon, 29 May 2017 22:02:43 -0500</pubDate>
      
      <guid>https://nasciiboy.land/prog/tgpl/</guid>
      <description>

&lt;p&gt;golang, el lenguaje de &lt;q&gt;programacion de sistemas&lt;/q&gt; de la gente de google con
el que planea llebar a cabo sus mas retorcidos y stalkerosos deseos.&lt;/p&gt;

&lt;p&gt;Hoy y tras pocos meses de programacion y muchas horas de investigacion
linguistica intentando entender el english, les traigo una reseña de la biblia
de golang (Go para los amigos) &lt;em&gt;The Go Programming Language&lt;/em&gt; (en adelante
TGPL o GPL(?))&lt;/p&gt;

&lt;h2 id=&#34;el-libro&#34;&gt;el libro&lt;/h2&gt;

&lt;p&gt;Los usa-americanos tienen sus medidas extravagantes. Siguiendo su ejemplo, yo
mido la extencion de un documento en las lineas (de 80 columnas indentadas) que
abarca, por ejemplo, 7000-10000 lineas suelen ser la extencion regular de una
novela, debajo de esta cantidad es un trabajo corto, superior de esta es extenso
y superior a las 20000 lineas ya es &lt;em&gt;muy extenso&lt;/em&gt;, aunque &lt;em&gt;Dune&lt;/em&gt;
utiliza (y muy bien) la friolera y descomunal cantidad de 34150 lineas.&lt;/p&gt;

&lt;p&gt;Pues bien, TGPL son 21426 lineas, repartidas a partes iguales entre explicaciones
y codigo fuente. Si quieres la extencion en paginas, son cerca de 400, aunque no
confiaria en esta medida&lt;/p&gt;

&lt;p&gt;La mayor parte del libro se utiliza para mostrar la forma de hacer las cosas en
Go: sintaxis, ideologia y paquetes. Haciendo un simil con C seria algo asi como
que te enseñaran a hacer muchas herramientas del sistema, mas una guia de &lt;code&gt;gcc&lt;/code&gt;,
&lt;code&gt;make&lt;/code&gt; y alguna cosa mas.&lt;/p&gt;

&lt;p&gt;Se asume que ya conoces al menos un lenguaje de programacion, particularmente C
o alguno de su descendencia y aunque no es necesario que manejes programacion
orientada a objetos y/o concurrencia es deseable contar con tales saberes antes
de iniciar la aventura&lt;/p&gt;

&lt;p&gt;Repitiendo, no es un manual para no iniciados, es decir, para quien no tenga ya
asumido en su ser lo que es programar, resultara hostil. Diria que es apto como
tercer o cuarto libro de programacion&lt;/p&gt;

&lt;p&gt;Se enseña a construir aplicaciones no triviales, utilzando la rica libreria
estandar del lenguaje, aunque la mayoria encaminadas al tema web, ninguna es
despreciable, incluso se propone la construccion de un parser de espreciones-S y
un pequeño interprete para un lenguaje de programacion. No se llega a
profundizar veraderamente en ningun tema, pero se da lo suficiente como para
enfrentar lo desconocido sin temor (jo, lo dice quien no ha hecho mas de 4
ejericios)&lt;/p&gt;

&lt;p&gt;Igualmente poco se indaga sobre la herramienta principal del lenguaje (&lt;code&gt;go&lt;/code&gt;) que
es a la vez un compilador, perfilador (primera ves que utilizo algo asi),
administador de paquetes, &amp;ldquo;visor&amp;rdquo; de documentacion y muchas cosas mas. Un par de
comandos para iniciar a hacer cosas y un par de comandos esotericos. Vamos,
tampoco es para abrumar, si es bueno y sencillo, es mas del doble de bueno&amp;hellip; o
eso diria. Siendo suficiente para iniciar, hecho en falta mayor detalle en
varios comandos que requieren un orden y sintaxis nada evidentes, parecidos mas a
conjuros misteriosos&lt;/p&gt;

&lt;p&gt;en resumen, recomendo su lectura a cualquiera, en particular si se biene de C o
C++ y se aspira a lenguajes mas desapegados de la maquina, sin topar de lleno en
abstracciones incomprensibles&lt;/p&gt;

&lt;h2 id=&#34;el-lengueje&#34;&gt;el lengueje&lt;/h2&gt;

&lt;p&gt;el libro esta muy bien!, que tal el lenguaje?&lt;/p&gt;

&lt;p&gt;bueno, desde la perspectiva de un aficionado a C, que ha pasado por C++, bash y
un ligero viaje por lisp, el lenguaje me gusta mucho, aunque no puedo perdonarle
que inponga un estilo arbitrario de como han de indentarse y separarse las
instrucciones, es decir el formateo. Viniendo de C tener llaves para
instrucciones sencillas (una instruccion) me parece atroz, por no decir forzar
la posicion de apertura y cierre de las demas llaves, sobre todo en
instrucciones &lt;code&gt;else&lt;/code&gt;, no lo soporto esteticamente! Ya por utilizar tabs
para indentar, deben arder en la hogera&lt;/p&gt;

&lt;p&gt;Como te obligan a seguir su estilo? si no cumples con el formato no compila&amp;hellip;&lt;/p&gt;

&lt;p&gt;dejando atras este no precisamente poco importante aspecto, tenemos el
inmobiliario habitual de los descendientes de C, ifs, elses, else ifs,
funciones, arreglos, switches, return, gotos y bucles for, careciendo de bucles
while y do while, pero sumando slices, que son una especie de arreglo con
crecimiento dinamico automagico (el lenguaje tien recolector de basura), mapas
hash, una funcion llamada &lt;code&gt;defer&lt;/code&gt;, &lt;code&gt;gorutinas&lt;/code&gt; para programacion concurrente,
&lt;q&gt;canales&lt;/q&gt; para pasar datos a las gorutinas y asegurar que completen su
ciclo, pero sobre todo y quiza lo mas interesante del lenguaje su orientacion a
objetos no evidente&lt;/p&gt;

&lt;p&gt;el lenguaje tiene una forma &lt;q&gt;peculiar&lt;/q&gt; de organizar sus parametros (al
revez de C tipo-nombre, aqui es nombre(s)-tipo) que no pocas veces me ha causado
transtornos cuando regreso a tocar C, p-e-r-o ninguna queja, tambien se ve bien.&lt;/p&gt;

&lt;p&gt;quiza lo que mas atractivo de Go es tratar de no ser ser innecesariamente
complejo en ningun aspecto, al grado de que entrar a una libreria sin conocer el
lenguaje da la imprecion de estar ante un lenguaje imperativo.&lt;/p&gt;

&lt;p&gt;Fascinante es que la orientacion a objetos surja por si sola. MMMM, no esta
permitida la sobre carga de operadores, la convercion automatica de tipos ni la
extencion de una clase fuera de su fichero de definicion. A cambio nos dan
composicion e interfases&lt;/p&gt;

&lt;p&gt;los ficheros de codigo fuente por defecto utilizan codificacion unicode utf-8,
que en conjunto con una funcion nativa llamada &lt;code&gt;range&lt;/code&gt; permiten iterar sobre
cadenas unicode sin tener que recurrir a esotericas librerias. Tambien se
permite convecion automagica de entre &lt;code&gt;runas&lt;/code&gt; unicode de 32 bits a cadenas de
caracteres utf-8&lt;/p&gt;

&lt;p&gt;por cierto, aunque el nucleo del lenguaje es compacto la libreria
estandar es muy rica, te da un servidor web, analisis en cadenas, codificadores,
compresores y otro monton de cosas&lt;/p&gt;

&lt;p&gt;es sencillo crear programas relativamente complejos con estas facilidades,
aunque encuentro incomoda la herramienta de documentacion para linea de comandos&lt;/p&gt;

&lt;p&gt;pese a lo amplio de la libreria estandar, carece de librerias nativas para
graficos y esto es un punto flaco, considerando que si te apegas a la libreria
estandar tus programas son multiplataforma y que el costructor de programas es
por naturaleza multiplataforma es triste no contar con herramientas oficiales
para crear GUIs o al menos TUIs. Lamentablemente, veo poco probable que algun dia
llegue a tener librerias nativas para estos menesteres&amp;hellip; a menos que el gestor
de paquetes pueda meter sus manos en el gestor de paquetes del sistema en si
(apt, dnf, yum, etc)&lt;/p&gt;

&lt;p&gt;me encanta como administra las &amp;ldquo;librerias&amp;rdquo;/paquetes externos, nada de buscar por
internet, ni compilar a mano, ni naaah, el solito busca las dependencias y las
enlaza. Nunca perdonare al comite de los estandares de C y C++, por no copiar
este aspecto y evolucionarlos de forma razonable, si hicieran su labor no
tendria que aparecen Go&lt;/p&gt;

&lt;p&gt;respecto a la concurrencia, no tenia ninguna experiencia previa, era un tema
mistico, magico y misterioso y sin embargo he podido implementar un tipo
concurrente, aunque no se, encuentro un poco criptica las formas en que esta
implementada, aunque como digo desconosco como se haga esto en otros lenguajes,
de momento la puedo usar sin muchos complejos ingorando una parte que tenia que
ver con bucles for, captura de variables y cosas concurrentes que no me quedo
muy clara en el libro&lt;/p&gt;

&lt;h3 id=&#34;cosas-feas&#34;&gt;cosas feas&lt;/h3&gt;

&lt;p&gt;ademas del jodido formateo? cast, cast, cast por todas partes, y si no aplicas
cast, he?, creas una varible extra con el cast apropiado al inicio de la funcion&amp;hellip;
teniendo que asignar memoria extra&amp;hellip;?&lt;/p&gt;

&lt;p&gt;tan dificil y peligroso es asumir que el programador sabe que es lo que hace con
los tipos que escoge y en consonancia hacer conversion automatica de tipos, digo
con tener conversion autamatica en llamadas a fuciones seria un gran alivio,
pero no, ademas ni ellos resepetan su estricto y seguro tipado (ironia), pues
aveces hacen convesiones automaticas para ciertas tareas, a sabiendas de lo poco
practico de tal desicion. La evidencia de que comprenden el problema se muestra
cuando por lo general se regresar &lt;code&gt;int&lt;/code&gt;s aun en valores que deverian ser unsigned&lt;/p&gt;

&lt;p&gt;no le haria mal al lenguaje separar la herramienta &lt;code&gt;go&lt;/code&gt; en varias utilidades, en
particular para la documentacion, pruebas y perfilado&lt;/p&gt;

&lt;p&gt;tener un solo paquete por directorio es bueno, pero en paquetes conseptualmente
extensos puede ser dificil averiguar la procedencia de una funcion, no es grave
y es principalmente un problema del programador no distribuir el codigo de forma
coherente, pero aun asi se vuelve dificil seguir la logica de un programa extenso&lt;/p&gt;

&lt;h3 id=&#34;conclucion&#34;&gt;conclucion&lt;/h3&gt;

&lt;p&gt;Me gusta y lo recomiendo como lenguaje secundario. Si bien es cierto que tiene
un fuerte enfoque para aplicaciones web es utilizable como lenguaje de
proposito general, entregando un rendimiento aceptable&lt;/p&gt;

&lt;p&gt;segun pruebas mias, su rendimiento esta entre 3 a 4 veces mas lento que su
homologo en C, es decir, si un pragrama demora 1, en Go, demora 4 o 5, bueno no?
si, eheemee, aun tengo conflictos psicologicos al saber que va 3 o 4 veces mas
lento que C, pero bueno al menos no es 100 veces mas lento como el
&lt;q&gt;fabulosisimo&lt;/q&gt; python o JS&lt;/p&gt;

&lt;p&gt;alto, tengo que sacarlo de mi sistema, no programes con python, ni JS, no lo
hagas, por fabor, no son lenguajes paro programar por mas (falsamente) simples o
elegantes que sean. Los lenguajes interpretados son para extender programas o
para servir como prompts, no para crear algo de cero. Sirve de algo tardar unas
horas menos programando en esos lenguajes cuando pasaras la eternidad
ejecutandolos lentamente? hay lo dejo&lt;/p&gt;

&lt;p&gt;Go apenas se encuentra en los limites que considero un rendiminto aceptable.&lt;/p&gt;

&lt;p&gt;Entre 7 y 10 veces mas lento que C, sin importar el paradigma, solo podre
considerar al lenguaje una &lt;q&gt;curiosidad&lt;/q&gt; intelectual&lt;/p&gt;

&lt;h2 id=&#34;porg&#34;&gt;porg&lt;/h2&gt;

&lt;p&gt;durante el ultimo mes, he estado traduciendo o mas bien dando sentido a la
traduccion de las maquinas sobre el libro en cuestion. Pueden optener una copia
del codigo y resultados con&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;git clone https://github.com/nasciiboy/TGPL.git
cd TGPL
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;abren los ficheros &lt;code&gt;html&lt;/code&gt; en su navegador de confianza (pista: el que tiene un
sufijo &lt;code&gt;es&lt;/code&gt;, es el que esta en español&lt;/p&gt;

&lt;p&gt;tambien hay verciones web de una sola pagina del material&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://nasciiboy.land/book4all/tgpl/The-Go-Programming-Language_es.html&#34;&gt;https://nasciiboy.land/book4all/tgpl/The-Go-Programming-Language_es.html&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://nasciiboy.land/book4all/tgpl/The-Go-Programming-Language.html&#34;&gt;https://nasciiboy.land/book4all/tgpl/The-Go-Programming-Language.html&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;para crear el material desde el codigo&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;go get -u https://github.com/nasciiboy/morg
morg toHtml The-Go-Programming-Language.morg
morg toHtml The-Go-Programming-Language_es.morg
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;para ver el fichero directamente en su terminal, utilice &lt;code&gt;morg tui fichero.morg&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;en fin, una labor estandar de traduccion a mi estilo sin acentos.&lt;/p&gt;

&lt;p&gt;apenas es lo suficientemente entendible, y apenas dare mi primer lectura seria
al libro y de paso correjir algunas cosas.&lt;/p&gt;

&lt;p&gt;tuve problemas al localizar muchas cosas, pero si quieres colaborar a mejorar un
manual que nunca iba a aparecer en españøl (o si) tienes mi correo y clave gpg
abajo&lt;/p&gt;

&lt;p&gt;happy hacking&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>
