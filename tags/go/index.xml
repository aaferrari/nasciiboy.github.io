<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Go on ⋲ᴹ∧cₛ ℜø∁κ§</title>
    <link>https://nasciiboy.land/tags/go/</link>
    <description>Recent content in Go on ⋲ᴹ∧cₛ ℜø∁κ§</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>es</language>
    <copyright>GPL v3.0</copyright>
    <lastBuildDate>Wed, 28 Mar 2018 14:53:20 -0600</lastBuildDate>
    
        <atom:link href="https://nasciiboy.land/tags/go/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>GDP</title>
      <link>https://nasciiboy.land/prog/gdp/</link>
      <pubDate>Wed, 28 Mar 2018 14:53:20 -0600</pubDate>
      
      <guid>https://nasciiboy.land/prog/gdp/</guid>
      <description>

&lt;p&gt;&lt;strong&gt;Go Design Patterns&lt;/strong&gt;, es un libro enfocado en los patrones de diseño
implementados en Go&amp;hellip;&lt;/p&gt;

&lt;p&gt;El material de esta ocacion, viene (o lo encontre) en presentacion de pdf, con
una extencion de aproximadamente 400 paginas en letra grande.&lt;/p&gt;

&lt;p&gt;El primer 15% es un sobrevuelo de las caracteristicas del lenguaje de
programacion Go. Nada profundo, pero viene bien como recordatorio de como es
esto de Go&lt;/p&gt;

&lt;p&gt;El siguiente 55% nos muestran la implementacion de los &amp;ldquo;clasicos&amp;rdquo; patrones
includidos en el GoF y el resto ilustra maneras de aprovechar las
caracteristicas concurrentes del lenguaje (gorutinas y canales) reimplementando
algunos patrones y mostrando un par especificos de esta tematica&lt;/p&gt;

&lt;p&gt;La ideologia programacional-didactica que imparte el autor se llama
&lt;a href=&#34;https://es.wikipedia.org/wiki/Desarrollo_guiado_por_pruebas&#34;&gt;TDD&lt;/a&gt; (Test-driven
development). Aunque me parece algo aburrida y monotona (hacer la prueba,
fallar, refactorizar, hacer la prueba, acercarse al comportamiento,
refactorizar, etc, etc) conicido en que las pruebas son un buen punto de
referencia para afrontar un problema, pues:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;Si es dificil realizar una prueba a tu codigo, seguramente este mal planteado,
ya sea por realizar demaciadas cosas, recibir demaciados parametros, regresar
variados resultados&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Son una garantia de que las nuevas modificaciones no rompan con el comportamiento
establecido&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;aun asi, el TDD como mantra sigue sin convencerme. Por lo demas, cada patron
se divide mas o menos en las secciones Descripcion, Objetivos, Criterios de
aceptacion, Pruebas de unidad, Implementacion y &amp;ldquo;resumen-reflexion-o-algo&amp;rdquo;.&lt;/p&gt;

&lt;p&gt;El acercamiento que tome, por resultarme tedioso y aburrido lo relacionado con
la TDD, fue leer todo ignorando criterios de aceptacion y pruebas de unidad para
ir directamente al codigo, descifrarlo y verlo funcionar, luego ante alguna duda
ya leer la seccion de implementacion y pasar al resumen-o-algo&lt;/p&gt;

&lt;p&gt;Los primeros capitulos, dedicados a los patrones estructurales y de creacion,
son bastante desabridos. Basicamente se podrian resumir en simples
interfaces. Pero cuando se llega a los patrones de comportamiento, el codigo se
convierte en ludicos rompecabezas (no frustrantes) y con concurrencia mejoran
aun mas. La implemantacion del patron &lt;code&gt;Pipeline&lt;/code&gt; es una gozada de sencilles y
genialidad que unicamente podria implementarse en Go con tanta genialidad
(aunque creo que en el TGPL lo muestran aun mejor implementando una pasteleria)&lt;/p&gt;

&lt;p&gt;mencionar que el codigo fuente no incluye ni un puñetero comentario, yeee! este
sujeto es de mi escuela de pensamiento&amp;hellip; No temais, entre los nombres, tipos,
funciones del paquete en conjuncion con las acciones dentro de las pruebas es
suficiente para entender lo que se esta intentando demostrar. Diria que en caso
de amnesias mentales, en lugar de revisitar el libro, es mas interesante ir
directo al codigo, y si tienes la suficiente determinacion, ni siquiera hace
falta leer el libro&lt;/p&gt;

&lt;p&gt;por la demas, la lectura es amena y rapida, no se esfuersa en repetir lo que en
otros libros (como el mismo GoF) encontrarias mejor y mas detallado. En su lugar
se decanta por enseñar formas idiomaticas de aprovechar el lenguaje&lt;/p&gt;

&lt;h2 id=&#34;notas&#34;&gt;Notas&lt;/h2&gt;

&lt;p&gt;el codigo fuente, del libro esta disponible en
&lt;a href=&#34;https://github.com/PacktPublishing/Go-Design-Patterns&#34;&gt;github&lt;/a&gt; pero aunque la
mayoria esta listo para compilar/probar uno que otro tiene fallos, no se si
intencionales, como por ejemplo en el penultimo capitulo, para ejecutar el
codigo es necesario renombrarlo, reorganizarlo y ocacionalmente modificar y/o
agregar alguna funcion o libreria. Ya en el capitulo 10 ni se molestan
(literalmente) en terminar la escritura, el primer fichero trae una funcion a
medio hacer y poco mas&amp;hellip; coloque una
&lt;a href=&#34;https://github.com/PacktPublishing/Go-Design-Patterns/issues/1&#34;&gt;issue&lt;/a&gt;,
esperando que corrijan el asunto&amp;hellip; pero no espero nada, es un libro &amp;ldquo;de
maquila&amp;rdquo;, con mas de un año en el mercado, un mercado inundado de material
generico donde apenas alguien tiene interes en ellos y las unicas ventas,
ocurren casi por equivocacion, ja, ja, ja, la ruleta rusa de los libros!&lt;/p&gt;

&lt;p&gt;el primer error que detecte en el codigo, esta en &lt;code&gt;Chapter02/prototype.go&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;func GetShirtsCloner() ShirtCloner {
    return nil
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;el asunto, es que la funcion regresa un &lt;code&gt;nil&lt;/code&gt; para una interfaz que tiene como
contrato una funcion &lt;code&gt;GetClone(m int) (ItemInfoGetter, error)&lt;/code&gt; que solo es
cumplida por la estructura &lt;code&gt;ShirtsCache&lt;/code&gt; por su metodo &lt;code&gt;GetClone&lt;/code&gt; aplicado en
un puntero a la funcion&amp;hellip;&lt;/p&gt;

&lt;p&gt;Al principio me jodio la mente pensando en que dicho codigo pudiera funsionar.
Comor? un nil convirtiendose en una interfaz para una estructura que no se
declara explicitamente? Go hace este tipo de magia (me pregunte) &amp;hellip; y nop,
para que la cosa funcione &lt;code&gt;GetShirtsCloner&lt;/code&gt; debe regresar &lt;code&gt;new(ShirtsCache)&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;En el capitulo 8, fue necesario aislar un par de ficheros para ejecutar el patron
singleton (concurrente con canales)&lt;/p&gt;

&lt;p&gt;En el capitulo 9, hubo que reorganizar todos los ficheros y modificarlos un poco&lt;/p&gt;

&lt;p&gt;Y el 10 directamente no esta hecho. Me habia planteado terminarlos, sin embargo,
como la metodolagia que habia adoptado era ir directamente al codigo, esta vez
inexistente, y mi forma de aproximarme al libro fue con una traduccion no
humana, no fui capaz (ni me esforce) en enterder que demonios decia. Es una
lastima, por que dicho capitulo mostraba (creo) como limitar la cantidad de gorutinas
en ejecucion, como finalizar la ejecucion de una gorutina y un codigo final que
incluia de todo un poco&lt;/p&gt;

&lt;p&gt;Como nota final en una parte del patron State, mencionan un FSM que al parecer
no solo se refiere al buen &lt;strong&gt;monstruo de espagueti volador&lt;/strong&gt; o
&lt;a href=&#34;https://en.wikipedia.org/wiki/Flying_Spaghetti_Monster&#34;&gt;FSM&lt;/a&gt; si no tambien a
una maquina de estados finitos (&lt;a href=&#34;https://es.wikipedia.org/wiki/Aut%C3%B3mata_finito&#34;&gt;finite-state machine&lt;/a&gt;)&lt;/p&gt;

&lt;h2 id=&#34;cobaya&#34;&gt;cobaya&lt;/h2&gt;

&lt;p&gt;Aunque cobayizar un material es un entretenimiento &amp;ldquo;mecanico&amp;rdquo;, cada vez, me da
mas pereza tener que aplicarlo a tristes PDFs. Pero para optener una traduccion
&amp;ldquo;express&amp;rdquo; es lo mas sencillo que encuentro, y bueno &lt;code&gt;¯\_(ツ)_/¯&lt;/code&gt; aunque sea poco, material a
material van refinando las ideas del lenguaje de documentacion
imaginario. Por ejemplo, esta vez hicieron evidente un fallo en el
reconocimiento de listas alfabeticas (y numericas) que se resolvio modificando
chapuseramente una regex (aunque no subire el cambio al repo hasta el siguiente refactorizado)&lt;/p&gt;

&lt;p&gt;Hem, el material tenia pocos retos y apenas incluia imagenes. Lo mas complicado
fue dar formato al codigo, tambien inferir donde demonios terminabas los TIPs y
darle la jerarquia adecuada a los encabezados&lt;/p&gt;

&lt;p&gt;Los bloques donde se mostraba la salida de las pruebas no la afine del todo, y
en la lectura del libro no me percate del hecho de su no correcta indentacion
hasta luego de la mitad&lt;/p&gt;

&lt;p&gt;en el &lt;a href=&#34;https://github.com/nasciiboy/gdp&#34;&gt;repo cobayizado&lt;/a&gt; encontraran el fuente,
una exportacion a html sin interes ni esfuerzo, y la version (mal) traducida
automaticamente. Dicha traduccion, no tiene ni tabla de indice, ni los
encabezados tienen el orden correcto (mientras la leia, iba corrigiendo la
version en ingles), ademas seguramente el html este bastante
roto por toquetearlo bastante a mano y con regexes&amp;hellip; y asi se quedara, esta
ocacion no hay una version &amp;ldquo;fuente&amp;rdquo; en español, es mucho curro y prefiero
ponerme a practicar los patrones&lt;/p&gt;

&lt;p&gt;felices trazos!&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>blackfriday</title>
      <link>https://nasciiboy.land/prog/blackfriday/</link>
      <pubDate>Fri, 27 Oct 2017 17:42:32 -0500</pubDate>
      
      <guid>https://nasciiboy.land/prog/blackfriday/</guid>
      <description>

&lt;p&gt;&lt;img src=&#34;https://nasciiboy.land/img/bf.jpg&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;Durante la modificacion del morg, habia escrito esto junto con otras notas
vagas en una bitocora de abordo que trata de ser FIFO, aunque si no mantengo la
constancia comienza a crecer y crecer hasta volverse incomoda. Asi pues (y como
el post anterior) a despejar algunas de esas divagaciones&lt;/p&gt;

&lt;h2 id=&#34;como-no-construir-un-parser-para-un-lenguaje-de-marcas-ligeras&#34;&gt;Como (no) construir un parser para un lenguaje de marcas (ligeras)&lt;/h2&gt;

&lt;p&gt;con &lt;em&gt;morg&lt;/em&gt; (parser y lenguaje de marcas ligueras inventado por yo) la
construccion al igual que casi todas mis mierdas, fue fruto de reinventar la
rueda + prueba y error constantes, tratando de mantener una cierta sencilles&amp;hellip;
mientras la raices de la incertidubre sobre si el proyecto llegaria a ser
funcional o quedaria truncado por la ignorancia y malas deciciones de diseño
orientadas en su mayoria por la aleatoriedad, me consumen lentamente&lt;/p&gt;

&lt;p&gt;una de las primeras deciciones luego de la mudanza a Go, fue trabajar con
strings o slices de bytes, los primeros son inmutables, peeero todas las
funciones que trabajan con documentos (de la libreria estandar y mas alla) optan
por utilizar slices de bytes.&lt;/p&gt;

&lt;p&gt;En principo me parecio que los strings son mejor opcion, pues me aseguro de no
fastidiar lo que el usuario envie a el exportador, ademas que hacer recorridos
por la cadena mediante &lt;code&gt;range&lt;/code&gt;s es muy sencillo, con el agregado de
soportar unicode.&lt;/p&gt;

&lt;p&gt;Por el otro lado, trabajar con bytes, evita una conversion extra (de bytes a
strings) y supuestamente son mas eficientes, pero venido como soy de C, donde se
suponque que las cadenas constantes son mas eficientes, la duda sigue presente&lt;/p&gt;

&lt;p&gt;Otro tema y creo que mas crucial es como recorer y diseccionar los
datos de entrada, opteniendo los supuestos componentes del lenguaje,
encabezados, parrafos, notas, resaltado, listas, definiciones, etc, y casi igual
de importante como organizarlos en una forma conveniente tanto para yo como
programador, como para yo como usuario del programa y de ser posible lanzar
advertencias cuando se localicen datos de entrada erroneos&lt;/p&gt;

&lt;p&gt;ante tal reto y sin &amp;ldquo;documentos tecnicos&amp;rdquo; que conosca (o entienda), la unica
opcion en el corto plazo, no es otra que meterse a lo bruto con algun proyecto
de programacion que ofresca descaradamente su codigo a todo mundo, aqui es donde
entra la libreria &lt;a href=&#34;https://github.com/russross/blackfriday&#34;&gt;blackfriday&lt;/a&gt; de un
tal &lt;em&gt;russross&lt;/em&gt; para parsear markdown, escrita en Go&amp;hellip; lol, hace tiempo intente
con cosas en C y python&amp;hellip; donde el codigo me resulto incomprensible&amp;hellip;&lt;/p&gt;

&lt;h2 id=&#34;como-lo-hace-russross&#34;&gt;como lo hace russross&lt;/h2&gt;

&lt;p&gt;utiliza slices de bytes, en lugar de cadenas, buffers del paquetes &lt;code&gt;bytes&lt;/code&gt; como
contenedores del resultado, tanto en llamadas internas como en los
&lt;em&gt;renderizadores&lt;/em&gt; del documento parceado e igual que morg no regresa error
alguno, solo slices vacios (&lt;code&gt;nil&lt;/code&gt;)&lt;/p&gt;

&lt;p&gt;interesante es su parseo en si, asigno funciones con caracteres &amp;ldquo;centinela&amp;rdquo;
para identificar los objetos, envia el slice de datos a la funcion respectiva,
junto con la estructura del documento y esta almacena el resultado y regeresa la
longitud de bytes leeidos que se suponen forman parte del elemento&lt;/p&gt;

&lt;p&gt;mas interesante, es que toma dos pasos de parseo sobre el documento, la primera
para normalizar el docuemento (quitar los saltos de linea a lo windows &lt;code&gt;\r\n&lt;/code&gt;,
cosa que no hare por asco a windows y trabajar solo con saltos unix &lt;code&gt;\n&lt;/code&gt;),
extraer referencias, normalizar bloques de codigo y copiar el resto tal cual,
todo byte a byte o a slices, en el buffer. El segundo reccorido por el documento
es para el parseo &amp;ldquo;serio&amp;rdquo; donde corta y renderiza el resto de cosas.&lt;/p&gt;

&lt;p&gt;Me llama la atencion, que aunque utiliza &lt;code&gt;bytes.Buffer&lt;/code&gt;, no los haga crecer
desde un inicio para disminuir las asignaciones de memoria, no es que sea
realmente necesario&amp;hellip; je, optimizacion premutura, el mal!&lt;/p&gt;

&lt;p&gt;otra desicion relevante toma cuando al llamar al parser del documento, hay que
enviarle un &lt;em&gt;renderizador&lt;/em&gt; que es una interfaz con 31 funciones, la cual se
encarga en unica instancia de entregar el resultado como texto plano en forma de
slice de bytes, bueno, eficiente o practico? dificil saberlo, blacfriday entrega
un render para HTML y otro experimental para latex, aunque por la naturazela de
markdown dificimente sera satisfactorio, pero siendo markdown, un mero
&lt;em&gt;facilitador&lt;/em&gt; de HTML, no hay necesidad de generar otra cosa que no sea HTML, un
poco futil ecuentro la cortecia de entregar &amp;ldquo;renders&amp;rdquo; en blackfriday, cuando el
parseo y exportacion van juntos, unidos, en las entrañas del parser.&lt;/p&gt;

&lt;p&gt;En morg, no lo tenia (ni tengo) muy claro, en la primer version, el parser y el
render son entes separados, unidos solo por la estructura &amp;ldquo;organizada&amp;rdquo; que
entrega el primero, deje en manos del render hacer lo que le venga en gana con
la estructura, sin embargo, al cambiar constantemente esta, hay que hacer una
labor de actualizacion en los &lt;em&gt;n&lt;/em&gt; renders, en &lt;em&gt;n&lt;/em&gt; cambios, quiza un punto
intermedio vendria bien, para la siguiente version; que te entrege la estructura
en bruto y cuente con una interfaz que trabaje como plantilla de exportacion,
aunque, las sutilezas del lenguaje de marcado a exportar, vuelven a esto un
rigido inconveniente, pese a lo sencillo de definir unas cuantas reglas
genericas&lt;/p&gt;

&lt;p&gt;creo que pandoc, cuando examina un docuemnto, lo convierte a una estructura
&amp;ldquo;maestra&amp;rdquo; y luego con ella ya se lo manda a sus renders, me siento mas comodo con esta
opcion, pero como aun no le hago al haskell, tendre que esperar para comprobarlo
de primera mano&lt;/p&gt;

&lt;h2 id=&#34;conclucion&#34;&gt;conclucion&lt;/h2&gt;

&lt;p&gt;tentado estoy a trabajar con bytes, aunque creo que trabajar con &lt;code&gt;bytes.Buffer&lt;/code&gt;
no representa una gran mejora y obliga a incluir un paquete extra, je, je, tengo
algun complejo muuu grande con incluir librerias, aunque sean las estandar,
tengo un problema&amp;hellip; repite tu mantra, esta en la libreria estandar, es bueno y
necesario, en la libreria estandar esta, necesario y bueno es usarlo&lt;/p&gt;

&lt;p&gt;utilizar bytes, requiere modificaciones drasticas en regexp4 que solo maneja
strings, o un monton de conversiones de ida y vuelta.&lt;/p&gt;

&lt;p&gt;que hacer? bytes y strings, dos caras de la misma moneda, separadas por la no
conversion de tipos automatica, para la ocultacion de cadenas como punteros, en
estas deciciones Go-leanas es cuando extraño a C, cuando aparecen estas
estructuras que no estoy seguro si se replican a cada copia/asignacion o
trabajan con los mismos datos de fondo&lt;/p&gt;

&lt;p&gt;en resumen blackfriday (digo, luego de tres intentos por comprenderla hasta no
terminar de leer seriamente el TGPL), no era tan alien, ni complejo como parecia
en un principio, que esta furtemente atado a las limitaciones de markdown, al
igual que sus renderes y por ello no se ve forzado a implementar una estructura
que almacene el documento, pues no maneja elementos, anidados sobre elementos
anidados, sobre elementos aninados, peroooo dentro de sus limitaciones tecnicas,
hace bien su labor&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>benchmarks dentro de un programa en go</title>
      <link>https://nasciiboy.land/prog/gomark/</link>
      <pubDate>Fri, 06 Oct 2017 21:03:55 -0500</pubDate>
      
      <guid>https://nasciiboy.land/prog/gomark/</guid>
      <description>

&lt;p&gt;en Go podemos realizar benchmarks dentro de los ficheros &lt;code&gt;_test.go&lt;/code&gt;, sin embargo
realizar comparativas dentro de en un programa &amp;ldquo;regular&amp;rdquo; no es (era) tan
sencillo hasta la llegada de la version 1.9&lt;/p&gt;

&lt;h2 id=&#34;cgo&#34;&gt;cgo&lt;/h2&gt;

&lt;p&gt;la primer opcion es echar mano de la libreria &lt;code&gt;time&lt;/code&gt; de C. Esta libreria
contiene la funcion &lt;code&gt;clock&lt;/code&gt; que nos regresa una aproximacion a la cantidad de tiempo
del procesador que ha utilizado el programa desde su ejecucion.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;package main

//#include &amp;lt;time.h&amp;gt;
import &amp;quot;C&amp;quot;

import &amp;quot;fmt&amp;quot;

const top = 1 &amp;lt;&amp;lt; 12

func main(){
  init := CpuTime()

  // prueba &amp;gt;
  for x, str := 0, &amp;quot;&amp;quot;; x &amp;lt; top; x++ { str += &amp;quot;1234567890&amp;quot; }
  // &amp;lt; prueba

  fmt.Printf( &amp;quot;CpuTime %dms\n&amp;quot;, DiffCpuTimeByMS( init, CpuTime() ) )
}

func CpuTime() uint64 {
  return uint64(C.clock())
}

func DiffCpuTimeByMS( begin, end uint64 ) uint64 {
  return (end - begin) *  1000 / uint64(C.CLOCKS_PER_SEC)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;resultado:&lt;/strong&gt; &lt;code&gt;CpuTime 55ms&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;solo hay que cambiar el codigo dentro de las comentaarios &amp;ldquo;prueba&amp;rdquo;, es
importante mantener la linea con &lt;code&gt;//#include &amp;lt;time.h&amp;gt;&lt;/code&gt; tal cual, pues es una
(obscura) indicacion para decirle al compilador de Go que incluya dicha libreria
de C. Por supuesto tambien hay que mantener la importacion de &lt;code&gt;&amp;quot;C&amp;quot;&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;Para la compilacion no hace falta pasar ningun parametro adicicional, basta con
un simple &lt;code&gt;go build main.go&lt;/code&gt;&lt;/p&gt;

&lt;h2 id=&#34;testing&#34;&gt;testing&lt;/h2&gt;

&lt;p&gt;la segunda opcion para realizar un benchmark es invocar a &lt;code&gt;testing&lt;/code&gt; desde codigo
regular con una funcion literal&amp;hellip; lo se, no es intiuitivo, pero hay esta y
funciona&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;package main

import &amp;quot;fmt&amp;quot;
import &amp;quot;testing&amp;quot;
import &amp;quot;time&amp;quot;

const top = 1 &amp;lt;&amp;lt; 12

func main(){

  result := testing.Benchmark(func(b *testing.B) {
    b.N = 1 // numero de repeticiones de la prueba
    for i := 0; i &amp;lt; b.N; i++ {
      // prueba &amp;gt;
      for x, str := 0, &amp;quot;&amp;quot;; x &amp;lt; top; x++ { str += &amp;quot;1234567890&amp;quot; }
      // &amp;lt; prueba
    }
  })

  fmt.Printf( &amp;quot;tiempo %s\n&amp;quot;, result.T / time.Duration(result.N) )
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;resultado:&lt;/strong&gt; &lt;code&gt;tiempo 67.861708ms&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;esta prueba toma mucho mas tiempo que con la version anterior, la diferencia se
origina en el propio &lt;code&gt;testing.B&lt;/code&gt;, ya que realiza metricas adicionales, como el numero de
asignaciones de memoria, bytes utilizados, gorutinas y otras cosas&lt;/p&gt;

&lt;h2 id=&#34;time&#34;&gt;time&lt;/h2&gt;

&lt;p&gt;por ultimo la prueba del tiempo se puede realizar con la libreria estandar de
Go, aunque esto no es asi para verciones del compilador inferiores a 1.9 ya que
antes de estos no se media el timpo &amp;ldquo;monolitico&amp;rdquo; de ejecucion (lo que hace
&lt;code&gt;clock&lt;/code&gt; de la libreria &lt;code&gt;time&lt;/code&gt; de C)&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;package main

import &amp;quot;time&amp;quot;
import &amp;quot;fmt&amp;quot;

const top = 1 &amp;lt;&amp;lt; 12

func main(){
  start   := time.Now()
  for x, str := 0, &amp;quot;&amp;quot;; x &amp;lt; top; x++ { str += &amp;quot;1234567890&amp;quot; }
  elapsed := time.Since( start )

  fmt.Printf( &amp;quot;tiempo %s\n&amp;quot;, elapsed )
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;resultado:&lt;/strong&gt; &lt;code&gt;tiempo 59.746755ms&lt;/code&gt;&lt;/p&gt;

&lt;h2 id=&#34;conclusion&#34;&gt;conclusion&lt;/h2&gt;

&lt;p&gt;en pruebas personales, con &lt;code&gt;clock&lt;/code&gt; (de C) los resultados son mas constantes y con
menor variacion que en las demas opciones, mas la version con &lt;code&gt;time&lt;/code&gt; nativo no
dista demaciado de esta, ademas por ser la opcion con codigo nativo y sin
dependencias externas es la que recomiendo y utilizo. Reservaria como segunda
opcion y para pruebas mas exigentes la que utiliza &lt;code&gt;testing.B&lt;/code&gt;, siempre asumiendo
una consumo superior de recursos&lt;/p&gt;

&lt;h2 id=&#34;referencias&#34;&gt;referencias&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;https://www.reddit.com/r/golang/comments/6u4xhs/how_make_a_benchmark_in_a_regular_program_no/&#34;&gt;https://www.reddit.com/r/golang/comments/6u4xhs/how_make_a_benchmark_in_a_regular_program_no/&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://golang.org/pkg/time/&#34;&gt;https://golang.org/pkg/time/&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>regexp4-go (dia cero)</title>
      <link>https://nasciiboy.land/prog/regexp4-go/</link>
      <pubDate>Sat, 15 Jul 2017 21:36:03 -0500</pubDate>
      
      <guid>https://nasciiboy.land/prog/regexp4-go/</guid>
      <description>&lt;p&gt;&lt;img src=&#34;https://nasciiboy.land/img/regexp4.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;regexp4&lt;/strong&gt; es un &amp;ldquo;motor&amp;rdquo; de expresiones regulares de la familia de los motores
regulares &lt;em&gt;Recursive Regexp Raptor&lt;/em&gt;, o expresado de otra forma: una libreria de
expresiones regulares hecha desde cero, reinventando la rueda (o no) de la
manera (que para mi es la) mas simple posible. sin arboles de evaluacion, ni
liberacion de memoria, ni cosas raras o esa es la intencion, almenos de las
versiones en &lt;strong&gt;C&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;cual es entonces la necesidad de que exista esta version en go, podrias
preguntar. Pues segun mi escasa educacion programacional, la simplesa de los
motores raptor es tal, que pueden implementarse en cualquier lenguaje sin recurrir
a ninguna caracteristica no implementada en el lenguaje en si, es decir, sin
recurrir a ninguna libreria, incluyendo a las librerias estandar.&lt;/p&gt;

&lt;p&gt;Siguiendo esta creencia (quiza sin fundamentos) y a modo de prueba de las
caracteristicas de un lenguaje de programacion supongo que hare una costumbre
programar un raptor en cada ocacion que pueda. Ademas el modelo raptor aunque
bastante desarrollado no es perfecto, asi pues, con cada nuevo concepto
aprendido, logro profundizar un poco en busca de una mejor implementacion o el
incremento de caracteristicas segun las facilidades que otorgue el lenguaje&lt;/p&gt;

&lt;p&gt;existen dos versiones de la libreria las regexp3 donde a cada iteracion
valiendose de la recursividad, la expresion regular se convierte en
instrucciones que pueden evaluarse. En las regexp4 en lugar de interpretar la
regexp a cada paso primero se &amp;ldquo;compila&amp;rdquo;&amp;hellip; lo que la hace comporativamente mas
eficiente&lt;/p&gt;

&lt;p&gt;la libreria parte de la version en C y la sintaxis es compatible con esta
version en Go, pero por algunas facilidades que proporciona nativamente este
ultimo lenguaje y por su orientacion a objetos esta no tiene limitacion (que no
sean de hardware) del numero de capturas, la longitud y complejidad de la
expresion y ademas es concurrentemente segura&lt;/p&gt;

&lt;p&gt;bueno, bueno, vamos con los detalles morbosos&amp;hellip; esta version adapta sin mucho
empeño la regexp3 (go) a la version 4. Fueron necesarios varios dias con poco
enfoque donde los momentos de lucides escaceaban, primero aparecio un bicho por no
incrementar un indice del que tarde dos &lt;s&gt;dias&lt;/s&gt; sesiones en darme cuenta y
luego por otras 4 seciones las pruebas que contenian &amp;ldquo;conjuntos&amp;rdquo; (&lt;code&gt;[...]&lt;/code&gt;) se
resistian a funcionar, jo, el problema fue no colocar las constantes correctas
dentro de un &lt;code&gt;switch&lt;/code&gt;, je, por un momento me planteee hacer pruebas de cada
una de las funciones hasta asegurar que todas hicieran lo que se suponia deberia
de hacer&amp;hellip; lo cual no es trivial&lt;/p&gt;

&lt;p&gt;aunque en apariencia sencilla, cada uno de los componentes esta obscuramente
relacionado, y debe realizar su tarea en perfecta armonia con los demas, por
ello es necesario ponerse en serio con el asunto, y ya que esto escapaba un poco
de mi control, solo me limite a ejecutar las pruebas preexistentes y tambien a
comprobar el funcionamiento con &lt;em&gt;morg&lt;/em&gt;, asi pues una vez superadas las pruebas,
pese a no estar muy seguro de como &amp;ldquo;interactuava&amp;rdquo; la maquinaria, confie en las
muchas horas invertidas en la version en C y otras tantas en regexp3 en Go,
luego subi el repositorio a modo de respaldo&lt;/p&gt;

&lt;p&gt;Como antes mencione la sistaxis de la regexp es uniforme en todas las versiones,
ademas regexp3 (Go) y la presente compartiran la misma &amp;ldquo;&lt;em&gt;API&lt;/em&gt;&amp;rdquo;, mas esta version
sera extendida con un par de funciones mas (tentativamente) &lt;code&gt;Compile&lt;/code&gt; y
&lt;code&gt;TextMatch&lt;/code&gt; (o algo asi), aprovechando las capacidades de &amp;ldquo;compilacion&amp;rdquo; (tambien
programado de cero) en una forma singular a la que nombre &amp;ldquo;&lt;em&gt;tabla de
instrucciones&lt;/em&gt;&amp;rdquo; y en esta ocacion pretenciosamente las instrucciones de la tabla
lleban el prefijo &lt;code&gt;asm&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;en fin, &lt;a href=&#34;https://github.com/nasciiboy/regexp4/&#34;&gt;aqui&lt;/a&gt; encontraran el
repositorio, los &lt;em&gt;readmes&lt;/em&gt; son un copia y pega de la version regexp3 cambiando
el 3 por 4&lt;/p&gt;

&lt;p&gt;happy hacking!&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>El Lenguaje De programacion Go</title>
      <link>https://nasciiboy.land/prog/tgpl/</link>
      <pubDate>Mon, 29 May 2017 22:02:43 -0500</pubDate>
      
      <guid>https://nasciiboy.land/prog/tgpl/</guid>
      <description>

&lt;p&gt;golang, el lenguaje de &lt;q&gt;programacion de sistemas&lt;/q&gt; de la gente de google con
el que planea llebar a cabo sus mas retorcidos y stalkerosos deseos.&lt;/p&gt;

&lt;p&gt;Hoy y tras pocos meses de programacion y muchas horas de investigacion
linguistica intentando entender el english, les traigo una reseña de la biblia
de golang (Go para los amigos) &lt;em&gt;The Go Programming Language&lt;/em&gt; (en adelante
TGPL o GPL(?))&lt;/p&gt;

&lt;h2 id=&#34;el-libro&#34;&gt;el libro&lt;/h2&gt;

&lt;p&gt;Los usa-americanos tienen sus medidas extravagantes. Siguiendo su ejemplo, yo
mido la extencion de un documento en las lineas (de 80 columnas indentadas) que
abarca, por ejemplo, 7000-10000 lineas suelen ser la extencion regular de una
novela, debajo de esta cantidad es un trabajo corto, superior de esta es extenso
y superior a las 20000 lineas ya es &lt;em&gt;muy extenso&lt;/em&gt;, aunque &lt;em&gt;Dune&lt;/em&gt;
utiliza (y muy bien) la friolera y descomunal cantidad de 34150 lineas.&lt;/p&gt;

&lt;p&gt;Pues bien, TGPL son 21426 lineas, repartidas a partes iguales entre explicaciones
y codigo fuente. Si quieres la extencion en paginas, son cerca de 400, aunque no
confiaria en esta medida&lt;/p&gt;

&lt;p&gt;La mayor parte del libro se utiliza para mostrar la forma de hacer las cosas en
Go: sintaxis, ideologia y paquetes. Haciendo un simil con C seria algo asi como
que te enseñaran a hacer muchas herramientas del sistema, mas una guia de &lt;code&gt;gcc&lt;/code&gt;,
&lt;code&gt;make&lt;/code&gt; y alguna cosa mas.&lt;/p&gt;

&lt;p&gt;Se asume que ya conoces al menos un lenguaje de programacion, particularmente C
o alguno de su descendencia y aunque no es necesario que manejes programacion
orientada a objetos y/o concurrencia es deseable contar con tales saberes antes
de iniciar la aventura&lt;/p&gt;

&lt;p&gt;Repitiendo, no es un manual para no iniciados, es decir, para quien no tenga ya
asumido en su ser lo que es programar, resultara hostil. Diria que es apto como
tercer o cuarto libro de programacion&lt;/p&gt;

&lt;p&gt;Se enseña a construir aplicaciones no triviales, utilzando la rica libreria
estandar del lenguaje, aunque la mayoria encaminadas al tema web, ninguna es
despreciable, incluso se propone la construccion de un parser de espreciones-S y
un pequeño interprete para un lenguaje de programacion. No se llega a
profundizar veraderamente en ningun tema, pero se da lo suficiente como para
enfrentar lo desconocido sin temor (jo, lo dice quien no ha hecho mas de 4
ejericios)&lt;/p&gt;

&lt;p&gt;Igualmente poco se indaga sobre la herramienta principal del lenguaje (&lt;code&gt;go&lt;/code&gt;) que
es a la vez un compilador, perfilador (primera ves que utilizo algo asi),
administador de paquetes, &amp;ldquo;visor&amp;rdquo; de documentacion y muchas cosas mas. Un par de
comandos para iniciar a hacer cosas y un par de comandos esotericos. Vamos,
tampoco es para abrumar, si es bueno y sencillo, es mas del doble de bueno&amp;hellip; o
eso diria. Siendo suficiente para iniciar, hecho en falta mayor detalle en
varios comandos que requieren un orden y sintaxis nada evidentes, parecidos mas a
conjuros misteriosos&lt;/p&gt;

&lt;p&gt;en resumen, recomendo su lectura a cualquiera, en particular si se biene de C o
C++ y se aspira a lenguajes mas desapegados de la maquina, sin topar de lleno en
abstracciones incomprensibles&lt;/p&gt;

&lt;h2 id=&#34;el-lengueje&#34;&gt;el lengueje&lt;/h2&gt;

&lt;p&gt;el libro esta muy bien!, que tal el lenguaje?&lt;/p&gt;

&lt;p&gt;bueno, desde la perspectiva de un aficionado a C, que ha pasado por C++, bash y
un ligero viaje por lisp, el lenguaje me gusta mucho, aunque no puedo perdonarle
que inponga un estilo arbitrario de como han de indentarse y separarse las
instrucciones, es decir el formateo. Viniendo de C tener llaves para
instrucciones sencillas (una instruccion) me parece atroz, por no decir forzar
la posicion de apertura y cierre de las demas llaves, sobre todo en
instrucciones &lt;code&gt;else&lt;/code&gt;, no lo soporto esteticamente! Ya por utilizar tabs
para indentar, deben arder en la hogera&lt;/p&gt;

&lt;p&gt;Como te obligan a seguir su estilo? si no cumples con el formato no compila&amp;hellip;&lt;/p&gt;

&lt;p&gt;dejando atras este no precisamente poco importante aspecto, tenemos el
inmobiliario habitual de los descendientes de C, ifs, elses, else ifs,
funciones, arreglos, switches, return, gotos y bucles for, careciendo de bucles
while y do while, pero sumando slices, que son una especie de arreglo con
crecimiento dinamico automagico (el lenguaje tien recolector de basura), mapas
hash, una funcion llamada &lt;code&gt;defer&lt;/code&gt;, &lt;code&gt;gorutinas&lt;/code&gt; para programacion concurrente,
&lt;q&gt;canales&lt;/q&gt; para pasar datos a las gorutinas y asegurar que completen su
ciclo, pero sobre todo y quiza lo mas interesante del lenguaje su orientacion a
objetos no evidente&lt;/p&gt;

&lt;p&gt;el lenguaje tiene una forma &lt;q&gt;peculiar&lt;/q&gt; de organizar sus parametros (al
revez de C tipo-nombre, aqui es nombre(s)-tipo) que no pocas veces me ha causado
transtornos cuando regreso a tocar C, p-e-r-o ninguna queja, tambien se ve bien.&lt;/p&gt;

&lt;p&gt;quiza lo que mas atractivo de Go es tratar de no ser ser innecesariamente
complejo en ningun aspecto, al grado de que entrar a una libreria sin conocer el
lenguaje da la imprecion de estar ante un lenguaje imperativo.&lt;/p&gt;

&lt;p&gt;Fascinante es que la orientacion a objetos surja por si sola. MMMM, no esta
permitida la sobre carga de operadores, la convercion automatica de tipos ni la
extencion de una clase fuera de su fichero de definicion. A cambio nos dan
composicion e interfases&lt;/p&gt;

&lt;p&gt;los ficheros de codigo fuente por defecto utilizan codificacion unicode utf-8,
que en conjunto con una funcion nativa llamada &lt;code&gt;range&lt;/code&gt; permiten iterar sobre
cadenas unicode sin tener que recurrir a esotericas librerias. Tambien se
permite convecion automagica de entre &lt;code&gt;runas&lt;/code&gt; unicode de 32 bits a cadenas de
caracteres utf-8&lt;/p&gt;

&lt;p&gt;por cierto, aunque el nucleo del lenguaje es compacto la libreria
estandar es muy rica, te da un servidor web, analisis en cadenas, codificadores,
compresores y otro monton de cosas&lt;/p&gt;

&lt;p&gt;es sencillo crear programas relativamente complejos con estas facilidades,
aunque encuentro incomoda la herramienta de documentacion para linea de comandos&lt;/p&gt;

&lt;p&gt;pese a lo amplio de la libreria estandar, carece de librerias nativas para
graficos y esto es un punto flaco, considerando que si te apegas a la libreria
estandar tus programas son multiplataforma y que el costructor de programas es
por naturaleza multiplataforma es triste no contar con herramientas oficiales
para crear GUIs o al menos TUIs. Lamentablemente, veo poco probable que algun dia
llegue a tener librerias nativas para estos menesteres&amp;hellip; a menos que el gestor
de paquetes pueda meter sus manos en el gestor de paquetes del sistema en si
(apt, dnf, yum, etc)&lt;/p&gt;

&lt;p&gt;me encanta como administra las &amp;ldquo;librerias&amp;rdquo;/paquetes externos, nada de buscar por
internet, ni compilar a mano, ni naaah, el solito busca las dependencias y las
enlaza. Nunca perdonare al comite de los estandares de C y C++, por no copiar
este aspecto y evolucionarlos de forma razonable, si hicieran su labor no
tendria que aparecen Go&lt;/p&gt;

&lt;p&gt;respecto a la concurrencia, no tenia ninguna experiencia previa, era un tema
mistico, magico y misterioso y sin embargo he podido implementar un tipo
concurrente, aunque no se, encuentro un poco criptica las formas en que esta
implementada, aunque como digo desconosco como se haga esto en otros lenguajes,
de momento la puedo usar sin muchos complejos ingorando una parte que tenia que
ver con bucles for, captura de variables y cosas concurrentes que no me quedo
muy clara en el libro&lt;/p&gt;

&lt;h3 id=&#34;cosas-feas&#34;&gt;cosas feas&lt;/h3&gt;

&lt;p&gt;ademas del jodido formateo? cast, cast, cast por todas partes, y si no aplicas
cast, he?, creas una varible extra con el cast apropiado al inicio de la funcion&amp;hellip;
teniendo que asignar memoria extra&amp;hellip;?&lt;/p&gt;

&lt;p&gt;tan dificil y peligroso es asumir que el programador sabe que es lo que hace con
los tipos que escoge y en consonancia hacer conversion automatica de tipos, digo
con tener conversion autamatica en llamadas a fuciones seria un gran alivio,
pero no, ademas ni ellos resepetan su estricto y seguro tipado (ironia), pues
aveces hacen convesiones automaticas para ciertas tareas, a sabiendas de lo poco
practico de tal desicion. La evidencia de que comprenden el problema se muestra
cuando por lo general se regresar &lt;code&gt;int&lt;/code&gt;s aun en valores que deverian ser unsigned&lt;/p&gt;

&lt;p&gt;no le haria mal al lenguaje separar la herramienta &lt;code&gt;go&lt;/code&gt; en varias utilidades, en
particular para la documentacion, pruebas y perfilado&lt;/p&gt;

&lt;p&gt;tener un solo paquete por directorio es bueno, pero en paquetes conseptualmente
extensos puede ser dificil averiguar la procedencia de una funcion, no es grave
y es principalmente un problema del programador no distribuir el codigo de forma
coherente, pero aun asi se vuelve dificil seguir la logica de un programa extenso&lt;/p&gt;

&lt;h3 id=&#34;conclucion&#34;&gt;conclucion&lt;/h3&gt;

&lt;p&gt;Me gusta y lo recomiendo como lenguaje secundario. Si bien es cierto que tiene
un fuerte enfoque para aplicaciones web es utilizable como lenguaje de
proposito general, entregando un rendimiento aceptable&lt;/p&gt;

&lt;p&gt;segun pruebas mias, su rendimiento esta entre 3 a 4 veces mas lento que su
homologo en C, es decir, si un pragrama demora 1, en Go, demora 4 o 5, bueno no?
si, eheemee, aun tengo conflictos psicologicos al saber que va 3 o 4 veces mas
lento que C, pero bueno al menos no es 100 veces mas lento como el
&lt;q&gt;fabulosisimo&lt;/q&gt; python o JS&lt;/p&gt;

&lt;p&gt;alto, tengo que sacarlo de mi sistema, no programes con python, ni JS, no lo
hagas, por fabor, no son lenguajes paro programar por mas (falsamente) simples o
elegantes que sean. Los lenguajes interpretados son para extender programas o
para servir como prompts, no para crear algo de cero. Sirve de algo tardar unas
horas menos programando en esos lenguajes cuando pasaras la eternidad
ejecutandolos lentamente? hay lo dejo&lt;/p&gt;

&lt;p&gt;Go apenas se encuentra en los limites que considero un rendiminto aceptable.&lt;/p&gt;

&lt;p&gt;Entre 7 y 10 veces mas lento que C, sin importar el paradigma, solo podre
considerar al lenguaje una &lt;q&gt;curiosidad&lt;/q&gt; intelectual&lt;/p&gt;

&lt;h2 id=&#34;porg&#34;&gt;porg&lt;/h2&gt;

&lt;p&gt;durante el ultimo mes, he estado traduciendo o mas bien dando sentido a la
traduccion de las maquinas sobre el libro en cuestion. Pueden optener una copia
del codigo y resultados con&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;git clone https://github.com/nasciiboy/TGPL.git
cd TGPL
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;abren los ficheros &lt;code&gt;html&lt;/code&gt; en su navegador de confianza (pista: el que tiene un
sufijo &lt;code&gt;es&lt;/code&gt;, es el que esta en español&lt;/p&gt;

&lt;p&gt;tambien hay verciones web de una sola pagina del material&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://nasciiboy.land/book4all/tgpl/The-Go-Programming-Language_es.html&#34;&gt;https://nasciiboy.land/book4all/tgpl/The-Go-Programming-Language_es.html&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://nasciiboy.land/book4all/tgpl/The-Go-Programming-Language.html&#34;&gt;https://nasciiboy.land/book4all/tgpl/The-Go-Programming-Language.html&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;para crear el material desde el codigo&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;go get -u https://github.com/nasciiboy/morg
morg toHtml The-Go-Programming-Language.morg
morg toHtml The-Go-Programming-Language_es.morg
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;para ver el fichero directamente en su terminal, utilice &lt;code&gt;morg tui fichero.morg&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;en fin, una labor estandar de traduccion a mi estilo sin acentos.&lt;/p&gt;

&lt;p&gt;apenas es lo suficientemente entendible, y apenas dare mi primer lectura seria
al libro y de paso correjir algunas cosas.&lt;/p&gt;

&lt;p&gt;tuve problemas al localizar muchas cosas, pero si quieres colaborar a mejorar un
manual que nunca iba a aparecer en españøl (o si) tienes mi correo y clave gpg
abajo&lt;/p&gt;

&lt;p&gt;happy hacking&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>regexp3-go (dia cero)</title>
      <link>https://nasciiboy.land/prog/regexp3-go/</link>
      <pubDate>Sat, 11 Feb 2017 10:26:04 -0600</pubDate>
      
      <guid>https://nasciiboy.land/prog/regexp3-go/</guid>
      <description>&lt;p&gt;Hace un año, luego de &amp;ldquo;maquetar&amp;rdquo; algunos libros en org-mode, decidi crear mi
propio lenguaje de marcas ligeras, con casinos y colegialas japonesas, programar
un substituto del comando man/info y aniquilar a html/latex como sistema de
documentacion.&lt;/p&gt;

&lt;p&gt;Un mes mas tarde fruto de la necesidad de &lt;em&gt;parsear&lt;/em&gt; el texto del nuevo lenguaje
y mi incapacidad de entender como utilizar una libreria de expresiones
regulares, nacio Recursive Regexp Raptor (alias regexp3) que es un motor de
expresiones regulares para C, otro mes mas tarde salio a la web la primer
version en forma de repositorio
en &lt;a href=&#34;https://github.com/nasciiboy/RecursiveRegexpRaptor/&#34;&gt;github&lt;/a&gt; y ahora&amp;hellip; ni
hay un nuevo lenguaje, ni un substituto de man/info, ni ha muerto html y he
dedicado mas horas de las que jamas pense en regexp3 (y regexp4 &amp;ldquo;el sucesor&amp;rdquo;)&lt;/p&gt;

&lt;p&gt;Por un mes (entero) intente programar el interprete del lenguaje de marcas
ligero y fracase, asi que pase al plan de emergencia, ver como estaban hechos
otros interpretes como el de &lt;em&gt;org-mode&lt;/em&gt; o el de &lt;em&gt;reStructured Text&lt;/em&gt;, lo que trajo
un nuevo problema: aprender (e)lisp o aprender python(2|3).&lt;/p&gt;

&lt;p&gt;Lo primero implicaba aprender ingles, encortrar un buen libro y ponerme a
traducir cosas, lo segundo encontrar un buen libro (e intentar por segunda vez
con python), termine llendo por la primer opcion y cuando llego la desesperacion
se mezclo con la segunda.&lt;/p&gt;

&lt;p&gt;Lisp es interesante, asombroso en su simplesa e incomodo en su escritura&lt;/p&gt;

&lt;p&gt;Python&amp;hellip; no puedo con python, lo encuentro aburrido, un pegote de muchas cosas
en un mismo lenguaje e indentar a mano pelada por ahorrar unas llaves es un
sufrimiento carente de toda elegancia&lt;/p&gt;

&lt;p&gt;en fin, que no aprendi mucho de nada&amp;hellip; cerca de octubre del año pasado con la
inquietud de hacer un blog (de nuevo) y tras probar algunos cms llege a &lt;em&gt;&lt;a href=&#34;https://github.com/spf13/hugo&#34;&gt;hugo&lt;/a&gt;&lt;/em&gt;,
me parecio que era sencillo y digno de investigacion, luego de un par de semanas
nacio este blog y decidi aprender algo de su motor de renderizado markdown
llamado &lt;a href=&#34;https://github.com/russross/blackfriday&#34;&gt;blackfriday&lt;/a&gt;&amp;hellip;&lt;/p&gt;

&lt;p&gt;entonces? habia que aprender go&lt;/p&gt;

&lt;p&gt;entonces? mas ingles (solo hay una pequeña guia traducida al
español &lt;a href=&#34;https://github.com/karlseguin/the-little-go-book&#34;&gt;aqui&lt;/a&gt;)&lt;/p&gt;

&lt;p&gt;y haci, pase a buscar un pdf en la web, aparecio &lt;em&gt;The way to go&lt;/em&gt;, luego de unas
semanas viendo ejemplos y como no hay mejor manera de apreder algo que ponerlo
en practica, comenzo el port de lo unico que entiendo a la perfeccion y estoy
orgulloso, asi es, el motor de expresiones regulares (terminen con mi
sufrimiento)&lt;/p&gt;

&lt;p&gt;De momento funciona, aunque no es mas que una copia medio usable de C a Go, sin
ninguna orientacion a objetos.&lt;/p&gt;

&lt;p&gt;Hace ya unos años que di un recorrido ninja por sdl 1.2 y C++ (deitel y como
pensar en c++) medio aprendi algo de OO, pero di media vuelta hacia atras, tome
el C de k&amp;amp;r (+ deitel), algo de ncurses y prometi no programar nada hasta no
dominar C.&lt;/p&gt;

&lt;p&gt;asi que? no me acuerdo de como programar OO&lt;/p&gt;

&lt;p&gt;y que con go? podria ser un buen sucesor de C, si tubiese punteros de verdad,
cadenas de caracteres de verdad, un tipado menos estricto, pero sobre todo, si
presindiera de su estupido autoformateo, guia de estilo y llaves para
instrucciones simples, te maldigo &lt;code&gt;gofmt&lt;/code&gt;!&lt;/p&gt;

&lt;p&gt;y &lt;em&gt;regexp3-go&lt;/em&gt; que? &lt;a href=&#34;https://github.com/nasciiboy/regexp3/&#34;&gt;aqui&lt;/a&gt;, algo mas de
informacion en el readme&lt;/p&gt;

&lt;p&gt;que sigue? transitar la aleatoriedad.&lt;/p&gt;

&lt;p&gt;Bueno hasta aqui con mis cosas, pronto (una semana, un mes o mas) una version
simplificada del lenguaje de marcas ligeras.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;../gotor.jpg&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>
