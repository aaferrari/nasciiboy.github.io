<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="es" xml:lang="es">
<head>
<!-- 2018-11-10 sáb 12:29 -->
<meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>El lenguaje de programacion C - Kernighan, Ritchie.</title>
<meta name="generator" content="Org mode" />
<meta name="author" content="BRIAN W. KERNIGHAN &amp; DENNIS M. RITCHIE" />
<link rel="stylesheet" type="text/css" href="worg-data/worg.css" /
</head>
<body>
<div id="content">
<h1 class="title">El lenguaje de programacion C - Kernighan, Ritchie.</h1>
<div id="table-of-contents">
<h2>&Iacute;ndice</h2>
<div id="text-table-of-contents">
<ul>
<li><a href="#orgdb1f615">Prefacio</a></li>
<li><a href="#orge43f8d1">Prefacio a la primera edicion</a></li>
<li><a href="#orgd6d52f9">Introduccion</a></li>
<li><a href="#orgc4990f1">capitulo 1: Introduccion general                                    </a>
<ul>
<li><a href="#org88d09cd">1.1  Comencemos                                                    </a></li>
<li><a href="#orgfe64a15">1.2  Variables y expresiones aritmeticas                           </a></li>
<li><a href="#org0756296">1.3  La proposicion for                                            </a></li>
<li><a href="#org6a40344">1.4  Constantes simbolicas                                         </a></li>
<li><a href="#orgbea7c3b">1.5  Entrada y salida de caracteres                                </a>
<ul>
<li><a href="#org2e38daa">1.5.1 Copia de archivos                                           </a></li>
<li><a href="#orga9076fa">1.5.2 Conteo de caracteres                                        </a></li>
<li><a href="#orge7b7124">1.5.3 Conteo de lineas                                            </a></li>
<li><a href="#org0b39e7f">1.5.4 Conteo de palabras                                          </a></li>
</ul>
</li>
<li><a href="#orgb2969a5">1.6  Arreglos                                                      </a></li>
<li><a href="#org8ca612d">1.7  Funciones                                                     </a></li>
<li><a href="#org4a4a9b1">1.8  Argumentos - llamadas por valor                               </a></li>
<li><a href="#org7265fff">1.9  Arreglos de caracteres                                        </a></li>
<li><a href="#org4e01f7d">1.10 Variables externas y alcance                                  </a></li>
</ul>
</li>
<li><a href="#orgf845bad">capitulo 2: Tipos, operadores y expresiones                         </a>
<ul>
<li><a href="#orge1a4f79">2.1  Nombres de variables                                          </a></li>
<li><a href="#org504ea78">2.2  Tipos y tamaños de datos                                      </a></li>
<li><a href="#orgda3bc12">2.3  Constantes                                                    </a></li>
<li><a href="#orga30b21f">2.4  Declaraciones                                                 </a></li>
<li><a href="#orga19702e">2.5  Operadores aritmeticos                                        </a></li>
<li><a href="#org52e7ae4">2.6  Operadores de relacion y logicos                              </a></li>
<li><a href="#orgdf5ae32">2.7  Conversiones de tipo                                          </a></li>
<li><a href="#orgc09bc02">2.8  Operadores de incremento y decremento                         </a></li>
<li><a href="#org77bf0d9">2.9  Operadores para manejo de bits                                </a></li>
<li><a href="#org01da028">2.10 Operadores de asignacion y expresiones                        </a></li>
<li><a href="#orga67c522">2.11 Expresiones condicionales                                     </a></li>
<li><a href="#org465098e">2.12 Precedencia y orden de evaluacion                             </a></li>
</ul>
</li>
<li><a href="#org4490919">capitulo 3: Control de flujo                                        </a>
<ul>
<li><a href="#org012d070">3.1  Proposiciones y bloques                                       </a></li>
<li><a href="#orge44b8dd">3.2  <code>if-else</code>                                                     </a></li>
<li><a href="#org6a03fb6">3.3  <code>else-if</code>                                                     </a></li>
<li><a href="#orge1cacbd">3.4  <code>switch</code>                                                      </a></li>
<li><a href="#orgd5e84fe">3.5  Ciclos <code>while</code> y <code>for</code>                                        </a></li>
<li><a href="#org11f9b93">3.6  Ciclos <code>do-while</code>                                             </a></li>
<li><a href="#orgd6f8690">3.7  <code>break</code> y <code>continue</code>                                          </a></li>
<li><a href="#orga5166c6">3.8  <code>goto</code> y etiquetas                                            </a></li>
</ul>
</li>
<li><a href="#orgf6a9aca">capitulo 4: Funciones y la estructura del programa                  </a>
<ul>
<li><a href="#orgcb61671">4.1  Conceptos basicos de funciones                                </a></li>
<li><a href="#orgc06f3b2">4.2  Funciones que regresan valores no enteros                     </a></li>
<li><a href="#org5eb7291">4.3  Variables externas                                            </a></li>
<li><a href="#org92f5d93">4.4  Reglas de alcance                                             </a></li>
<li><a href="#orga1df3f2">4.5  Archivo de encabezamiento <code>header</code>                            </a></li>
<li><a href="#org2d32506">4.6  Variables estaticas                                           </a></li>
<li><a href="#org4505195">4.7  Variables tipo registro                                       </a></li>
<li><a href="#orgc66d62b">4.8  Estructura de bloques                                         </a></li>
<li><a href="#org6e74dcc">4.9  Inicializacion                                                </a></li>
<li><a href="#org80ccc0d">4.10 Recursividad                                                  </a></li>
<li><a href="#orgdc3914a">4.11 El preprocesador de C                                         </a>
<ul>
<li><a href="#orgc847546">4.11.1 Inclusion de archivos                                      </a></li>
<li><a href="#org08c78dd">4.11.2 Substitucion de macros                                     </a></li>
<li><a href="#org5e77945">4.11.3 Inclusion condicional                                      </a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#orgf0a8297">capitulo 5: Apuntadores y arreglos                                  </a>
<ul>
<li><a href="#orgf7ed1c8">5.1  Apuntadores y direcciones                                     </a></li>
<li><a href="#orge524012">5.2  Apuntadores y argumentos de funciones                         </a></li>
<li><a href="#org52b8b5a">5.3  Apuntadores y arreglos                                        </a></li>
<li><a href="#orgab7cd6c">5.4  Aritmetica de direcciones                                     </a></li>
<li><a href="#org8d6bc13">5.5  Apuntadores a caracteres, y funciones                         </a></li>
<li><a href="#org7ac205b">5.6  Arreglos de apuntadores; apuntadores a apuntadores            </a></li>
<li><a href="#org8f7af81">5.7  Arreglos multidimensionales                                   </a></li>
<li><a href="#org5346f97">5.8  Inicializacion de arreglos de apuntadores                     </a></li>
<li><a href="#org31a281b">5.9  Apuntadores vs. arreglos multidimensionales                   </a></li>
<li><a href="#org140c9c2">5.10 Argumentos en la linea de ordenes                             </a></li>
<li><a href="#orgd015a35">5.11 Apuntadores a funciones                                       </a></li>
<li><a href="#org30c8d07">5.12 Declaraciones complicadas                                     </a></li>
</ul>
</li>
<li><a href="#orga7053eb">capitulo 6: Estructura                                              </a>
<ul>
<li><a href="#orgbe208f6">6.1  Conceptos basicos sobre estructuras                           </a></li>
<li><a href="#org1c16408">6.2  Estructuras y funciones                                       </a></li>
<li><a href="#orgc12116e">6.3  Arreglos de estructuras                                       </a></li>
<li><a href="#org7220a24">6.4  Apuntadores a estructuras                                     </a></li>
<li><a href="#org053695b">6.5  Estructuras autorreferenciadas                                </a></li>
<li><a href="#orgd34cf1d">6.6  Busqueda en tablas                                            </a></li>
<li><a href="#org30db592">6.7  Typedef                                                       </a></li>
<li><a href="#org566d372">6.8  Uniones                                                       </a></li>
<li><a href="#orgd03c1a3">6.9  Campos de bits                                                </a></li>
</ul>
</li>
<li><a href="#org6982d3e">capitulo 7: Entrada y salida                                        </a>
<ul>
<li><a href="#org15288e7">7.1  Entrada y salida estandar                                     </a></li>
<li><a href="#org310ffee">7.2  Salida con formato - <code>printf</code>                                 </a></li>
<li><a href="#orgdb129c6">7.3  Listas de argumentos de longitud variable                     </a></li>
<li><a href="#org6b76a23">7.4  Entrada con formato - <code>scanf</code>                                 </a></li>
<li><a href="#org1da08db">7.5  Acceso a archivos                                             </a></li>
<li><a href="#org320c33f">7.6  Manejo de errores - <code>stderr</code> y <code>exit</code>                         </a></li>
<li><a href="#orge5bbcf2">7.7  Entrada y salida de lineas                                    </a></li>
<li><a href="#org7d23f09">7.8  Otras funciones                                               </a>
<ul>
<li><a href="#org6aef657">7.8.1 Operaciones sobre cadenas                                   </a></li>
<li><a href="#orgaf127ef">7.8.2 Prueba y conversion de clases de caracteres                 </a></li>
<li><a href="#orgacf4478">7.8.3 <code>ungetc</code>                                                    </a></li>
<li><a href="#org4073399">7.8.4 Ejecucion de ordenes                                        </a></li>
<li><a href="#org97c37b1">7.8.5 Administracion del almacenamiento                           </a></li>
<li><a href="#org162b11c">7.8.6 Funciones matematicas                                       </a></li>
<li><a href="#orgd773f8a">7.8.7 Generacion de numeros aleatorios                            </a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#orga6e66c5">capitulo 8: La interfaz con el sistema UNIX                         </a>
<ul>
<li><a href="#org798c0fa">8.1  Descriptores de archivos                                      </a></li>
<li><a href="#org1f773e9">8.2  E/S de bajo nivel - <code>read</code> y <code>write</code>                          </a></li>
<li><a href="#org5ad2ba2">8.3  <code>open</code>, <code>creat</code>, <code>close</code>, <code>unlink</code>                            </a></li>
<li><a href="#orge0ef88a">8.4  Acceso aleatorio - <code>lseek</code>                                    </a></li>
<li><a href="#org5aa8f92">8.5  Ejemplo - una realizacion de <code>fopen</code> y <code>getc</code>                 </a></li>
<li><a href="#org9a8872b">8.6  Ejemplo - listado de directorios                              </a></li>
<li><a href="#orgafd9577">8.7  Ejemplo - asignador de memoria                                </a></li>
</ul>
</li>
<li><a href="#org920e841">Apendice A: Manual de referencia                                    </a>
<ul>
<li><a href="#orgca49a38">A1   Introduccion                                                  </a></li>
<li><a href="#org5c060fe">A2   Convenciones lexicas                                          </a>
<ul>
<li><a href="#org59cca1e">A2.1 Componentes lexicos (tokens)                                 </a></li>
<li><a href="#org3b1e3bd">A2.2 Comentarios                                                  </a></li>
<li><a href="#orga28a346">A2.3 Identificadores                                              </a></li>
<li><a href="#orge37dbd3">A2.4 Palabras reservadas                                          </a></li>
<li><a href="#org188f7c6">A2.5 Constantes                                                   </a>
<ul>
<li><a href="#org7fc886c">A2.5.1 Constantes enteras                                        </a></li>
<li><a href="#org4c93fed">A2.5.2 Constantes de caracter                                    </a></li>
<li><a href="#orgb13f2c0">A2.5.3 Constantes flotantes                                      </a></li>
<li><a href="#org21f04a8">A2.5.4 Constantes de enumeracion                                 </a></li>
</ul>
</li>
<li><a href="#org328d2fc">A2.6 Cadenas literales                                            </a></li>
</ul>
</li>
<li><a href="#org1a3b387">A3   Notacion sintactica                                           </a></li>
<li><a href="#org23b7c5e">A4   Significado de los identificadores                            </a>
<ul>
<li><a href="#org002922b">A4.1 Categorias de almacenamiento                                 </a></li>
<li><a href="#org71ffce2">A4.2 Tipos basicos                                                </a></li>
<li><a href="#org11ec79a">A4.3 Tipos derivados                                              </a></li>
<li><a href="#org76c1877">A4.4 Calificadores de tipo                                        </a></li>
</ul>
</li>
<li><a href="#org99c6e1e">A5   Objetos y valores-l                                           </a></li>
<li><a href="#org9c390c4">A6   Conversiones                                                  </a>
<ul>
<li><a href="#org25b811b">A6.1 Promocion entera                                             </a></li>
<li><a href="#org3a3fed1">A6.2 Conversiones enteras                                         </a></li>
<li><a href="#org9d7ba49">A6.3 Entero y flotante                                            </a></li>
<li><a href="#org209debe">A6.4 Tipos flotantes                                              </a></li>
<li><a href="#org2ef95c1">A6.5 Conversiones aritmeticas                                     </a></li>
<li><a href="#org99a94be">A6.6 Apuntadores y enteros                                        </a></li>
<li><a href="#orgc716a8f">A6.7 Void                                                         </a></li>
<li><a href="#org9e9092f">A6.8 Apuntadores a void                                           </a></li>
</ul>
</li>
<li><a href="#org0ee3589">A7   Expresiones                                                   </a>
<ul>
<li><a href="#org523e5e7">A7.1 Generacion de apuntadores                                    </a></li>
<li><a href="#orgc5bdccb">A7.2 Expresiones primarias                                        </a></li>
<li><a href="#orgd0cc058">A7.3 Expresiones posfijas                                         </a>
<ul>
<li><a href="#orgac7249f">A7.3.1 Referencias a arreglos                                    </a></li>
<li><a href="#org25f0da6">A7.3.2 Llamadas a funciones                                      </a></li>
<li><a href="#org16545c5">A7.3.3 Referencias a estructuras                                 </a></li>
<li><a href="#orga0127a8">A7.3.4 Incrementos posfijos                                      </a></li>
</ul>
</li>
<li><a href="#orgf0ae25f">A7.4 Operadores unarios                                           </a>
<ul>
<li><a href="#org6a7a7fe">A7.4.1 Operadores prefijos de incremento                         </a></li>
<li><a href="#orgb0f6155">A7.4.2 Operador de dreccion                                      </a></li>
<li><a href="#org11490be">A7.4.3 Operador de irtfireccion                                  </a></li>
<li><a href="#orgccc7ffd">A7.4.4 Operador mas unario                                       </a></li>
<li><a href="#org0c42656">A7.4.5 Operador menos unario                                     </a></li>
<li><a href="#org3962a6d">A7.4.6 Operador compemento a uno                                 </a></li>
<li><a href="#orga21f3ca">A7.4.7 Operador de negacion logica                               </a></li>
<li><a href="#org96ac14c">A7.4.8 Operador sizeol                                           </a></li>
</ul>
</li>
<li><a href="#org6f3b9ae">A7.5 Cast                                                         </a></li>
<li><a href="#org1eb2fe9">A7.6 Operadores multiplicativos                                   </a></li>
<li><a href="#org99d2b5e">A7.7 Operadores aditivos                                          </a></li>
<li><a href="#org0e17b45">A7.8 Operadores de corrimiento                                    </a></li>
<li><a href="#orgf9423be">A7.9 Operadores de relacion                                       </a></li>
<li><a href="#orgda6f092">A7.10 Operadores de igualdad                                      </a></li>
<li><a href="#org43fde4c">A7.11 Operador AND para bits                                      </a></li>
<li><a href="#org5db16b1">A7.12 Operador OR exclusivo para bits                             </a></li>
<li><a href="#orgd1d3d1d">A7.13 Operador OR inclusivo para bits                             </a></li>
<li><a href="#org4e0e8d3">A7.14 Operador logico AND                                         </a></li>
<li><a href="#org8196249">A7.15 Operador logico OR                                          </a></li>
<li><a href="#orgf2b929c">A7.16 Operador condicional                                        </a></li>
<li><a href="#org9de8d8c">A7.17 Expresiones de asignacion                                   </a></li>
<li><a href="#org59a1d22">A7.18 Operador coma                                               </a></li>
<li><a href="#org5e40114">A7.19 Expresiones constantes                                      </a></li>
</ul>
</li>
<li><a href="#orgbe16103">A8   Declaraciones                                                 </a>
<ul>
<li><a href="#orgfa62e75">A8.1 Especificadores de categoria de almacenamiento               </a></li>
<li><a href="#orga1c1af9">A8.2 Especificadores de tipo                                      </a></li>
<li><a href="#org660d855">A8.3 Declaraciones de estructura y union                          </a></li>
<li><a href="#org65d5166">A8.4 Enumeraciones                                                </a></li>
<li><a href="#org9fadbe1">A8.5 Declaradores                                                 </a></li>
<li><a href="#orgc65b74e">A8.6 Significado de los declaradores                              </a>
<ul>
<li><a href="#orgbc85c78">A8.6.1 Declaradores de apuntadores                               </a></li>
<li><a href="#org0de1d95">A8.6.2 Declaradores de arreglos                                  </a></li>
<li><a href="#org949d756">A8.6.3 Declaracion de funciones                                  </a></li>
</ul>
</li>
<li><a href="#org41627ce">A8.7 Inicializacion                                               </a></li>
<li><a href="#org53c8312">A8.8 Nombres de tipos                                             </a></li>
<li><a href="#orgdc2e07a">A8.9 Typedef                                                      </a></li>
<li><a href="#orgf49346e">A8.10 Equivalencia de tipo                                        </a></li>
</ul>
</li>
<li><a href="#orga3b0830">A9   Proposiciones                                                 </a>
<ul>
<li><a href="#orgfec7bf8">A9.1 Proposiciones etiquetadas                                    </a></li>
<li><a href="#org53fd7c4">A9.2 Proposicion de expresion                                     </a></li>
<li><a href="#org5fc4dce">A9.3 Proposicion compuesta                                        </a></li>
<li><a href="#orgc8462ca">A9.4 Proposiciones de seleccion                                   </a></li>
<li><a href="#orgb22e815">A9.5 Proposiciones de iteracion                                   </a></li>
<li><a href="#org30500fb">A9.6 Proposiciones de salto                                       </a></li>
</ul>
</li>
<li><a href="#orgae35f9a">A10  Declaraciones externas                                        </a>
<ul>
<li><a href="#org4ee0f62">A10.1 Definicion de funciones                                     </a></li>
<li><a href="#org9e89747">A10.2 Declaraciones externas                                      </a></li>
</ul>
</li>
<li><a href="#orgde37996">A11  Alcance y enlace                                              </a>
<ul>
<li><a href="#org908a650">A11.1 Alcance lexico                                              </a></li>
<li><a href="#orgf703a82">A11.2 Enlace                                                      </a></li>
</ul>
</li>
<li><a href="#org32f3838">A12  Preprocesamiento                                              </a>
<ul>
<li><a href="#orge25fecd">A12.1 Secuencias trigraficas                                      </a></li>
<li><a href="#org9fa7879">A12.2 Union de lineas                                             </a></li>
<li><a href="#orge236d94">A12.3 Definicion y expansion de macros                            </a></li>
<li><a href="#org5c48a81">A12.4 Inclusion de archivos                                       </a></li>
<li><a href="#org46c0294">A12.5 Compilacion condicional                                     </a></li>
<li><a href="#orgd738ab2">A12.6 Control de linea                                            </a></li>
<li><a href="#orgd547bc3">A12.7 Generacion de errores                                       </a></li>
<li><a href="#orgb514431">A12.8 Pragmas                                                     </a></li>
<li><a href="#orgfbc4db2">A12.9 Directiva nula                                              </a></li>
<li><a href="#orga0fd96d">A12.10 Nombres predefinidos                                       </a></li>
</ul>
</li>
<li><a href="#org0b71afb">A13  Gramatica                                                     </a></li>
</ul>
</li>
<li><a href="#org9270bdb">Apendice B: Biblioteca estandar                                     </a>
<ul>
<li><a href="#org1189a3b">B1   Entrada y salida: <code>&lt;stdio.h&gt;</code>                                 </a>
<ul>
<li><a href="#orgada7b94">B1.1 Operaciones sobre archivos                                   </a>
<ul>
<li><a href="#org78288ea">=fopen=</a></li>
<li><a href="#org0bbbe2b">=freopen=</a></li>
<li><a href="#orgd9ee5d7">=fflush=</a></li>
<li><a href="#org55e44e8">=fclose=</a></li>
<li><a href="#orgf182144">=remove=</a></li>
<li><a href="#org9d60bb3">=rename=</a></li>
<li><a href="#org840bbbe">=tmpfile=</a></li>
<li><a href="#org0f2df97">=tmpnam=</a></li>
<li><a href="#org6dc1748">=setvbuf=</a></li>
<li><a href="#orgca68d5f">=setbuf=</a></li>
</ul>
</li>
<li><a href="#org85879ae">B1.2 Salida con formato                                           </a>
<ul>
<li><a href="#org0240597">=fprintf=</a></li>
<li><a href="#org5e1c949">=printf=</a></li>
<li><a href="#org93e4bac">=sprintf=</a></li>
<li><a href="#orgb858b18">=vprintf=</a></li>
<li><a href="#orgd511460">=vfprintf=</a></li>
<li><a href="#org12ee179">=vsprintf=</a></li>
</ul>
</li>
<li><a href="#orgd054f48">B1.3 Entrada con formato                                          </a>
<ul>
<li><a href="#org51de28c">=fscanf=</a></li>
<li><a href="#org0853adc">=scanf=</a></li>
<li><a href="#orgf775980">=sscanf=</a></li>
</ul>
</li>
<li><a href="#org19260ec">B1.4 Funciones de entrada y salida de caracteres                  </a>
<ul>
<li><a href="#org20382a4">=fgetc=</a></li>
<li><a href="#orga692b8e">=fgets=</a></li>
<li><a href="#orgb923c81">=fputc=</a></li>
<li><a href="#org3ef7764">=fputs=</a></li>
<li><a href="#orgae2a6aa">=getc=</a></li>
<li><a href="#orgbf08755">=getchar=</a></li>
<li><a href="#orgae965ce">=gets=</a></li>
<li><a href="#orgc7b63c8">=putc=</a></li>
<li><a href="#org4cd8139">=putchar=</a></li>
<li><a href="#org132728a">=puts=</a></li>
<li><a href="#orga388533">=ungetc=</a></li>
</ul>
</li>
<li><a href="#org4a69620">B1.5 Funciones de entrada y salida directa                        </a>
<ul>
<li><a href="#org75df545">=fread=</a></li>
<li><a href="#org4cb521b">=fwrite=</a></li>
</ul>
</li>
<li><a href="#orgb266019">B1.6 Funciones de posicionamiento en archivos                     </a>
<ul>
<li><a href="#org4583405">=fseek=</a></li>
<li><a href="#orgbca3da5">=ftell=</a></li>
<li><a href="#orgf50f9dd">=rewind=</a></li>
<li><a href="#org310cefb">=fgetpos=</a></li>
<li><a href="#org9ca8fb1">=fsetpos=</a></li>
</ul>
</li>
<li><a href="#org4753f1e">B1.7 Funciones de error                                           </a>
<ul>
<li><a href="#org97716e7">=clearerr=</a></li>
<li><a href="#org0e82d41">=feof=</a></li>
<li><a href="#orge7d9b76">=ferror=</a></li>
<li><a href="#org7133a1d">=perror=</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#org93c9679">B2   Pruebas de clasificacion de caracteres: <code>&lt;ctype.h&gt;</code>           </a></li>
<li><a href="#org2741370">B3   Funciones para cadenas: <code>&lt;string.h&gt;</code>                          </a></li>
<li><a href="#org2429365">B4   Funciones matematicas: &lt;math.h&gt;                               </a></li>
<li><a href="#org738460c">B5   Funciones de utileria: &lt;stdlib.h&gt;                             </a>
<ul>
<li><a href="#org8b77f5f">=atof=</a></li>
<li><a href="#org1d36cab">=atoi=</a></li>
<li><a href="#org0dbd981">=atol=</a></li>
<li><a href="#org451520d">=strtod=</a></li>
<li><a href="#orge9f0f95">=strtol=</a></li>
<li><a href="#org2f9ccda">=strtoul=</a></li>
<li><a href="#orgd634f5a">=rand=</a></li>
<li><a href="#orge954c0e">=srand=</a></li>
<li><a href="#org393ee21">=calloc=</a></li>
<li><a href="#orga14c41c">=malloc=</a></li>
<li><a href="#orgd58718c">=realloc=</a></li>
<li><a href="#orgbb71da8">=free=</a></li>
<li><a href="#orged3e936">=abort=</a></li>
<li><a href="#org49ff291">=exit=</a></li>
<li><a href="#orgdfa56d3">=atexit=</a></li>
<li><a href="#orgb70001b">=system=</a></li>
<li><a href="#orga9cfb5c">=getenv=</a></li>
<li><a href="#org9080cdf">=bsearch=</a></li>
<li><a href="#org73f94dc">=qsort=</a></li>
<li><a href="#orgc384539">=abs=</a></li>
<li><a href="#orgd65fe31">=labs=</a></li>
<li><a href="#org24351e5">=div=</a></li>
<li><a href="#org3992958">=ldiv=</a></li>
</ul>
</li>
<li><a href="#orgb109509">B6   Diagnosticos: <code>&lt;assert.h&gt;</code>                                    </a>
<ul>
<li><a href="#orgdc2b15a">=assert=</a></li>
</ul>
</li>
<li><a href="#orgfb09ed2">B7   Listas de argumentos variables: &lt;stdarg.h&gt;                    </a></li>
<li><a href="#org5f475fc">B8   Saltos no locales: <code>&lt;setjmp.h&gt;</code>                               </a>
<ul>
<li><a href="#org05c7918">=setjmp=</a></li>
<li><a href="#org130f1a5">=longjmp=</a></li>
</ul>
</li>
<li><a href="#orgb780161">B9   Señales: <code>&lt;signal.h&gt;</code>                                         </a>
<ul>
<li><a href="#org7aa0e98">=signal=</a></li>
<li><a href="#org1cbd907">=raise=</a></li>
</ul>
</li>
<li><a href="#orga2e5f0a">B10  Funciones de fecha y hora <code>&lt;time.h&gt;</code>                          </a>
<ul>
<li><a href="#org8ba1343">=clock=</a></li>
<li><a href="#org8681d60">=time=</a></li>
<li><a href="#org164a7ce">=difftime=</a></li>
<li><a href="#orge1c018e">=mktime=</a></li>
<li><a href="#org8cd5afe">=asctime=</a></li>
<li><a href="#orga73b0a1">=ctime=</a></li>
<li><a href="#orgb4d4246">=gmtime=</a></li>
<li><a href="#orge2b8274">=localtime=</a></li>
<li><a href="#org44519fe">=strftime=</a></li>
</ul>
</li>
<li><a href="#orgbdb4c59">B11  Limites definidos en la implantacion: <code>&lt;limits.h&gt;</code> y <code>&lt;float.h&gt;</code>  </a></li>
</ul>
</li>
<li><a href="#org38daa93">Apendice C: Resumen de modificaciones                               </a></li>
</ul>
</div>
</div>

<div id="outline-container-orgdb1f615" class="outline-2">
<h2 id="orgdb1f615">Prefacio</h2>
<div class="outline-text-2" id="text-orgdb1f615">
<p>
El mundo de la computacion ha sufrido una revolucion desde la
publicacion, en 1978, de <i>El lenguaje de programacion C</i>. Las
grandes computadoras son ahora mucho mas grandes, y las
computadoras personales tienen capacidades que rivalizan con los
<i>mainframes</i> de hace una decada. Tambien el lenguaje C ha cambiado en
ese tiempo, aunque solo en forma modesta, y se ha extendido mas alla
de lo que fueron sus origenes como el lenguaje del sistema operativo
UNIX.
</p>

<p>
La creciente popularidad de C, los cambios en el lenguaje a lo largo
de los años, y la creacion de compiladores por grupos no
involucrados en su diseño, se combinaron para demostrar la necesidad
de una definicion del lenguaje mas precisa y contemporanea que la
que proporciono la primera edicion de este libro.  En 1983, el
<i>American National Standards Institute</i> (ANSI) establecio un comite
cuyos propositos eran producir "una definicion no ambigua del
lenguaje C e, independiente de la maquina", cuidando la conservacion
de su espiritu. El resultado es el estandar ANSI para el lenguaje C.
</p>

<p>
El estandar formaliza construcciones sugeridas pero no descritas en
la primera edicion, particularmente la asignacion de estructura y
las enumeraciones. Proporciona una nueva forma de declaracion de
funciones, que permite revisar comparativamente su definicion y
uso. Especifica una biblioteca estandar, con un conjunto extensivo
de funciones para realizar la entrada y salida, la administracion
de memoria, la manipulacion de cadenas y tareas semejantes. Precisa
el comportamiento de caracteristicas que no se mencionaron en la
definicion original, y al mismo tiempo establece explicitamente
cuales aspectos del lenguaje tienen aun dependencia de maquina.
</p>

<p>
Esta segunda edicion de <i>El lenguaje de programacion C</i> lo describe
tal como lo definio el estandar ANSI. (En el momento de escribir
esta edicion, el estandar se encontraba en la etapa final de
revision; se esperaba su aprobacion a finales de 1988. Las
diferencias entre lo que se ha descrito aqui y la forma final
deberan ser minimas.) Aunque hemos hecho anotaciones en los lugares
donde el lenguaje ha evolucionado, preferimos escribir
exclusivamente en la nueva forma. En general esto no hace una
diferencia significativa; el cambio mas visible es la nueva forma de
declaracion y definicion de funciones. Los modernos compiladores
manejan ya la mayoria de las posibilidades del estandar
</p>

<p>
Hemos tratado de mantener la brevedad de la primera edicion. El
lenguaje C no es grande, y no le esta bien un gran libro. Hemos
mejorado la exposicion de caracteristicas criticas, como los
apuntadores, que son parte central en la programacion con C. Hemos
redefinido los ejemplos originales y agregamos ejemplos nuevos en
varios capitulos. Por ejemplo, se aumento el tratamiento de
declaraciones complicadas con programas que convierten declaraciones
en palabras y viceversa. Como antes, todos los ejemplos se han
probado directamente a partir del texto, el cual esta diseñado de
manera que lo pueda leer la maquina.
</p>

<p>
El <a href="#orgea26d39">apendice A</a>, manual de referencia, no es el estandar, sino que
nuestra intencion fue trasladar la esencia del estandar a un espacio
mas pequeño. Esta hecho con el animo de que proporcione una facil
comprension para los programadores, pero no como una definicion del
lenguaje para quienes escriben compiladores — ese papel propiamente
le corresponde al estandar en si. El <a href="#org89d4232">apendice B</a> es un resumen de las
posibilidades de la biblioteca estandar. Tambien tiene el proposito
de ser una referencia para programadores, no para implantadores. En
el <a href="#org2311eb8">apendice C</a> se ofrece un resumen de los cambios de la version
original.
</p>

<p>
Como mencionamos en el prefacio a la primera edicion, C "se lleva
bien, en la medida en que aumenta nuestra experiencia con el". Con
una decada mas de experiencia, aun lo sentimos asi. Deseamos que
este libro le ayude a aprender el lenguaje C y tambien como usarlo.
</p>

<p>
Tenemos un profundo reconocimiento hacia los amigos que nos ayudaron
a producir esta segunda edicion. Jon Bentley, Doug Gwyn, Doug
Mcllroy, Peter Nelson y Rob Pike nos dieron valiosos comentarios
sobre casi cada pagina del borrador de este manuscrito. Estamos
agradecidos por la cuidadosa lectura de Al Aho, Dennis Allison, Joe
Campbell, G. R. Emlin, Karen Fortgang, Alien Holub, Andrew Hume,
Dave Kristol, John Linderrmm, Dave Prosser, Gene Spafford, y Chris
Van Wyk. Tambien recibimos utiles sugerencias de Bill Cheswick, Mark
Kernighan, Andy Koening, Robin Lake, Tom London, Jim Reeds, Clovis
Tondo y Peter Weinberger. Dave Prosser respondio muchas preguntas
detalladas acerca del estandar ANSI. Utilizamos extensivamente el
interprete de C++ de Bjarne Stroustrup, para la prueba local de
nuestros programas, y Dave Kristol nos ofrecio un compilador ANSI C
para las pruebas finales. Rich Drechsler nos ayudo grandemente con
la composicion.
</p>

<p>
Nuestro sincero agradecimiento a todos.
</p>

<p>
Brian W. Kernighan
Dennis M. Ritchie
</p>
</div>
</div>

<div id="outline-container-orge43f8d1" class="outline-2">
<h2 id="orge43f8d1">Prefacio a la primera edicion</h2>
<div class="outline-text-2" id="text-orge43f8d1">
<p>
C es un lenguaje de programacion de proposito general que ofrece
como ventajas economia de expresion, control de flujo y estructuras
de datos modernos y un rico conjunto de operadores. Ademas, C no es
un lenguaje de "muy alto nivel" ni "grande", y no esta especializado
en alguna area especial de aplicacion. Pero su ausencia de
restricciones y su generalidad lo hacen mas conveniente y efectivo
para muchas tareas que otros lenguajes supuestamente mas poderosos.
Originalmente, C fue diseñado para el sistema operativo UNIX y
Dennis Ritchie lo implanto sobre el mismo en la DEC PDP-11. El
sistema operativo, el compilador de C y esencialmente todos los
programas de aplicacion de UNIX (incluyendo todo el sofware
utilizado para preparar este libro) estan escritos en C. Tambien
existen compiladores para la produccion en otras maquinas,
incluyendo la IBM System/370, la Honeywell 6000 y la Interdata
8/32. El lenguaje C no esta ligado a ningun hardware o sistema en
particular y es facil escribir programas que correran sin cambios en
cualquier maquina que maneje C.
</p>

<p>
La finalidad de este libro es ayudar al lector a aprender como
programar en C. Contiene una introduccion general para hacer que los
nuevos usuarios se inicien lo mas pronto posible, capitulos
separados sobre cada caracteristica importante y un manual de
referencia. La mayoria de las exposiciones estan basadas en la
lectura, escritura y revision de ejemplos, mas que en el simple
establecimiento de reglas. En su mayoria, los ejemplos son programas
reales y completos, no fragmentos aislados. Todos los ejemplos han
sido probados directamente a partir del texto, el cual esta en forma
legible para la maquina. Ademas de demostrar como hacer un uso
efectivo del lenguaje, donde ha sido posible, tratamos de ilustrar
algoritmos utiles y principios de buen estilo y diseño.
</p>

<p>
El libro no es un manual de introduccion a la programacion; se
supone en el familiaridad con los conceptos basicos de programacion,
como variables, proposiciones de asignacion, ciclos y funciones. No
obstante, un programador novato deber ser capaz de leer y obtener
los conceptos del lenguaje, aunque le ayudaria la cooperacion de un
colega mas experimentado.
</p>

<p>
De acuerdo con nuestra experiencia, C ha demostrado ser un lenguaje
agradable expresivo y versatil para una amplia variedad de
programas. Es facil de aprender y se obtienen mejores resultados a
medida que aumenta nuestra experiencia con el. Deseamos que este
libro le ayude al lector a usarlo correctamente.
</p>

<p>
Las criticas y sugerencias de muchos amigos y colegas han aumentado
muchisimo los conceptos de este libro y ha sido un placer
escribirlo. En particular nuestro agradecimiento a Mike Bianchi, Jim
Blue, Stu Feldman, Doug Mcllroy, Bill Roome, Bob Rosin y Larry
Rosler que leyeron cuidadosamente las numerosas versiones. Tambien
agradecemos Al Aho, Steve Bourne, Dan Dvorak, Chuck Haley, Debbie
Haley, Marion Harrris, Rick Holt, Steve Johnson, John Mashey, Bob
Mitze, Ralph Muha, Peter Nelson, Elliot Pinson, Bill Plauger, Jerry
Spivack, Ken Thompson y Peter Weinberger por sus valiosos
comentarios a traves de varias etapas; a Mike Lesk y Joe Ossanna,
por su invaluable ayuda en la impresion.
</p>

<p>
Brian W. Kernighan
 Dennis M. Ritchie
</p>
</div>
</div>
<div id="outline-container-orgd6d52f9" class="outline-2">
<h2 id="orgd6d52f9">Introduccion</h2>
<div class="outline-text-2" id="text-orgd6d52f9">
<p>
C es un lenguaje de programacion de proposito general que ha sido
estrechamente asociado con el sistema UNIX en donde fue desarrollado
puesto que tanto el sistema como los programas que corren en el
estan escritos en lenguaje C. Sin embargo, este lenguaje no esta
ligado a ningun sistema operativo ni a ninguna maquina, y aunque se
le llama "lenguaje de programacion de sistemas" debido a su utilidad
para escribir compiladores y sistemas operativos, se utiliza con
igual eficacia para escribir importantes programas en diversas
disciplinas.
</p>

<p>
Muchas de las ideas importantes de C provienen del lenguaje BCPL,
desarrollado por Martin Richards. La influencia de BCPL sobre C se
continuo indirectamente a traves del lenguaje B, el cual fue
escrito por Ken Thompson en 1970 para el primer sistema UNIX de la
DEC PDP-7.
</p>

<p>
BCPL y B son lenguajes "carentes de tipos". En contraste, C
proporciona una variedad de tipos de datos. Los tipos fundamentales
son caracteres, enteros y numeros de punto flotante de varios
tamaños. Ademas, existe una jerarquia de tipos de datos derivados,
creados con apuntadores, arreglos, estructuras y uniones. Las
expresiones se forman a partir de operadores y operandos; cualquier
expresion, incluyendo una asignacion o una llamada a funcion, puede
ser una proposicion. Los apuntadores proporcionan una aritmetica de
direcciones independiente de la maquina.
</p>

<p>
C proporciona las construcciones fundamentales de control de flujo
que se requieren en programas bien estructurados: agrupacion de
proposiciones, toma de decisiones (<code>if-else</code>), seleccion de un caso
entre un conjunto de ellos (<code>switch</code>), iteracion con la condicion de
paro en la parte superior (<code>while</code>, <code>for</code>) o en la parte inferior
(<code>do</code>), y terminacion prematura de ciclos (<code>break</code>).
</p>

<p>
Las funciones pueden regresar valores de tipos basicos, estructuras,
uniones o apuntadores. Cualquier funcion puede ser llamada
recursivamente. Las variables locales son normalmente "automaticas",
o creadas de nuevo con cada invocacion. La definicion de una funcion
no puede estar anidada, pero las variables Pueden estar declaradas
en una modalidad estructurada por bloques. Las funciones de un
programa en C pueden existir en archivos fuente separados, que se
compilan de manera separada. Las variables pueden ser internas a una
funcion, externas pero conocidas solo dentro de un archivo fuente, o
visibles al programa completo.
</p>

<p>
Un paso de preprocesamiento realiza substitucion de macros en el
texto del programa, inclusion de otros archivos fuente y compilacion
condicional.
</p>

<p>
C es un lenguaje de relativo "bajo nivel Esta caracterizacion no es
peyorativa, simplemente significa que C trata con el mismo tipo de
objetos que la mayoria de las computadoras, llamense caracteres,
numeros y direcciones. Estos pueden ser combinados y cambiados de
sitio con los operadores aritmeticos y logicos implantados por
maquinas reales.
</p>

<p>
C no proporciona operaciones para tratar directamente con objetos
compuestos, tales como cadenas de caracteres, conjuntos, listas o
arreglos. No existen operaciones que manipulen un arreglo o una
cadena completa, aunque las estructuras pueden copiarse como una
unidad. El lenguaje no define ninguna facilidad para asignacion de
almacenamiento que no sea la de definicion estatica y la disciplina
de pilas provista por las variables locales de funciones; no emplea
<i>heap</i> ni recolector de basura. Finalmente, C en si mismo no
proporciona capacidades de entrada/salida; no hay proposiciones
<code>READ</code> o <code>WRITE</code>, ni metodos propios de acceso a archivos. Todos
esos mecanismos de alto nivel deben ser proporcionados por funciones
llamadas explicitamente.
</p>

<p>
De manera semejante, C solamente ofrece un control de flujo franco,
y lineal: condiciones, ciclos, agrupamientos y subprogramas, pero no
multiprogramacion, operaciones paralelas, sincronizacion ni
corrutinas.
</p>

<p>
Aunque la ausencia de alguna de esas capacidades puede parecer como
una grave deficiencia ("¿significa que se tiene que llamar a una
funcion para comparar dos cadenas de caracteres?"), el mantener al
lenguaje de un tamaño modesto tiene beneficios reales. Puesto que C
es relativamente pequeño, se puede describir en un pequeño espacio y
aprenderse con rapidez. Un programador puede razonablemente esperar
conocer, entender y utilizar en verdad la totalidad del lenguaje.
</p>

<p>
Por muchos años, la definicion de C fue el manual de referencia de
la primera edicion de <i>El lenguaje de programacion C</i>. En 1983, el
<i>American National Standards Institute</i> (ANSI) establecio un comite
para proporcionar una moderna y comprensible definicion de C. La
definicion resultante, el estandar ANSI o "ANSI C", se esperaba
fuera aprobada a fines de 1988. La mayoria de las caracteristicas
del estandar ya se encuentran soportadas por compiladores modernos.
</p>

<p>
El estandar esta basado en el manual de referencia original. El
lenguaje ha cambiado relativamente poco; uno de los propositos del
estandar fue asegurar que la mayoria de los programas existentes
pudiesen permanecer validos o, al menos, que los compiladores
pudieran producir mensajes de advertencia acerca del nuevo
comportamiento.
</p>

<p>
Para la mayoria de los programadores, el cambio mas importante es
una nueva sintaxis para declarar y definir funciones. Una
declaracion de funcion ahora puede incluir una descripcion de los
argumentos de la funcion; la sintaxis de la definicion cambia para
coincidir. Esta informacion extra permite que los compiladores
detecten mas facilmente los errores causados por argumentos que no
coinciden; de acuerdo con nuestra experiencia, es una adicion muy
util al lenguaje.
</p>

<p>
Existen otros cambios de menor escala en el lenguaje. La asignacion
de estructuras y enumeraciones, que ha estado ampliamente
disponible, es ahora parte oficial del lenguaje. Los calculos de
punto flotante pueden ahora realizarse con precision sencilla. Las
propiedades de la aritmetica, especialmente para tipos sin signo,
estan esclarecidas. El preprocesador es mas elaborado. La mayor
parte de esos cambios solo tendran efectos secundarios para la
mayoria de los programadores.
</p>

<p>
Una segunda contribucion significativa dei estandar es la definicion
de una biblioteca que acompañe a C. Esta especifica funciones para
tener acceso al sistema operativo (por ejemplo, leer de archivos y
escribir en ellos), entrada y salida con formato, asignacion de
memoria, manipulacion de cadenas y otras actividades semejantes. Una
coleccion de encabezadores (<i>headers</i>) estandar proporcionan un
acceso uniforme a las declaraciones de funciones y tipos de
datos. Los programas que utilizan esta biblioteca para interactuar
con un sistema anfitrion estan asegurados de un comportamiento
compatible. La mayor parte de la biblioteca esta estrechamente
modelada con base en la "biblioteca E/S estandar" del sistema
UNIX. Esta biblioteca se describio en la primera edicion y ha sido
tambien ampliamente utilizada en otros sistemas. De nuevo, la
mayoria de los programadores no notaran mucho el cambio.
</p>

<p>
Debido a que los tipos de datos y estructuras de control provistas
por C son manejadas directamente por la mayoria de las computadoras,
la biblioteca de ejecucion (<i>run-time</i>) requerida para implantar
programas autocontenidos es pequeña. Las funciones de la biblioteca
estandar unicamente se llaman en forma explicita, de manera que se
pueden evitar cuando no se necesitan. La mayor parte puede
escribirse en C, y excepto por detalles ocultos del sistema
operativo, ellas mismas son portatiles.
</p>

<p>
Aunque C coincide con las capacidades de muchas computadoras, es
independiente de cualquier arquitectura. Con un poco de cuidado es
facil escribir programas portatiles, esto es, programas que puedan
correr sin cambios en una variedad de maquinas. El estandar explica
los problemas de la transportabilidad, y prescribe un conjunto de
constantes que caracterizan a la maquina en la que se ejecuta el
programa.
</p>

<p>
C no es un lenguaje fuertemente tipificado, sino que, al
evolucionar, su verificacion de tipos ha sido reforzada. La
definicion original de C desaprobo, pero permitio, el intercambio de
apuntadores y enteros; esto se ha eliminado y el estandar ahora
requiere la adecuada declaracion y la conversion explicita que ya ha
sido obligada por los buenos compiladores. La nueva declaracion de
funciones es otro paso en esta direccion. Los compiladores
advertiran de la mayoria de los errores de tipo, y no hay conversion
automatica de tipos de datos incompatibles.  Sin embargo, C mantiene
la filosofia basica de que los programadores saben lo que estan
haciendo; solo requiere que establezcan sus intenciones en forma
explicita.
</p>

<p>
Como cualquier otro lenguaje, C tiene sus defectos. Algunos de los
operadores tienen la precedencia equivocada; algunos elementos de la
sintaxis pueden ser mejores. A pesar de todo, C ha probado ser un
lenguaje extremadamente efectivo y expresivo para una amplia
variedad de programas de aplicacion.
</p>

<p>
El libro esta organizado como sigue. El <a href="#orgc16243d">capitulo 1</a> es una
introduccion orientada a la parte central de C. El proposito es
hacer que el lector se inicie tan pronto como le sea posible, puesto
que creemos firmemente que la forma de aprender un nuevo lenguaje es
escribir programas en el. La introduccion supone un conocimiento
practico de los elementos basicos de la programacion; no hay una
explicacion de computadoras, de compilacion, ni del significado de
una expresion como <code>n = n + 1</code>. Aunque hemos tratado de mostrar
tecnicas utiles de programacion en donde fue posible, la intencion
del libro no es la de ser un texto de consulta sobre estructuras de
datos y algoritmos; cuando nos vimos forzados a hacer una eleccion,
nos hemos concentrado en el lenguaje.
</p>

<p>
En los capitulos del 2 al 6 se discuten varios aspectos de C en
mayor detalle y mas formalmente de lo que se hace en el <a href="#orgc16243d">capitulo 1</a>,
aunque el enfasis esta aun en los ejemplos de programas completos,
mas que en fragmentos aislados. El <a href="#org29d5b55">capitulo 2</a> trata de los tipos
basicos de datos, operaciones y expresiones. El <a href="#org35eee87">capitulo 3</a> trata
sobre control de flujo: <code>if-else</code>, <code>switch</code>, <code>while</code>, <code>for</code>, etc. En
el <a href="#org05a38fc">capitulo 4</a> se cubren funciones y la estructura de un programa
—variables externas, reglas de alcance, archivos fuente multiples y
otros aspectos– y tambien abarca al preprocesador. El <a href="#org69d49af">capitulo 5</a>
discute sobre apuntadores y aritmetica de direcciones. El <a href="#org09ddcb4">capitulo 6</a>
cubre estructuras y uniones.
</p>

<p>
El <a href="#orgf1abb1c">capitulo 7</a> describe la biblioteca estandar, la cual proporciona
una interfaz comun con el sistema operativo. Esta biblioteca esta
definida por el estandar ANSI y se intenta que se tenga en todas las
maquinas que manejan C; asi, los programas que la usen para entrada,
salida y otros accesos al sistema operativo se puedan transportar de
un sistema a otro sin cambios.
</p>

<p>
El <a href="#orgb0747de">capitulo 8</a> describe una interfaz entre los programas en C y el
sistema operativo UNIX, concentrandose en entrada/salida, el sistema
de archivos y la asignacion de memoria. Aunque algo de este capitulo
es especifico de sistemas UNIX, los programadores que usen otros
sistemas de todas maneras encontraran aqui material de utilidad,
incluyendo alguna comprension acerca de como esta implantada una
version de la biblioteca estandar, asi como sugerencias para obtener
un codigo portatil.
</p>

<p>
El <a href="#orgea26d39">apendice A</a> contiene un manual de consulta del lenguaje. El
informe oficial de la sintaxis y la semantica de C es en si el
estandar ANSI. Ese documento, sin embargo, esta principalmente
pensado para quienes escriben compiladores. El manual de consulta de
este libro transmite la definicion del lenguaje en una forma mas
concisa y sin el mismo estilo legalista. El <a href="#org89d4232">apendice B</a> es un resumen
de la biblioteca estandar, de nuevo mas para usuarios que para
implantadores. El <a href="#org2311eb8">apendice C</a> es un breve resumen de los cambios del
lenguaje original. Aunque, en caso de duda, el estandar y el
compilador en uso quedan como las autoridades finales sobre el
lenguaje.
</p>
</div>
</div>

<div id="outline-container-orgc4990f1" class="outline-2">
<h2 id="orgc4990f1">capitulo 1: Introduccion general                                    <a id="orgc16243d"></a></h2>
<div class="outline-text-2" id="text-orgc4990f1">
<p>
Comencemos con una introduccion rapida a C. Nuestro objetivo es
mostrar los elementos esenciales del lenguaje en programas reales,
pero sin perdernos en detalles, reglas o excepciones. Por el
momento, no intentamos ser completos ni precisos (exceptuando en los
ejemplos, que si lo son). Deseamos llevarlo tan rapido como sea
posible al punto en donde pueda escribir programas utiles, y para
hacerlo tenemos que concentrarnos en las bases: variables y
constantes, aritmetica, control de flujo, funciones y los rudimentos
de entrada y salida. Hemos dejado intencionalmente fuera de este
capitulo las caracteristicas de C que son importantes para escribir
programas mas grandes. Esas caracteristicas incluyen apuntadores,
estructuras, la mayor parte del rico conjunto de operadores de C,
varias proposiciones para control de flujo y la biblioteca estandar.
</p>

<p>
Este enfoque tiene sus inconvenientes. Lo mas notorio es que aqui no
se encuentra la descripcion completa de ninguna caracteristica
particular del lenguaje, y la introduccion, por su brevedad, puede
tambien ser confusa. Y debido a que los ejemplos no utilizan la
potencia completa de C, no son tan concisos y elegantes como podrian
serlo. Hemos tratado de aminorar esos efectos, pero tenga
cuidado. Otro inconveniente es que los capitulos posteriores
necesariamente repetiran algo de lo expuesto en este. Esperamos que
la repeticion, mas que molestar, ayude.
</p>

<p>
En cualquier caso, los programadores con experiencia deben ser
capaces de extrapolar del material que se encuentra en este capitulo
a sus propias necesidades de programacion. Los principiantes deben
complementarlo escribiendo pequeños programas semejantes a los aqui
expuestos. Ambos grupos pueden utilizar este capitulo como un marco
de referencia sobre el cual asociar las descripciones mas detalladas
que comienzan en el <a href="#org29d5b55">capitulo 2</a>.
</p>
</div>

<div id="outline-container-org88d09cd" class="outline-3">
<h3 id="org88d09cd">1.1  Comencemos                                                    <a id="orgc8ff1c3"></a></h3>
<div class="outline-text-3" id="text-org88d09cd">
<p>
La unica forma de aprender un nuevo lenguaje de programacion es
escribiendo programas con el. El primer programa por escribir es el
mismo para todos los lenguajes:
</p>

<pre class="example">
Imprima las palabras
    hola, mundo
</pre>

<p>
Este es el gran obstaculo; para librarlo debe tener la habilidad de
crear el texto del programa de alguna manera, compilarlo con exito,
cargarlo, ejecutarlo y descubrir a donde fue la salida. Con el
dominio de estos detalles mecanicos, todo lo demas es relativamente
facil.
</p>

<p>
En C, el programa para escribir "hola, mundo" es:
</p>

<div class="org-src-container">
<pre class="src src-c"><span style="color: #b0c4de;">#include</span> <span style="color: #ffa07a;">&lt;stdio.h&gt;</span>

<span style="color: #87cefa;">main</span>()
{
  printf(<span style="color: #ffa07a;">"hola, mundo\n"</span>);
}
</pre>
</div>

<p>
La forma de ejecutar este programa depende del sistema que se este
utilizando. Como un ejemplo especifico, en el sistema operativo
UNIX se debe crear el programa en un archivo cuyo nombre termine
con ".c", como <code>hola.c</code>, y despues compilarlo con la orden
</p>

<div class="org-src-container">
<pre class="src src-sh">cc hola.c
</pre>
</div>

<p>
Si no se ha cometido algun error, como la omision de un caracter o
escribir algo en forma incorrecta, la compilacion se hara sin
emitir mensaje alguno, y creara un archivo ejecutable llamado
<code>a.out</code>. Si se ejecuta <code>a.out</code> escribiendo la orden
</p>

<div class="org-src-container">
<pre class="src src-sh">a.out
</pre>
</div>

<p>
se escribira
</p>

<pre class="example">
hola, mundo
</pre>

<p>
En otros sistemas, las reglas seran diferentes, consultelo con un
experto.
</p>

<p>
Ahora algunas explicaciones acerca del programa en si. Un programa
en C, cualquiera que sea su tamaño, consta de <i>funciones</i> y
<i>variables</i>. Una funcion contiene <i>proposiciones</i> que especifican
las operaciones de calculo que se van a realizar, y las variables
almacenan los valores utilizados durante los calculos. Las
funciones de C son semejantes a las subrutinas y funciones de
Fortran o a los procedimientos y funciones de Pascal. Nuestro
ejemplo es una funcion llamada <code>main</code>. Normalmente se tiene la
libertad de dar cualquier nombre que se desee, pero "main" es
especial —el programa comienza a ejecutarse al principio de
<code>main</code>. Esto significa que todo programa debe tener un <code>main</code> en
algun sitio.
</p>

<p>
Por lo comun <code>main</code> llamara a otras funciones que ayuden a realizar
su trabajo, algunas que usted ya escribio, y otras de bibliotecas
escritas previamente. La primera linea del programa.
</p>

<div class="org-src-container">
<pre class="src src-c"><span style="color: #b0c4de;">#include</span> <span style="color: #ffa07a;">&lt;stdio.h&gt;</span>
</pre>
</div>

<p>
indica al compilador que debe incluir informacion acerca de la
biblioteca estandar de entrada/salida; esta linea aparece al
principio de muchos archivos fuente de C. La biblioteca estandar
esta descrita en el <a href="#orgf1abb1c">capitulo 7</a> y en el <a href="#org89d4232">apendice B</a>.
</p>

<p>
Un metodo para comunicar datos entre las funciones es que la
funcion que llama proporciona una lista de valores, llamados
argumentos, a la funcion que esta invocando. Los parentesis que
estan despues del nombre de la funcion encierran a la lista de
argumentos. En este ejemplo, <code>main</code> esta definido para ser una
funcion que no espera argumentos, lo cual esta indicado por la
lista vacia <code>()</code>.
</p>

<dl class="org-dl">
<dt>El primer programa en C</dt><dd><div class="org-src-container">
<pre class="src src-c"><span style="color: #b0c4de;">#include</span> <span style="color: #ffa07a;">&lt;stdio.h&gt;</span>             <span style="color: #ff4500;">/* </span><span style="color: #ff4500;">incluye informacion acerca de la biblioteca estandar </span><span style="color: #ff4500;">*/</span>

<span style="color: #87cefa;">main</span>()                         <span style="color: #ff4500;">/*  </span><span style="color: #ff4500;">define una funcion llamada main</span>
<span style="color: #ff4500;">                                   que no recibe valores de argumentos </span><span style="color: #ff4500;">*/</span>
{                              <span style="color: #ff4500;">/* </span><span style="color: #ff4500;">las proposiciones de main estan encerradas entre llaves </span><span style="color: #ff4500;">*/</span>
  printf (<span style="color: #ffa07a;">"hola, mundo\n"</span>);    <span style="color: #ff4500;">/* </span><span style="color: #ff4500;">main llama a la funcion printf de biblioteca estandar</span>
<span style="color: #ff4500;">                                  para escribir esta secuencia de caracteres;</span>
<span style="color: #ff4500;">                                  \n representa el caracter nueva linea </span><span style="color: #ff4500;">*/</span>
}
</pre>
</div></dd>
</dl>


<p>
Las proposiciones de una funcion estan encerradas entre llaves <code>{
   }</code>. La funcion <code>main</code> solo contiene una proposicion,
</p>

<div class="org-src-container">
<pre class="src src-c">printf (<span style="color: #ffa07a;">"hola, mundo\n"</span>);
</pre>
</div>

<p>
Una funcion se invoca al nombrarla, seguida de una lista de
argumentos entre parentesis; de esta manera se esta llamando a la
funcion <a href="#org0458a76"><code>printf</code></a> con el argumento "hola, mundo\n". <a href="#org0458a76"><code>printf</code></a> es una
funcion de biblioteca que escribe la salida, en este caso la cadena
de caracteres que se encuentra entre comillas.
</p>

<p>
A una secuencia de caracteres entre comillas, como "hola, mundo\n",
se le llama <i>cadena de caracteres</i> o <i>constante de cadena</i>. Por el
momento, nuestro unico uso de cadenas de caracteres sera como
argumentos para <a href="#org0458a76"><code>printf</code></a> y otras funciones.
</p>

<p>
La secuencia <code>\n</code> en la cadena representa el caracter nueva linea
en la notacior de C, y hace avanzar la impresion al margen
izquierdo de la siguiente linea. Si se omite el <code>\n</code> (un
experimento que vale la pena), encontrara que no hay avance de
linea despues de la impresion. Se debe utilizar <code>\n</code> para incluir
un caracter nueva linea en el argumento de <a href="#org0458a76"><code>printf</code></a>; si se intenta
algo como:
</p>

<div class="org-src-container">
<pre class="src src-c">printf (<span style="color: #ffc0cb; font-weight: bold;">"</span><span style="color: #ffa07a;">hola, mundo</span>
<span style="color: #ffa07a;">"</span>);
</pre>
</div>

<p>
el compilador de C producira un mensaje de error.
</p>

<p>
<a href="#org0458a76"><code>printf</code></a> nunca proporciona una nueva linea automaticamente, de
manera que se pueden utilizar varias llamadas para construir una
linea de salida en etapas. Nuestro primer programa tambien pudo
haber sido escrito de la siguiente manera.
</p>

<div class="org-src-container">
<pre class="src src-c"><span style="color: #b0c4de;">#include</span> <span style="color: #ffa07a;">&lt;stdio.h&gt;</span>

<span style="color: #87cefa;">main</span>()
{
  printf(<span style="color: #ffa07a;">"hola,"</span>);
  printf (<span style="color: #ffa07a;">"mundo"</span>);
  printf(<span style="color: #ffa07a;">"\n"</span>);
}
</pre>
</div>

<p>
produciendose una salida identica.
</p>

<p>
Notese que <code>\n</code> representa un solo caracter. Una secuencia de
escape como <code>\n</code> proporciona un mecanismo general y extensible para
representar caracteres invisibles o dificiles de escribir. Entre
otros que C proporciona estan <code>\t</code> para tabulacion, <code>\b</code> para
retroceso, <code>\"</code> para comillas, y <code>\\</code> para la diagonal
invertida. Hay una lista completa en la <a href="#orgc43a3e4">seccion 2.3</a>.
</p>

<p>
<b>Ejercicio 1-1</b>. Ejecute el programa "hola, mundo" en su
sistema. Experimente con la omision de partes del programa, para
ver que mensajes de error se obtienen.
</p>

<p>
<b>Ejercicio 1-2</b>. Experimente el descubrir que pasa cuando la cadena
del argumento de <a href="#org0458a76"><code>printf</code></a> contiene <code>\c</code>, en donde <code>c</code> es algun
caracter no puesto en lista anteriormente.
</p>
</div>
</div>

<div id="outline-container-orgfe64a15" class="outline-3">
<h3 id="orgfe64a15">1.2  Variables y expresiones aritmeticas                           <a id="org8192a63"></a></h3>
<div class="outline-text-3" id="text-orgfe64a15">
<p>
El siguiente programa utiliza la formula <code>°C = (5/9) (°F-32)</code> para
imprimir la siguiente tabla de temperaturas Fahrenheit y sus
equivalentes centigrados o Celsius:
</p>

<pre class="example">
0       -17
20      -6
40      4
60      15
80      26
100     37
120     48
140     60
160     71
180     82
200     93
220     104
240     115
260     126
280     137
300     148
</pre>

<p>
En si el programa aun consiste de la definicion de una unica
funcion llamada <code>main</code>. Es mas largo que el que imprime "hola,
mundo", pero no es complicado.  Introduce varias ideas nuevas,
incluyendo comentarios, declaraciones, variables, expresiones
aritmeticas, ciclos y salida con formato.
</p>

<div class="org-src-container">
<pre class="src src-c"><span style="color: #b0c4de;">#include</span> <span style="color: #ffa07a;">&lt;stdio.h&gt;</span>
<span style="color: #ff4500;">/* </span><span style="color: #ff4500;">imprime la tabla Fahrenheit-Celsius</span>
<span style="color: #ff4500;">   para fahr = 0, 20, ..., 300 </span><span style="color: #ff4500;">*/</span>

<span style="color: #87cefa;">main</span> ()
{
  <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">fahr</span>, <span style="color: #eedd82;">celsius</span>;
  <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">lower</span>, <span style="color: #eedd82;">upper</span>, <span style="color: #eedd82;">step</span>;

  lower = 0;              <span style="color: #ff4500;">/* </span><span style="color: #ff4500;">limite inferior de la tabla de temperaturas </span><span style="color: #ff4500;">*/</span>
  upper = 300;            <span style="color: #ff4500;">/* </span><span style="color: #ff4500;">limite superior                             </span><span style="color: #ff4500;">*/</span>
  step = 20;              <span style="color: #ff4500;">/* </span><span style="color: #ff4500;">tama&#241;o del incremento                       </span><span style="color: #ff4500;">*/</span>
  fahr = lower;

  <span style="color: #00ffff;">while</span> (fahr &lt;= upper) {
    celsius = 5 * (fahr - 32) / 9;
    printf(<span style="color: #ffa07a;">"%d\t%d\n"</span>, fahr, celsius);
    fahr = fahr + step;
  }
}
</pre>
</div>

<p>
Las dos lineas
</p>

<div class="org-src-container">
<pre class="src src-c"><span style="color: #ff4500;">/* </span><span style="color: #ff4500;">imprime la tabla Fahrenheit-Celsius</span>
<span style="color: #ff4500;">   para fahr = 0, 20, ..., 300 </span><span style="color: #ff4500;">*/</span>
</pre>
</div>

<p>
son un <i>comentario</i>, que en este caso explica brevemente lo que
hace el programa. Cualesquier caracteres entre <code>/*</code> y <code>*/</code> son
ignorados por el compilador, y pueden ser utilizados libremente
para hacer a un programa mas facil de entender. Los comentarios
pueden aparecer en cualquier lugar donde puede colocarse un espacio
en blanco, un tabulador o nueva linea.
</p>

<p>
En C, se deben declarar todas las variables antes de su uso,
generalmente al principio de la funcion y antes de cualquier
proposicion ejecutable. Una <i>declaracion</i> notifica las propiedades
de una variable; consta de un nombre de tipo y una lista de
variables, como:
</p>

<div class="org-src-container">
<pre class="src src-c"><span style="color: #98fb98;">int</span> <span style="color: #eedd82;">fahr</span>, <span style="color: #eedd82;">celsius</span>;
<span style="color: #98fb98;">int</span> <span style="color: #eedd82;">lower</span>, <span style="color: #eedd82;">upper</span>, <span style="color: #eedd82;">step</span>;
</pre>
</div>

<p>
El tipo <code>int</code> significa que las variables de la lista son enteros,
en contraste con <code>float</code>, que significa punto flotante, esto es,
numeros que pueden tener una parte fraccionaria. El rango tanto de
<code>int</code> como de <code>float</code> depende de la maquina que se esta utilizando;
los <code>int</code> de 16 bits, que estan comprendidos entre el <code>-32768</code> y
<code>+32767</code>, son comunes, como lo son los <code>int</code> de 32 bits. Un numero
<code>float</code> tipicamente es de 32 bits, por lo menos con seis digitos
significativos y una magnitud generalmente entre 10<sup>-38</sup> y 10<sup>+38</sup>.
</p>

<p>
Ademas de <code>int</code> y <code>float</code>, C proporciona varios tipos de datos
basicos, incluyendo:
</p>

<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-left" />

<col  class="org-left" />
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">Tipo</th>
<th scope="col" class="org-left">Descripcion</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left"><code>char</code></td>
<td class="org-left">caracter — un solo byte</td>
</tr>
</tbody>
<tbody>
<tr>
<td class="org-left"><code>short</code></td>
<td class="org-left">entero corto</td>
</tr>
</tbody>
<tbody>
<tr>
<td class="org-left"><code>long</code></td>
<td class="org-left">entero largo</td>
</tr>
</tbody>
<tbody>
<tr>
<td class="org-left"><code>double</code></td>
<td class="org-left">punto flotante de doble precision</td>
</tr>
</tbody>
</table>

<p>
Los tamaños de estos objetos tambien dependen de la maquina.
Tambien existen <i>arreglos</i>, <i>estructuras</i> y <i>uniones</i> de estos
tipos basicos, apuntadores a ellos y funciones que regresan valores
con esos tipos, todo lo cual se vera en el momento oportuno.
</p>

<p>
Los calculos en el programa de conversion de temperaturas
principian con las <i>proposiciones de asignacion</i>.
</p>

<div class="org-src-container">
<pre class="src src-c">lower = 0;
upper = 300;
step = 20;
fahr = lower;
</pre>
</div>

<p>
que asignan a las variables sus valores iniciales. Las
proposiciones individuales se terminan con punto y coma.
</p>

<p>
Cada linea de la tabla se calcula de la misma manera por lo que se
utiliza una iteracion que se repite una vez por cada linea de
salida; este es el proposito del ciclo <code>while</code>
</p>

<div class="org-src-container">
<pre class="src src-c"><span style="color: #00ffff;">while</span> (fahr &lt;= upper) {

}
</pre>
</div>

<p>
El ciclo <code>while</code> funciona de la siguiente manera: se prueba la
condicion entre parentesis. De ser verdadera (<code>fahr</code> es menor o
igual que <code>upper</code>), el cuerpo del ciclo (las tres proposiciones
entre llaves) se ejecuta. Luego la condicion se prueba nuevamente,
y si es verdadera, el cuerpo se ejecuta de nuevo. Cuando la prueba
resulta falsa (<code>fahr</code> excede a <code>upper</code>) la iteracion termina, y la
ejecucion continua en la proposicion que sigue al ciclo. No existe
ninguna otra proposicion en este programa, de modo que termina.
</p>

<p>
El cuerpo de un <code>while</code> puede tener una o mas proposiciones
encerradas entre llaves, como en el convertidor de temperaturas, o
una sola proposicion sin llaves, como en:
</p>

<div class="org-src-container">
<pre class="src src-c"><span style="color: #00ffff;">while</span> (i &lt; j)
  i = 2 * i;
</pre>
</div>

<p>
En cualquier caso, siempre se sangra la proposicion controlada por
el <code>while</code> con una tabulacion (lo que se ha mostrado con dos
espacios) para poder apreciar de un vistazo cuales proposiciones
estan dentro del ciclo. El sangrado acentua la estructura logica
del programa. Aunque a los compiladores de C no les importa la
apariencia del programa, un sangrado y espaciamiento adecuados son
muy importantes para hacer programas faciles de leer. Se recomienda
escribir una sola proposicion por linea y utilizar espacios en
blanco alrededor de los operadores para dar claridad al
agrupamiento. La posicion de las llaves es menos importante, aunque
la gente mantiene creencias apasionadas. Se eligio uno de los
varios estilos populares. Seleccione un estilo que le satisfaga y
uselo en forma consistente.
</p>

<p>
La mayor parte del trabajo se realiza en el cuerpo del ciclo. La
temperatura Celsius se calcula y se asigna a la variable celsius
por la proposicion.
</p>

<div class="org-src-container">
<pre class="src src-c">celsius = 5 * (fahr - 32) / 9;
</pre>
</div>

<p>
La razon de multiplicar por 5 y despues dividir entre 9 en lugar de
solamente multiplicar por 5/9 es que en C, como en muchos otros
lenguajes, la division de enteros trunca el resultado: cualquier
parte fraccionaria se descarta. Puesto que 5 y 9 son enteros, 5/9
seria truncado a cero y asi todas las temperaturas Celsius se
reportarian como cero.
</p>

<p>
Este ejemplo tambien muestra un poco mas acerca de como funciona
<a href="#org0458a76"><code>printf</code></a>.  En realidad, <a href="#org0458a76"><code>printf</code></a> es una funcion de proposito
general para dar formato de salida, que se describira con detalle
en el <a href="#orgf1abb1c">capitulo 7</a>. Su primer argumento es una cadena de caracteres
que seran impresos, con cada <code>%</code> indicando en donde uno de los
otros (segundo, tercero, &#x2026;) argumentos va a ser sustituido, y en
que forma sera impreso. Por ejemplo, <code>%d</code> especifica un argumento
entero, de modo que la proposicion
</p>

<div class="org-src-container">
<pre class="src src-c">printf(<span style="color: #ffa07a;">"%d\t%d\n"</span>, fahr, celsius);
</pre>
</div>

<p>
hace que los valores de los dos enteros <code>fahr</code> y <code>celsius</code> sean
escritos, con una tabulacion (<code>\t</code>) entre ellos.
</p>

<p>
Cada construccion <code>%</code> en el primer argumento de <a href="#org0458a76"><code>printf</code></a> esta
asociada con el correspondiente segundo argumento, tercero, etc., y
deben corresponder apropiadamente en numero y tipo, o se tendran
soluciones incorrectas.
</p>

<p>
Con relacion a esto, <a href="#org0458a76"><code>printf</code></a> no es parte del lenguaje C; no existe
propiamente una entrada o salida definida en C. <a href="#org0458a76"><code>printf</code></a> es solo
una util funcion de la biblioteca estandar de funciones que esta
accesible normalmente a los programas en C. Sin embargo, el
comportamiento de <a href="#org0458a76"><code>printf</code></a> esta definido en el estandar ANSI, por
lo que sus propiedades deben ser las mismas en cualquier compilador
o biblioteca que se apegue a el.
</p>

<p>
Para concentrarnos en C, no hablaremos mucho acerca de la entrada y
la salida hasta el <a href="#orgf1abb1c">capitulo 7</a>. En particular, pospondremos el tema
de la entrada con formato hasta entonces. Si se tiene que darle
entrada a numeros, lease la discusion de la funcion <a href="#orgb47aa6e"><code>scanf</code></a> en la
<a href="#org58236a0">seccion 7.4</a>. La funcion <a href="#orgb47aa6e"><code>scanf</code></a> es como <a href="#org0458a76"><code>printf</code></a>, exceptuando que
lee de la entrada en lugar de escribir a la salida.
</p>

<p>
Existen un par de problemas con el programa de conversion de
temperaturas. El mas simple es que la salida no es muy estetica
debido a que los numeros no estan justificados hacia su
derecha. Esto es facil de corregir; si aumentamos a cada <code>%d</code> de la
proposicion <a href="#org0458a76"><code>printf</code></a> una amplitud, los numeros impresos seran
justificados hacia su derecha dentro de sus campos. Por ejemplo,
podria decirse:
</p>

<div class="org-src-container">
<pre class="src src-c">printf(<span style="color: #ffa07a;">"%3d %6d\n"</span>, fahr, celsius);
</pre>
</div>

<p>
para escribir el primer numero de cada linea en un campo de tres
digitos de ancho, y el segundo en un campo de seis digitos, como
esto:
</p>

<pre class="example">
  0    -17
 20     -6
 40      4
 60     15
 80     26
100     37
...
</pre>

<p>
El problema mas grave es que debido a que se ha utilizado
aritmetica de enteros, las temperaturas Celsius no son muy
precisas; por ejemplo, 0°F es en realidad aproximadamente —17.8°C,
no —17. Para obtener soluciones mas precisas, se debe utilizar
aritmetica de punto flotante en lugar de entera. Esto requiere de
algunos cambios en el programa. Aqui esta una segunda version:
</p>

<div class="org-src-container">
<pre class="src src-c"><span style="color: #b0c4de;"># include</span> <span style="color: #ffa07a;">&lt;stdio.h&gt;</span>

<span style="color: #ff4500;">/* </span><span style="color: #ff4500;">imprime la tabla Fahrenheit-Celsius</span>
<span style="color: #ff4500;">   para fahr = 0, 20, ..., 300; version de punto flotante </span><span style="color: #ff4500;">*/</span>

<span style="color: #87cefa;">main</span> ()
{
  <span style="color: #98fb98;">float</span> <span style="color: #eedd82;">fahr</span>, <span style="color: #eedd82;">celsius</span>;
  <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">lower</span>, <span style="color: #eedd82;">upper</span>, <span style="color: #eedd82;">step</span>;

  lower = 0;              <span style="color: #ff4500;">/* </span><span style="color: #ff4500;">limite inferior de la tabla de temperaturas </span><span style="color: #ff4500;">*/</span>
  upper = 300;            <span style="color: #ff4500;">/* </span><span style="color: #ff4500;">limite superior                             </span><span style="color: #ff4500;">*/</span>
  step = 20;              <span style="color: #ff4500;">/* </span><span style="color: #ff4500;">tama&#241;o del incremento                       </span><span style="color: #ff4500;">*/</span>
  fahr = lower;

  <span style="color: #00ffff;">while</span> (fahr &lt;= upper) {
    celsius = (5.0/9.0) * (fahr-32.0);
    printf(<span style="color: #ffa07a;">"%3.0f %6.1f\n"</span>, fahr, celsius);
    fahr = fahr + step;
  }
}
</pre>
</div>

<p>
Esto es muy semejante a lo anterior, excepto que <code>fahr</code> y <code>celsius</code>
estan declarados como <code>float</code>, y la formula de conversion esta
escrita en una forma mas natural.  No pudimos utilizar 5/9 en la
version anterior debido a que la division entera lo truncaria a
cero. Sin embargo, un punto decimal en una constante indica que
esta es de punto flotante, por lo que 5.0/9.0 no se trunca debido a
que es una relacion de dos valores de punto flotante.
</p>

<p>
Si un operador aritmetico tiene operandos enteros, se ejecuta una
operacion entera. Si un operador numerico tiene un operando de
punto flotante y otro entero, este uliimo sera convertido a punto
flotante antes de hacer la operacion. Si se hubiera escrito <code>fahr -
   32</code>, el 32 seria convertido automaticamente a punto
flotante. Escribir constantes de punto flotante con puntos
decimales explicitos, aun cuando tengan valores enteros, destaca su
naturaleza de punto flotante para los lectores humanos.
</p>

<p>
Las reglas detalladas de cuando los enteros se convierten a punto
flotante se encuentran en el <a href="#org29d5b55">capitulo 2</a>. Por ahora, notese que la
asignacion
</p>

<div class="org-src-container">
<pre class="src src-c">fahr = lower;
</pre>
</div>

<p>
y la prueba
</p>

<div class="org-src-container">
<pre class="src src-c"><span style="color: #00ffff;">while</span> (fahr &lt;= upper)
</pre>
</div>

<p>
tambien trabajan en la forma natural —el <code>int</code> se convierte a
<code>float</code> antes de efectuarse la operacion.
</p>

<p>
La especificacion de conversion <code>%3.0f</code> del <a href="#org0458a76"><code>printf</code></a> indica que se
escribira un numero de punto flotante (en este caso <code>fahr</code>) por lo
menos con tres caracteres de ancho, sin punto decimal y sin digitos
fraccionarios; <code>%6.1f</code> describe a otro numero (celsius) que se
escribira en una amplitud de por lo menos 6 caracteres, con 1
digito despues del punto decimal. La salida se vera como sigue:
</p>

<pre class="example">
 0  -17.8
20   -6.7
40    4.4
...
</pre>

<p>
La amplitud y la precision pueden omitirse de una especificacion:
<code>%6f</code> indica que el numero es por lo menos de seis caracteres de
ancho; <code>%.2f</code> indica dos caracteres despues del punto decimal, pero
el ancho no esta restringido; y <code>%f</code> unicamente indica escribir el
numero como punto flotante.
</p>

<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-left" />

<col  class="org-left" />
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">Especificacion</th>
<th scope="col" class="org-left">Descripcion</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left"><code>%d</code></td>
<td class="org-left">escribe como entero decimal</td>
</tr>
</tbody>
<tbody>
<tr>
<td class="org-left"><code>%6d</code></td>
<td class="org-left">escribe como entero decimal, por lo menos con 6 caracteres de amplitud</td>
</tr>
</tbody>
<tbody>
<tr>
<td class="org-left"><code>%f</code></td>
<td class="org-left">escribe como punto flotante</td>
</tr>
</tbody>
<tbody>
<tr>
<td class="org-left"><code>%6f</code></td>
<td class="org-left">escribe como punto flotante, por lo menos con 6 caracteres de amplitud</td>
</tr>
</tbody>
<tbody>
<tr>
<td class="org-left"><code>%.2f</code></td>
<td class="org-left">escribe como punto flotante, con 2 caracteres despues del punto decimal</td>
</tr>
</tbody>
<tbody>
<tr>
<td class="org-left"><code>%6.2gf</code></td>
<td class="org-left">escribe como punto flotante, por lo menos con 6 caracteres de ancho y 2 despues del punto decimal</td>
</tr>
</tbody>
</table>

<p>
Entre otros, <a href="#org0458a76"><code>printf</code></a> tambien reconoce <code>%o</code> para octal, <code>%x</code> para
hexadecimal, <code>%c</code> para caracter, <code>%s</code> para cadena de caracteres y
<code>%%</code> para % en si.
</p>

<p>
<b>Ejercicio 1-3</b>. Modifique el programa de conversion de
temperaturas de modo que escriba un encabezado sobre la tabla.
</p>

<p>
<b>Ejercicio 1-4</b>. Escriba un programa que imprima la tabla
correspondiente Celsius a Fahrenheit.
</p>
</div>
</div>

<div id="outline-container-org0756296" class="outline-3">
<h3 id="org0756296">1.3  La proposicion for                                            <a id="org98f1590"></a></h3>
<div class="outline-text-3" id="text-org0756296">
<p>
Existen suficientes formas distintas de escribir un programa para
una tarea en particular. Intentemos una variacion del programa de
conversion de temperaturas.
</p>

<div class="org-src-container">
<pre class="src src-c"><span style="color: #b0c4de;">#include</span> <span style="color: #ffa07a;">&lt;stdio.h&gt;</span>

<span style="color: #ff4500;">/* </span><span style="color: #ff4500;">imprime la tabla Fahrenheit-Celsius </span><span style="color: #ff4500;">*/</span>
<span style="color: #87cefa;">main</span>()
{
  <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">fahr</span>;

  <span style="color: #00ffff;">for</span> (fahr = 0; fahr &lt;= 300; fahr = fahr + 20)
    printf(<span style="color: #ffa07a;">"%3d %6.1f\n"</span>, fahr, (5.0/9.0)*(fahr-32));
}
</pre>
</div>

<p>
Este produce los mismos resultados, pero ciertamente se ve
diferente. Un cambio importante es la eliminacion de la mayoria de
las variables; solo permanece <code>fahr</code> y la hemos hecho <code>int</code>. Los
limites inferior y superior y el tamaño del avance solo aparecen
como constantes dentro de la proposicion <code>for</code>, que es una nueva
construccion, y la expresion que calcula la temperatura Celsius
ahora aparece como el tercer argumento de <a href="#org0458a76"><code>printf</code></a> en vez de una
proposicion de asignacion separada.
</p>

<p>
Este ultimo cambio ejemplifica una regla general —en cualquier
contexto en el que se permita utilizar el valor de una variable de
algun tipo, es posible usar una expresion mas complicada de ese
tipo. Puesto que el tercer argumento de <a href="#org0458a76"><code>printf</code></a> debe ser un valor
de punto flotante para coincidir con <code>%6.1f</code>, cualquier expresion
de punto flotante puede estar alli.
</p>

<p>
La proposicion <code>for</code> es un ciclo, una forma generalizada del
<code>while</code>. Si se compara con el <code>while</code> anterior, su operacion debe
ser clara. Dentro de los parentesis existen tres secciones,
separadas por punto y coma. La primera, la inicializacion
</p>

<div class="org-src-container">
<pre class="src src-c">fahr = 0
</pre>
</div>

<p>
se ejecuta una vez, antes de entrar propiamente al ciclo. La
segunda seccion es la condicion o prueba que controla el ciclo:
</p>

<div class="org-src-container">
<pre class="src src-c">fahr &lt;= 300
</pre>
</div>

<p>
Esta condicion se evalua; si es verdadera, el cuerpo del ciclo (en
este caso un simple <a href="#org0458a76"><code>printf</code></a>) se ejecuta. Despues el incremento de
avance
</p>

<div class="org-src-container">
<pre class="src src-c">fahr = fahr + 20
</pre>
</div>

<p>
se ejecuta y la condicion se vuelve a evaluar. El ciclo termina si
la condicion se hace falsa. Tal como con el <code>while</code>, el cuerpo del
ciclo puede ser una proposicion sencilla o un grupo de
proposiciones encerradas entre llaves. La inicializacion, la
condicion y el incremento pueden ser cualquier expresion.
</p>

<p>
La seleccion entre <code>while</code> y <code>for</code> es arbitraria, y se basa en
aquello que parezca mas claro. El <code>for</code> es por lo general apropiado
para ciclos en los que la inicializacion y el incremento son
proposiciones sencillas y logicamente relacionadas, puesto que es
mas compacto que el <code>while</code> y mantiene reunidas en un lugar a las
proposiciones que controlan al ciclo.
</p>

<p>
<b>Ejercicio 1-5</b>. Modifique el programa de conversion de
temperaturas de manera que escriba la tabla en orden inverso, esto
es, desde 300 grados hasta 0.
</p>
</div>
</div>

<div id="outline-container-org6a40344" class="outline-3">
<h3 id="org6a40344">1.4  Constantes simbolicas                                         <a id="org172b050"></a></h3>
<div class="outline-text-3" id="text-org6a40344">
<p>
Una observacion final antes de dejar definitivamente el tema de la
conversion de temperaturas. Es una mala practica poner "numeros
magicos" como 300 y 20 en un programa, ya que proporcionan muy poca
informacion a quien tenga que leer el programa, y son dificiles de
modificar en un forma sistematica. Una manera de tratar a esos
numeros magicos es darles nombres significativos. Una linea
<code>#define</code> define un nombre simbolico o constante simbolica como una
cadena de caracteres especial:
</p>

<div class="org-src-container">
<pre class="src src-c"><span style="color: #b0c4de;">#define</span> <span style="color: #eedd82;">nombre</span> texto de reemplazo
</pre>
</div>

<p>
A partir de esto, cualquier ocurrencia de <i>nombre</i> (que no este
entre comillas ni como parte de otro nombre) se sustituira por el
<i>texto de reemplazo</i> correspondiente. El <i>nombre</i> tiene la misma
forma que un nombre de variable: una secuencia de letras y digitos
que comienza con una letra. El <i>texto de reemplazo</i> puede ser
cualquier secuencia de caracteres; no esta limitado a numeros.
</p>

<div class="org-src-container">
<pre class="src src-c"><span style="color: #b0c4de;">#include</span> <span style="color: #ffa07a;">&lt;stdio.h&gt;</span>

<span style="color: #b0c4de;">#define</span> <span style="color: #eedd82;">LOWER</span>           0           <span style="color: #ff4500;">/* </span><span style="color: #ff4500;">limite inferior de la tabla </span><span style="color: #ff4500;">*/</span>
<span style="color: #b0c4de;">#define</span> <span style="color: #eedd82;">UPPER</span>           300         <span style="color: #ff4500;">/* </span><span style="color: #ff4500;">limite superior </span><span style="color: #ff4500;">*/</span>
<span style="color: #b0c4de;">#define</span> <span style="color: #eedd82;">STEP</span>            20          <span style="color: #ff4500;">/* </span><span style="color: #ff4500;">tama&#241;o del incremento </span><span style="color: #ff4500;">*/</span>

<span style="color: #ff4500;">/* </span><span style="color: #ff4500;">imprime la tabla Fahrenheit-Celsius </span><span style="color: #ff4500;">*/</span>
<span style="color: #87cefa;">main</span>()
{
  <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">fahr</span>;

  <span style="color: #00ffff;">for</span> (fahr = LOWER; fahr &lt;= UPPER; fahr = fahr + STEP)
    printf(<span style="color: #ffa07a;">"%3d %6.1f\n"</span>, fahr, (5.0/9.0) * (fahr-32));
}

</pre>
</div>

<p>
Las cantidades <code>LOWER</code>, <code>UPPER</code> y <code>STEP</code> son constantes simbolicas,
no variables, por lo que no aparecen entre las declaraciones. Los
nombres de constantes simbolicas, por convencion, se escriben con
letras mayusculas, de modo que se puedan distinguir facilmente de
los nombres de variables escritos con minusculas. Notese que no hay
punto y coma al final de una linea <code>#define</code>.
</p>
</div>
</div>

<div id="outline-container-orgbea7c3b" class="outline-3">
<h3 id="orgbea7c3b">1.5  Entrada y salida de caracteres                                <a id="org8529139"></a></h3>
<div class="outline-text-3" id="text-orgbea7c3b">
<p>
Ahora vamos a considerar una familia de programas relacionados para
el procesamiento de datos de tipo caracter. Se encontrara que
muchos programas solo son versiones ampliadas de los prototipos que
se tratan aqui.
</p>

<p>
El modelo de entrada y salida manejado por la biblioteca estandar
es muy simple. La entrada y salida de texto, sin importar donde fue
originada o hacia donde se dirige, se tratan como flujos
(<i>streams</i>) de caracteres. Un <i>flujo</i> de texto es una secuencia de
caracteres divididos entre lineas, cada una de las cuales consta de
cero o mas caracteres seguidos de un caracter nueva linea. La
biblioteca es responsable de hacer que cada secuencia de entrada o
salida este de acuerdo con este modelo; el programador de C que
utiliza la biblioteca no necesita preocuparse de como estan
representadas las lineas fuera del programa.
</p>

<p>
La biblioteca estandar proporciona varias funciones para leer o
escribir un caracter a la vez, de las cuales <a href="#org4d38061"><code>getchar</code></a> y <a href="#orgc7f0a8a"><code>putchar</code></a>
son las mas simples. Cada vez que se invoca, <a href="#org4d38061"><code>getchar</code></a> lee el
siguiente caracter de entrada de una secuencia de texto y lo
devuelve como su valor. Esto es, despues de
</p>

<div class="org-src-container">
<pre class="src src-c">c = getchar()
</pre>
</div>

<p>
la variable <code>c</code> contiene el siguiente caracter de entrada. Los
caracteres provienen normalmente del teclado; la entrada de
archivos se trata en el <a href="#orgf1abb1c">capitulo 7</a>.
</p>

<p>
La funcion <a href="#orgc7f0a8a"><code>putchar</code></a> escribe un caracter cada vez que se invoca:
</p>

<div class="org-src-container">
<pre class="src src-c"><span style="color: #87cefa;">putchar</span>(c)
</pre>
</div>

<p>
escribe el contenido de la variable entera <code>c</code> como un caracter,
generalmente en la pantalla. Las llamadas a <a href="#orgc7f0a8a"><code>putchar</code></a> y a <a href="#org0458a76"><code>printf</code></a>
pueden estar alternadas; la salida aparecera en el orden en que se
realicen las llamadas.
</p>
</div>

<div id="outline-container-org2e38daa" class="outline-4">
<h4 id="org2e38daa">1.5.1 Copia de archivos                                           <a id="org5c2f420"></a></h4>
<div class="outline-text-4" id="text-org2e38daa">
<p>
Con <a href="#org4d38061"><code>getchar</code></a> y <a href="#orgc7f0a8a"><code>putchar</code></a> se puede escribir una cantidad
sorprendente de codigo util sin saber nada mas acerca de entrada y
salida. El ejemplo mas sencillo es un programa que copia la
entrada en la salida, un caracter a la vez:
</p>

<pre class="example">
lee un caracter
while (caracter no es indicador de fin de archivo)
     manda a la salida el caracter recien leido
     lee un caracter
</pre>

<p>
Al convertir esto en C se obtiene
</p>

<div class="org-src-container">
<pre class="src src-c"><span style="color: #b0c4de;">#include</span> <span style="color: #ffa07a;">&lt;stdio.h&gt;</span>

<span style="color: #ff4500;">/* </span><span style="color: #ff4500;">copia la entrada a la salida; 1a. version </span><span style="color: #ff4500;">*/</span>
<span style="color: #87cefa;">main</span>()
{
  <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">c</span>;

  c = getchar();
  <span style="color: #00ffff;">while</span> (c != EOF) {
    putchar(c);
    c = getchar();
  }
}
</pre>
</div>

<p>
El operador de relacion <code>!=</code> significa "no igual a".
</p>

<p>
Lo que aparece como un caracter en el teclado o en la pantalla es,
por supuesto, como cualquier otra cosa, almacenado internamente
como un patron de bits. El tipo <code>char</code> tiene la funcion especifica
de almacenar ese tipo de dato, pero tambien puede ser usado
cualquier tipo de entero. Usamos <code>int</code> por una sutil pero
importante razon.
</p>

<p>
El problema es distinguir el fin de la entrada de los datos
validos. La solucion es que <a href="#org4d38061"><code>getchar</code></a> devuelve un valor distintivo
cuando no hay mas a la entrada, un valor que no puede ser
confundido con ningun otro caracter. Este valor se llama <code>EOF</code>,
por <i>end of file</i> (fin de archivo). Se debe declarar <code>c</code> con un
tipo que sea lo suficientemente grande para almacenar cualquier
valor que le regrese <a href="#org4d38061"><code>getchar</code></a>. No se puede utilizar <code>char</code> puesto
que <code>c</code> debe ser suficientemente grande como para mantener a <code>EOF</code>
ademas de cualquier otro caracter. Por lo tanto, se emplea <code>int</code>.
</p>

<p>
<code>EOF</code> es un entero definido en <code>&lt;stdio.h&gt;</code>, pero el valor numerico
especifico no importa mientras que no sea el mismo que ningun
valor tipo <code>char</code>. Utilizando la constante simbolica, hemos
asegurado que nada en el programa depende del valor numerico
especifico.
</p>

<p>
El programa para copiar podria escribirse de modo mas conciso por
programadores experimentados de C. En lenguaje C, cualquier
asignacion, tal como:
</p>

<div class="org-src-container">
<pre class="src src-c">c = getchar()
</pre>
</div>

<p>
es una expresion y tiene un valor, el del lado izquierdo luego de
la asignacion. Esto significa que una asignacion puede aparecer
como parte de una expresion mas larga. Si la asignacion de un
caracter a <code>c</code> se coloca dentro de la seccion de prueba de un
ciclo <code>while</code>, el programa que copia puede escribirse de la
siguiente manera:
</p>

<div class="org-src-container">
<pre class="src src-c"><span style="color: #b0c4de;">#include</span> <span style="color: #ffa07a;">&lt;stdio.h&gt;</span>

<span style="color: #ff4500;">/* </span><span style="color: #ff4500;">copia la entrada a la salida; 2a. version </span><span style="color: #ff4500;">*/</span>
<span style="color: #87cefa;">main</span>()
{
  <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">c</span>;

  <span style="color: #00ffff;">while</span> ((c = getchar()) != EOF)
    putchar(c);
}
</pre>
</div>

<p>
El <code>while</code> obtiene un caracter, lo asigna a <code>c</code>, y entonces prueba
si el caracter fue la señal de fin de archivo. De no serlo, el
cuerpo del <code>while</code> se ejecuta, escribiendo el caracter; luego se
repite el <code>while</code>. Luego, cuando se alcanza el final de la
entrada, el <code>while</code> termina y tambien lo hace <code>main</code>.
</p>

<p>
Esta version centraliza la entrada &#x2013;ahora hay solo una referencia
a <a href="#org4d38061"><code>getchar</code></a>&#x2013; y reduce el programa. El programa resultante es mas
compacto y mas facil de leer una vez que se domina el truco. Usted
vera seguido este estilo. (Sin embargo, es posible descarriarse y
crear codigo impenetrable, una tendencia que trataremos de
reprimir.)
</p>

<p>
Los parentesis que estan alrededor de la asignacion dentro de la
condicion son necesarios. La <i>precedencia</i> de <code>!=</code> es mas alta que
la de <code>=</code>, lo que significa que en ausencia de parentesis la
prueba de relacion <code>!=</code> se realizaria antes de la asignacion
<code>=</code>. De esta manera, la proposicion
</p>

<div class="org-src-container">
<pre class="src src-c">c = getchar() != EOF
</pre>
</div>

<p>
es equivalente a
</p>

<div class="org-src-container">
<pre class="src src-c">c = (getchar() != EOF)
</pre>
</div>

<p>
Esto tiene el efecto indeseable de hacer que <code>c</code> sea <code>0</code> o <code>1</code>,
dependiendo de si la llamada de <a href="#org4d38061"><code>getchar</code></a> encontro fin de
archivo. (En el <a href="#org29d5b55">capitulo 2</a> se trata este tema con mas detalle).
</p>

<p>
<b>Ejercicio 1-6</b>. Verifique que la expresion <code>getchar() != EOF</code> es
<code>0</code> o <code>1</code>.
</p>

<p>
<b>Ejercicio 1-7</b>. Escriba un programa que imprima el valor de
<code>EOF</code>.
</p>
</div>
</div>

<div id="outline-container-orga9076fa" class="outline-4">
<h4 id="orga9076fa">1.5.2 Conteo de caracteres                                        <a id="org7759d37"></a></h4>
<div class="outline-text-4" id="text-orga9076fa">
<p>
El siguiente programa cuenta caracteres y es semejante al programa
que copia.
</p>

<div class="org-src-container">
<pre class="src src-c"><span style="color: #b0c4de;">#include</span> <span style="color: #ffa07a;">&lt;stdio.h&gt;</span>
<span style="color: #ff4500;">/* </span><span style="color: #ff4500;">cuenta los caracteres de la entrada; 1a. version </span><span style="color: #ff4500;">*/</span>
<span style="color: #87cefa;">main</span>()
{
  <span style="color: #98fb98;">long</span> <span style="color: #eedd82;">nc</span>;
  nc = 0;
  <span style="color: #00ffff;">while</span> (getchar() != EOF)
    ++nc;

  printf(<span style="color: #ffa07a;">"%ld\n"</span>, nc);
}
</pre>
</div>

<p>
La proposicion
</p>

<div class="org-src-container">
<pre class="src src-c">++nc;
</pre>
</div>

<p>
Presenta un nuevo operador, <code>++</code>, que significa <i>incrementa en
uno</i>. Es posible escribir <code>nc = nc + 1</code>, pero <code>++nc</code> es mas
conciso y muchas veces mas eficiente. Hay un operador
correspondiente para disminuir en 1, es <code>--</code>. Los operadores <code>++</code>
y <code>--</code> pueden ser tanto operadores prefijos (<code>++nc</code>) como
postfijos (<code>nc++</code>); esas dos formas tienen diferentes valores
dentro de las expresiones, como se demostrara en el <a href="#org29d5b55">capitulo 2</a>,
pero ambos <code>++nc</code> y <code>nc++</code> incrementan a <code>nc</code>. Por el momento
adoptaremos la forma de prefijo.
</p>

<p>
El programa para contar caracteres acumula su cuenta en una
variable <code>long</code> en lugar de una <code>int</code>. Los enteros <code>long</code> son por
lo menos de 32 bits. Aunque en algunas maquinas <code>int</code> y <code>long</code> son
del mismo tamaño, en otras un <code>int</code> es de 16 bits, con un valor
maximo de 32767, y tomaria relativamente poca lectura a la entrada
para desbordar un contador <code>int</code>. La especificacion de conversion
<code>%ld</code> indica a <a href="#org0458a76"><code>printf</code></a> que el argumento correspondiente es un
entero <code>long</code>.
</p>

<p>
Seria posible tener la capacidad de trabajar con numeros mayores
empleando un <code>double</code> (<code>float</code> de doble precision). Tambien se
utilizara una proposicion <code>for</code> en lugar de un <code>while</code>, para demostrar
otra forma de escribir el ciclo.
</p>

<div class="org-src-container">
<pre class="src src-c"><span style="color: #b0c4de;">#include</span> <span style="color: #ffa07a;">&lt;stdio.h&gt;</span>

<span style="color: #ff4500;">/* </span><span style="color: #ff4500;">cuenta los caracteres de la entrada; 2a. version </span><span style="color: #ff4500;">*/</span>
<span style="color: #87cefa;">main</span>()
{
  <span style="color: #98fb98;">double</span> <span style="color: #eedd82;">nc</span>;

  <span style="color: #00ffff;">for</span> (nc = 0; getchar() != EOF; ++nc)
    ;
  printf(<span style="color: #ffa07a;">"%.0f\n"</span>, nc);
}
</pre>
</div>

<p>
<a href="#org0458a76"><code>printf</code></a> utiliza <code>%f</code> tanto para <code>float</code> como para <code>double</code>;
<code>%.0f</code> suprime la impresion del punto decimal y de la parte
fraccionaria, que es cero.
</p>

<p>
El cuerpo de este ciclo <code>for</code> esta vacio, debido a que todo el
trabajo se realiza en las secciones de prueba e incremento. Pero
las reglas gramaticales de C requieren que una proposicion <code>for</code>
tenga un cuerpo. El punto y coma aislado se llama <i>proposicion
nula</i>, y esta aqui para satisfacer este requisito. Lo colocamos en
una linea aparte para que sea visible.
</p>

<p>
Antes de abandonar el programa para contar caracteres, observese
que si la entrada no contiene caracteres, la prueba del <code>while</code> o
del for= no tiene exito desde la primera llamada a <a href="#org4d38061"><code>getchar</code></a>, y el
programa produce cero, el resultado correcto. Esto es
importante. Uno de los aspectos agradables acerca del <code>while</code> y
del <code>for</code> es que hacen la prueba al inicio del ciclo, antes de
proceder con el cuerpo. Si no hay nada que hacer, nada se hace,
aun si ello significa no pasar a traves del cuerpo del ciclo. Los
programas deben actuar en forma inteligente cuando se les da una
entrada de longitud cero. Las proposiciones <code>while</code> y <code>for</code> ayudan
a asegurar que los programas realizan cosas razonables con
condiciones de frontera.
</p>
</div>
</div>

<div id="outline-container-orge7b7124" class="outline-4">
<h4 id="orge7b7124">1.5.3 Conteo de lineas                                            <a id="org27514e5"></a></h4>
<div class="outline-text-4" id="text-orge7b7124">
<p>
El siguiente programa cuenta lineas a la entrada. Como se menciono
anteriormente, la biblioteca estandar asegura que una secuencia de
texto de entrada parezca una secuencia de lineas, cada una
terminada por un caracter nueva linea. Por lo tanto, contar lineas
es solamente contar caracteres nueva linea:
</p>

<div class="org-src-container">
<pre class="src src-c"><span style="color: #b0c4de;">#include</span> <span style="color: #ffa07a;">&lt;stdio.h&gt;</span>

<span style="color: #ff4500;">/* </span><span style="color: #ff4500;">cuenta las lineas de la entrada </span><span style="color: #ff4500;">*/</span>
<span style="color: #87cefa;">main</span>()
{
  <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">c</span>, <span style="color: #eedd82;">nl</span>;

  nl = 0;
  <span style="color: #00ffff;">while</span> ((c = getchar()) != EOF)
    <span style="color: #00ffff;">if</span> (c == <span style="color: #ffa07a;">'\n'</span>)
      ++nl;
  printf(<span style="color: #ffa07a;">"%d\n"</span>, nl);
}
</pre>
</div>

<p>
El cuerpo del <code>while</code> consiste ahora en un <code>if</code>, el cual a su vez
controla el incremento <code>++nl</code>. La proposicion <code>if</code> prueba la
condicion que se encuentra entre parentesis y, si la condicion es
verdadera, ejecuta la proposicion (o grupo de proposiciones entre
llaves) que le sigue. Hemos sangrado nuevamente para mostrar lo que
controla cada elemento.
</p>

<p>
El doble signo de igualdad <code>==</code> es la notacion de C para expresar
"igual a" (como el = simple de Pascal o el <code>.EQ.</code> de
Fortran). Este simbolo se emplea para distinguir la prueba de
igualdad del <code>=</code> simple que utiliza C para la asignacion. Un
mensaje de alerta: los principiantes de C ocasionalmente escriben
<code>=</code> cuando en realidad deben usar <code>==</code>. Como se vera en el
<a href="#org29d5b55">capitulo 2</a>, el resultado es por lo general una expresion legal, de
modo que no se obtendra ninguna advertencia.
</p>

<p>
Un caracter escrito entre apostrofos representa un valor entero
igual al valor numerico del caracter en el conjunto de caracteres
de la maquina. Esto se llama una <i>constante de caracter</i>, aunque
solo es otra forma de escribir un pequeño entero. Asi, por ejemplo
'A' es una constante de caracter; en el conjunto ASCII de
caracteres su valor es <code>65</code>, esto es, la representacion interna del
caracter <code>A</code>. Por supuesto 'A' es preferible que 65: su significado
es obvio, y es independiente de un conjunto de caracteres en
particular.
</p>

<p>
Las secuencias de escape que se utilizan en constantes de cadena
tambien son legales en constantes de caracter; asi, '\n' significa
el valor del caracter nueva linea, el cual es <code>10</code> en codigo
ASCII. Se debe notar cuidadosamente que ’\n' es un caracter simple,
y en expresiones es solo un entero; por otro lado, "\n" es una
constante cadena que contiene solo un caracter. En el <a href="#org29d5b55">capitulo 2</a> se
trata el tema de cadenas versus caracteres.
</p>

<p>
<b>Ejercicio 1-8</b>. Escriba un programa que cuente espacios en blanco,
tabuladores y nuevas lineas.
</p>

<p>
<b>Ejercicio 1.9</b>. Escriba un programa que copie su entrada a la
salida, reemplazando cada cadena de uno o mas blancos por un solo
blanco.
</p>

<p>
<b>Ejercicio 1-10</b>. Escriba un programa que copie su entrada a la
salida, reemplazando cada tabulacion por <code>\t</code>, cada retroceso por
<code>\b</code> y cada diagonal invertida por <code>\\</code>. Esto hace que las
tabulaciones y los espacios sean visibles sin confusiones.
</p>
</div>
</div>

<div id="outline-container-org0b39e7f" class="outline-4">
<h4 id="org0b39e7f">1.5.4 Conteo de palabras                                          <a id="org6c191e3"></a></h4>
<div class="outline-text-4" id="text-org0b39e7f">
<p>
El cuarto en nuestra serie de programas utiles cuenta las lineas,
palabras y caracteres, usando la definicion de que una palabra es
cualquier secuencia de caracteres que no contiene espacio en
blanco ni tabulacion ni nueva linea. Esta es una version reducida
del programa <code>wc</code> de UNIX.
</p>

<div class="org-src-container">
<pre class="src src-c"><span style="color: #b0c4de;">#include</span> <span style="color: #ffa07a;">&lt;stdio.h&gt;</span>
<span style="color: #b0c4de;">#define</span> <span style="color: #eedd82;">IN</span>  1   <span style="color: #ff4500;">/* </span><span style="color: #ff4500;">en una palabra </span><span style="color: #ff4500;">*/</span>
<span style="color: #b0c4de;">#define</span> <span style="color: #eedd82;">OUT</span> 0   <span style="color: #ff4500;">/* </span><span style="color: #ff4500;">fuera de una palabra </span><span style="color: #ff4500;">*/</span>

<span style="color: #ff4500;">/* </span><span style="color: #ff4500;">cuenta lineas, palabras, y caracteres de la entrada </span><span style="color: #ff4500;">*/</span>
<span style="color: #87cefa;">main</span>()
{
  <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">c</span>, <span style="color: #eedd82;">nl</span>, <span style="color: #eedd82;">nw</span>, <span style="color: #eedd82;">nc</span>, <span style="color: #eedd82;">state</span>;
  state = OUT;
  nl = nw = nc = 0;
  <span style="color: #00ffff;">while</span> ((c = getchar()) != EOF) {
    ++nc;
    <span style="color: #00ffff;">if</span> (c == <span style="color: #ffa07a;">'\n'</span>)
      ++nl;
    <span style="color: #00ffff;">if</span> (c == <span style="color: #ffa07a;">' '</span> || c == <span style="color: #ffa07a;">'\n'</span> || c == <span style="color: #ffa07a;">'\t'</span>)
      state = OUT;
    <span style="color: #00ffff;">else</span> <span style="color: #00ffff;">if</span> (state == OUT) {
      state = IN;
      ++nw;
    }
  }
  printf(<span style="color: #ffa07a;">"%d %d %d\n"</span>, nl, nw, nc);
}
</pre>
</div>

<p>
Cada vez que el programa encuentra el primer caracter de una
palabra, contabiliza una palabra mas. La variable <code>state</code> registra
si actualmente el programa esta o no sobre una palabra; al iniciar
es "no esta sobre una palabra", por lo que se asigna el valor
<code>OUT</code>. Es preferible usar las constantes simbolicas <code>IN</code> y <code>OUT</code>
que los valores literales <code>1</code> y <code>0</code>, porque hacen el programa mas
legible. En un programa tan pequeño como este, la diferencia es
minima, pero en programas mas grandes el incremento en claridad
bien vale el esfuerzo extra que se haya realizado para escribir de
esta manera desde el principio. Tambien se descubrira que es mas
facil hacer cambios extensivos en programas donde los numeros
magicos aparecen solo como constantes simbolicas.
</p>

<p>
La linea
</p>

<div class="org-src-container">
<pre class="src src-c">nl = nw = nc = 0;
</pre>
</div>

<p>
inicializa a las tres variables en cero. Este no es un caso
especial sino una consecuencia del hecho de que una asignacion es
una expresion con un valor, y que las asignaciones se asocian de
derecha a izquierda. Es como si se hubiese escrito
</p>

<div class="org-src-container">
<pre class="src src-c">nl = (nw = (nc = 0));
</pre>
</div>

<p>
El operador <code>||</code> significa "O" (o bien "OR"), por lo que la linea
</p>

<div class="org-src-container">
<pre class="src src-c"><span style="color: #00ffff;">if</span> (c == <span style="color: #ffa07a;">' '</span> || c == <span style="color: #ffa07a;">'\n'</span> || c == <span style="color: #ffa07a;">'\t'</span>)
</pre>
</div>

<p>
dice "si <code>c</code> es un blanco o <code>c</code> es nueva linea o <code>c</code> es un
tabulador". (Recuerde que la secuencia de escape <code>\t</code> es una
representacion visible del caracter tabulador.)  Existe un
correspondiente operador <code>&amp;&amp;</code> para <code>AND</code>; su precedencia es mas
alta que la de <code>||</code>. Las expresiones conectadas por <code>&amp;&amp;</code> o <code>||</code> se
evaluan de izquierda a derecha, y se garantiza que la evaluacion
terminara tan pronto como se conozca la verdad o falsedad. Si <code>c</code>
es un blanco, no hay necesidad de probar si es una nueva linea o
un tabulador, de modo que esas pruebas no se hacen. Esto no es de
particular importancia en este caso, pero es significativo en
situaciones mas complicadas, como se vera mas adelante.
</p>

<p>
El ejemplo muestra tambien un <code>else</code>, el cual especifica una
accion alternativa si la condicion de una proposicion <code>if</code> es
falsa. La forma general es
</p>

<div class="org-src-container">
<pre class="src src-c"><span style="color: #00ffff;">if</span> (expresion)
  proposicion1;
<span style="color: #00ffff;">else</span>
  proposicion2;
</pre>
</div>

<p>
Una y solo una de las dos proposiciones asociadas con un <code>if-else</code>
se realiza. Si la <code>expresion</code> es <code>verdadera</code>, se ejecuta
<code>proposicion1</code> si no lo es, se ejecuta <code>proposicion2</code>. Cada
proposicion puede ser una proposicion sencilla o varias entre
llaves. En el programa para contar palabras, la que esta despues
del <code>else</code> es un <code>if</code> que controla dos proposiciones entre llaves.
</p>

<p>
<b>Ejercicio 1-11</b>. ¿Como probaria el programa para contar palabras?
¿Que clase de entrada es la mas conveniente para descubrir errores
si estos existen?
</p>

<p>
<b>Ejercicio 1-12</b>. Escriba un programa que imprima su entrada una
palabra por linea.
</p>
</div>
</div>
</div>

<div id="outline-container-orgb2969a5" class="outline-3">
<h3 id="orgb2969a5">1.6  Arreglos                                                      <a id="org2222fff"></a></h3>
<div class="outline-text-3" id="text-orgb2969a5">
<p>
Escribamos un programa para contar el numero de ocurrencias de cada
digito, de caracteres espaciadores (blancos, tabuladores, nueva
linea), y de todos los otros caracteres. Esto es artificioso, pero
nos permite ilustrar varios aspectos de C en un programa.
</p>

<p>
Existen doce categorias de entrada, por lo que es conveniente
utilizar un arreglo para mantener el numero de ocurrencias de
cada digito, en lugar de tener diez variables individuales. Esta es
una version del programa:
</p>

<div class="org-src-container">
<pre class="src src-c"><span style="color: #b0c4de;">#include</span> <span style="color: #ffa07a;">&lt;stdio.h&gt;</span>

<span style="color: #ff4500;">/* </span><span style="color: #ff4500;">cuenta digitos, espacios blancos, y otros </span><span style="color: #ff4500;">*/</span>
<span style="color: #87cefa;">main</span>()
{
  <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">c</span>, <span style="color: #eedd82;">i</span>, <span style="color: #eedd82;">nwhite</span>, <span style="color: #eedd82;">nother</span>;
  <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">ndigit</span>[10];
  nwhite = nother = 0;
  <span style="color: #00ffff;">for</span> (i = 0; i &lt; 10; ++i)
    ndigit[i] = 0;
  <span style="color: #00ffff;">while</span> ((c = getchar()) != EOF)
    <span style="color: #00ffff;">if</span> (c &gt;= <span style="color: #ffa07a;">'0'</span> &amp;&amp; c &lt;= <span style="color: #ffa07a;">'9'</span>)
      ++ndigit[c-<span style="color: #ffa07a;">'0'</span>];
    <span style="color: #00ffff;">else</span> <span style="color: #00ffff;">if</span> (c == <span style="color: #ffa07a;">' '</span> || c == <span style="color: #ffa07a;">'\n'</span> || c == <span style="color: #ffa07a;">'\t'</span>)
      ++nwhite;
    <span style="color: #00ffff;">else</span>
      ++nother;
  printf(<span style="color: #ffa07a;">"digits ="</span>);
  <span style="color: #00ffff;">for</span> (i = 0; i &lt; 10; ++i)
    printf(<span style="color: #ffa07a;">" %d"</span>, ndigit[i]);
  printf(<span style="color: #ffa07a;">", espacios blancos = %d, other = %d\n"</span>,
         nwhite, nother);
}
</pre>
</div>

<p>
La salida de este programa al ejecutarlo sobre si mismo es
</p>

<pre class="example">
digits = 9 3 0 0 0 0 0 0 0 1, espacios blancos = 159, other = 358
</pre>

<p>
La declaracion
</p>

<div class="org-src-container">
<pre class="src src-c"><span style="color: #98fb98;">int</span> <span style="color: #eedd82;">ndigit</span>[10];
</pre>
</div>

<p>
declara <code>ndigit</code> como un arreglo de 10 enteros. En C, los
subindices de arreglos comienzan en cero, por lo que los elementos
son <code>ndigit[0]</code>, <code>ndigit[1]</code>, &#x2026;, <code>ndigit[9]</code>. Esto se refleja en
los ciclos for que inicializan e imprimen el arreglo.
</p>

<p>
Un subindice puede ser cualquier expresion entera, lo que incluye a
variables enteras como <code>i</code>, y constantes enteras.
</p>

<p>
Este programa en particular se basa en las propiedades de la
representacion de los digitos como caracteres. Por ejemplo, la
prueba
</p>

<div class="org-src-container">
<pre class="src src-c"><span style="color: #00ffff;">if</span> (c &gt;= <span style="color: #ffa07a;">'0'</span> &amp;&amp; c &lt;= <span style="color: #ffa07a;">'9'</span>) ...
</pre>
</div>

<p>
determina si el caracter en <code>c</code> es un digito. Si lo es, el valor
numerico del digito es:
</p>

<div class="org-src-container">
<pre class="src src-c">c - <span style="color: #ffa07a;">'0'</span>
</pre>
</div>

<p>
Esto solo funciona si '0', '1', &#x2026;, '9' tienen valores
consecutivos ascendentes. Por fortuna, esto es asi en todos los
conjuntos de caracteres.
</p>

<p>
Por definicion, los <code>char</code> son solo pequeños enteros, por lo que
las variables y las constantes <code>char</code> son identicas a las <code>int</code> en
expresiones aritmeticas. Esto es natural y conveniente; por
ejemplo, <code>c-'0'</code> es una expresion entera con un valor entre <code>0</code> y
<code>9</code>, correspondiente a los caracteres ’0’ a ’9’ almacenados en <code>c</code>,
por lo que es un subindice valido para el arreglo <code>ndigit</code>.
</p>

<p>
La decision de si un caracter es digito, espacio en blanco u otra
cosa se realiza con la secuencia:
</p>

<div class="org-src-container">
<pre class="src src-c"><span style="color: #00ffff;">if</span> (c &gt;= <span style="color: #ffa07a;">'0'</span> &amp;&amp; c &lt;= <span style="color: #ffa07a;">'9'</span>)
  ++ndigit[ c - <span style="color: #ffa07a;">'0'</span> ];
<span style="color: #00ffff;">else</span> <span style="color: #00ffff;">if</span> (c == <span style="color: #ffa07a;">' '</span> || c == <span style="color: #ffa07a;">'\n'</span> || c == <span style="color: #ffa07a;">'\t'</span>)
  ++nwhite;
<span style="color: #00ffff;">else</span>
  ++nother;
</pre>
</div>

<p>
El patron:
</p>

<div class="BLOCK">
<p>
<code>if</code> (condicion1)
  proposicion1
<code>else if</code> (condicion2)
  proposicion2
  &#x2026;
  &#x2026;
<code>else</code>
  proposicion<sub>n</sub>
</p>

</div>

<p>
se encuentra frecuentemente en programas como una forma de expresar
una decision multiple. Las <i>condiciones</i> se evaluan en orden desde
el principio hasta que se satisface alguna <i>condicion</i>; en ese
punto se ejecuta la <i>proposicion</i> correspondiente, y la
construccion completa termina. (Cualquier <i>proposicion</i> puede
constar de varias proposiciones entre llaves.) Si no se satisface
ninguna de las condiciones, se ejecuta la <i>proposicion</i> que esta
despues del <code>else</code> final, si esta existe. Cuando se omiten el
<code>else</code> y la <i>proposicion</i> finales, tal como se hizo en el programa
para contar palabras, no tiene lugar ninguna accion. Puede haber
cualquier numero de grupos de
</p>

<pre class="example">
else if (condicion)
  proposicion
</pre>

<p>
entre el <code>if</code> inicial y el <code>else</code> final.
</p>

<p>
Se recomienda, por estilo, escribir esta construccion tal como se
ha mostrado; si cada <code>if</code> estuviese sangrado despues del <code>else</code>
anterior, una larga secuencia de decisiones podria rebasar el
margen derecho de la pagina.
</p>

<p>
La proposicion <code>switch</code>, que se tratara en el <a href="#org35eee87">capitulo 3</a>,
proporciona otra forma de escribir una decision multiple, que es
particularmente apropiada cuando la condicion es determinar si
alguna expresion entera o de caracter corresponde con algun miembro
de un conjunto de constantes. Para contrastar, se presentara una
version de este programa, usando <code>switch</code>, en la seccion 3.4.
</p>

<p>
<b>Ejercicio 1-13</b>. Escriba un programa que imprima el histograma de
las longitudes de las palabras de su entrada. Es facil dibujar el
histograma con las barras horizontales; la Orientacion vertical es
un reto mas interesante.
</p>

<p>
<b>Ejercicio 1-14</b>. Escriba un programa que imprima el histograma de
las frecuencias con que se presentan diferentes caracteres leidos a
la entrada.
</p>
</div>
</div>

<div id="outline-container-org8ca612d" class="outline-3">
<h3 id="org8ca612d">1.7  Funciones                                                     <a id="org73a2a5a"></a></h3>
<div class="outline-text-3" id="text-org8ca612d">
<p>
En lenguaje C, una funcion es el equivalente a una subrutina o
funcion en Fortran, o a un procedimiento o funcion en Pascal. Una
funcion proporciona una forma conveniente de encapsular algunos
calculos, que se pueden emplear despues sin preocuparse de su
implantacion. Con funciones diseñadas adecuadamente, es posible
ignorar <i>como</i> se realiza un trabajo; es suficiente saber <i>que</i> se
hace. El lenguaje C hace que el uso de funciones sea facil,
conveniente y eficiente; es comun ver una funcion corta definida y
empleada una sola vez, unicamente porque eso esclarece alguna parte
del codigo.
</p>

<p>
Hasta ahora solo se han utilizado funciones como <i>printf</i>,
<i>getchar</i> y <i>putchar</i>, que nos han sido proporcionadas; ya es el
momento de escribir unas pocas nosotros mismos. Dado que C no posee
un operador de exponenciacion como el <code>**</code> de Fortran, ilustremos
el mecanismo de la definicion de una funcion al escribir la funcion
<code>power(m,n)</code>, que eleva un entero <code>m</code> a una potencia entera y
positiva <code>n</code>.  Esto es, el valor de <code>power(2,5)</code> es <code>32</code>. Esta
funcion no es una rutina de exponenciacion practica, puesto que
solo maneja potencias positivas de enteros pequeños, pero es
suficiente para ilustracion (la biblioteca estandar contiene una
funcion <code>pow(x,y)</code> que calcula \[x^y\] ).
</p>

<p>
A continuacion se presenta la funcion <code>power</code> y un programa <code>main</code>
para utilizarla, de modo que se vea la estructura completa de una
vez.
</p>

<div class="org-src-container">
<pre class="src src-c"><span style="color: #b0c4de;">#include</span> <span style="color: #ffa07a;">&lt;stdio.h&gt;</span>
<span style="color: #98fb98;">int</span> <span style="color: #87cefa;">power</span>(<span style="color: #98fb98;">int</span> <span style="color: #eedd82;">m</span>, <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">n</span>);

<span style="color: #ff4500;">/* </span><span style="color: #ff4500;">prueba la funcion power </span><span style="color: #ff4500;">*/</span>
<span style="color: #87cefa;">main</span>()
{
  <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">i</span>;
  <span style="color: #00ffff;">for</span> (i = 0; i &lt; 10; ++i)
    printf(<span style="color: #ffa07a;">"%d %d %d\n"</span>, i, power(2,i), power(-3,i));
  <span style="color: #00ffff;">return</span> 0;
}

<span style="color: #ff4500;">/* </span><span style="color: #ff4500;">power: eleva la base a la n-esima potencia; n &gt;= 0 </span><span style="color: #ff4500;">*/</span>
<span style="color: #98fb98;">int</span> <span style="color: #87cefa;">power</span>(<span style="color: #98fb98;">int</span> <span style="color: #eedd82;">base</span>, <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">n</span>)
{
  <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">i</span>, <span style="color: #eedd82;">p</span>;
  p = 1;
  <span style="color: #00ffff;">for</span> (i = 1; i &lt;= n; ++i)
    p = p * base;
  <span style="color: #00ffff;">return</span> p;
}
</pre>
</div>

<p>
Una definicion de funcion tiene la forma siguiente:
</p>

<pre class="example">
tipo-de-retorno nombre-de-funcion (declaracion de parametros, si los hay)
{
  declaraciones
  proposiciones
}
</pre>

<p>
Las definiciones de funcion pueden aparecer en cualquier orden y en
uno o varios archivos fuente, pero una funcion no puede separarse
en archivos diferentes. Si el programa fuente aparece en varios
archivos, tal vez se tengan que especificar mas cosas al compilar y
cargarlo que si estuviera en uno solo, pero eso es cosa del sistema
operativo, no un atributo del lenguaje. Por ahora supondremos que
ambas funciones estan en el mismo archivo y cualquier cosa que se
haya aprendido acerca de como ejecutar programas en C, aun
funcionaran.
</p>

<p>
La funcion <code>power</code> se invoca dos veces por <code>main</code>, en la linea:
</p>

<div class="org-src-container">
<pre class="src src-c">printf(<span style="color: #ffa07a;">"%d %d %d\n"</span>, i, power(2,i), power(-3,i));
</pre>
</div>

<p>
Cada llamada pasa dos argumentos a <code>power</code>, que cada vez regresa un
entero, al que se pone formato y se imprime. En una expresion,
<code>power(2,i)</code> es un entero tal como lo son <code>2</code> e <code>i</code>. (No todas las
funciones producen un valor entero; lo que se vera en el <a href="#org05a38fc">capitulo 4</a>.)
</p>

<p>
La primera linea de la funcion <code>power</code>,
</p>

<div class="org-src-container">
<pre class="src src-c"><span style="color: #98fb98;">int</span> <span style="color: #87cefa;">power</span>(<span style="color: #98fb98;">int</span> <span style="color: #eedd82;">base</span>, <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">n</span>)
</pre>
</div>

<p>
declara los tipos y nombres de los parametros, asi como el tipo de
resultado que la funcion devuelve. Los nombres que emplea <code>power</code>
para sus parametros son locales a la funcion y son invisibles a
cualquier otra funcion: otras rutinas pueden utilizar los mismos
nombres sin que exista problema alguno. Esto tambien es cierto para
las variables <code>i</code> y <code>p</code>: la <code>i</code> de <code>power</code> no tiene nada que ver
con la <code>i</code> de <code>main</code>.
</p>

<p>
Generalmente usaremos <i>parametro</i> para una variable nombrada en la
lista entre parentesis de la definicion de una funcion, y
<i>argumento</i> para el valor empleado al hacer la llamada de la
funcion. Los terminos <i>argumento formal</i> y <i>argumento real</i> se
emplean en ocasiones para hacer la misma distincion.
</p>

<p>
El valor que calcula <code>power</code> se regresa a <code>main</code> por medio de la
proposicion <code>return</code>, a la cual le puede seguir cualquier
expresion:
</p>

<pre class="example">
return expresion
</pre>

<p>
Una funcion no necesita regresar un valor; una <i>proposicion</i>
<code>return</code> sin expresion hace que el control regrese al programa,
pero no devuelve algun valor de utilidad, como se haria al "caer al
final" de una funcion al alcanzar la llave derecha de
terminacion. Ademas, la funcion que llama puede ignorar el valor
que regresa una funcion.
</p>

<p>
Probablemente haya notado que hay una proposicion <code>return</code> al final
de <code>main</code>.  Puesto que <code>main</code> es una funcion como cualquier otra,
tambien puede regresar un valor a quien la invoca, que es en efecto
el medio ambiente en el que el programa se ejecuta. Tipicamente, un
valor de regreso cero implica una terminacion normal; los valores
diferentes de cero indican condiciones de terminacion no comunes o
erroneas. Para buscar la simplicidad, se han omitido hasta ahora
las proposiciones <code>return</code> de las funciones <code>main</code>, pero se
incluiran mas adelante, como un recordatorio de que los programas
deben regresar su estado final a su medio ambiente.
</p>

<p>
La declaracion:
</p>

<div class="org-src-container">
<pre class="src src-c"><span style="color: #98fb98;">int</span> <span style="color: #87cefa;">power</span>(<span style="color: #98fb98;">int</span> <span style="color: #eedd82;">m</span>, <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">n</span>);
</pre>
</div>

<p>
precisamente antes de <code>main</code>, indica que <code>power</code> es una funcion que
espera dos argumentos <code>int</code> y regresa un <code>int</code>. Esta declaracion, a
la cual se le llama funcion prototipo, debe coincidir con la
definicion y uso de <code>power</code>. Es un error el que la definicion de
una funcion o cualquier uso que de ella se haga no corresponda con
su prototipo.
</p>

<p>
Los nombres de los parametros no necesitan coincidir; de hecho, son
optativos en el prototipo de una funcion, de modo que para el
prototipo se pudo haber escrito
</p>

<div class="org-src-container">
<pre class="src src-c"><span style="color: #98fb98;">int</span> <span style="color: #87cefa;">power</span>(<span style="color: #98fb98;">int</span>, <span style="color: #98fb98;">int</span>);
</pre>
</div>

<p>
No obstante, unos nombres bien seleccionados son una buena
documentacion, por lo que se emplearan frecuentemente.
</p>

<p>
Una nota historica: La mayor modificacion entre ANSI C y las
versiones anteriores es como estan declaradas y definidas las
funciones. En la definicion original de C, la funcion <code>power</code> se
pudo haber escrito de la siguiente manera:
</p>


<div class="org-src-container">
<pre class="src src-c"><span style="color: #ff4500;">/* </span><span style="color: #ff4500;">power: eleva la base a n-esima potencia; n &gt;= 0 </span><span style="color: #ff4500;">*/</span>
<span style="color: #ff4500;">/*           </span><span style="color: #ff4500;">(version en estilo antiguo)            </span><span style="color: #ff4500;">*/</span>
<span style="color: #87cefa;">power</span>(base, n)
<span style="color: #98fb98;">int</span> <span style="color: #eedd82;">base</span>, <span style="color: #eedd82;">n</span>;
{
  <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">i</span>, <span style="color: #eedd82;">p</span>;
  p = 1;
  <span style="color: #00ffff;">for</span> (i = 1; i &lt;= n; ++i)
    p = p * base;
  <span style="color: #00ffff;">return</span> p;
}
</pre>
</div>

<p>
Los parametros se nombran entre los parentesis y sus tipos se
declaran antes de abrir la llave izquierda; los parametros que no
se declaran se toman como <code>int</code>. (El cuerpo de la funcion es igual
a la anterior.)
</p>

<p>
La declaracion de <code>power</code> al inicio del programa pudo haberse visto
como sigue:
</p>

<div class="org-src-container">
<pre class="src src-c"><span style="color: #98fb98;">int</span> <span style="color: #87cefa;">power</span>();
</pre>
</div>

<p>
No se permitio ninguna lista de parametros, de modo que el
compilador no pudo revisar con facilidad que <code>power</code> fuera llamada
correctamente. De hecho, puesto que por omision se podia suponer
que <code>power</code> regresaba un <code>int</code>, toda la declaracion podria haberse
omitido.
</p>

<p>
La nueva sintaxis de los prototipos de funciones permite que sea
mucho mas facil para el compilador detectar errores en el numero o
tipo de argumentos. El viejo estilo de declaracion y definicion aun
funciona en ANSI C, al menos por un periodo de transicion, pero se
recomienda ampliamente que se utilice la nueva forma si se tiene un
compilador que la maneje.
</p>

<p>
<b>Ejercicio 1-15</b>. Escriba de nuevo el programa de conversion de
temperatura de la <a href="#org8192a63">seccion 1.2</a>, de modo que utilice una funcion para
la conversion.
</p>
</div>
</div>

<div id="outline-container-org4a4a9b1" class="outline-3">
<h3 id="org4a4a9b1">1.8  Argumentos - llamadas por valor                               <a id="orgc26710c"></a></h3>
<div class="outline-text-3" id="text-org4a4a9b1">
<p>
Hay un aspecto de las funciones de C que puede parecer poco
familiar a los programadores acostumbrados a otros lenguajes,
particularmente Fortran. En C, todos los argumentos de una funcion
se pasan "por valor". Esto significa que la funcion que se invoca
recibe los valores de sus argumentos en variables temporales y no
en las originales. Esto conduce a algunas propiedades diferentes a
las que se ven en lenguajes con "llamadas por referencia" como
Fortran o con parametros <code>var</code> Pascal, en donde la rutina que se
invoca tiene acceso al argumento original, no a una copia local.
</p>

<p>
La diferencia principal es que en C la funcion que se invoca no
puede alterar directamente una variable de la funcion que hace la
llamada; solo puede modificar su copia privada y temporal.
</p>

<p>
Sin embargo, la llamada por valor es una ventaja, no una
desventaja. Por lo comun, esto conduce a elaborar programas mas
compactos con pocas variables extrañas, debido a que los parametros
se tratan en la funcion invocada como variables locales
convenientemente inicializadas. Por ejemplo, he aqui una version de
<code>power</code> que utiliza esta propiedad.
</p>

<div class="org-src-container">
<pre class="src src-c"><span style="color: #ff4500;">/* </span><span style="color: #ff4500;">power: eleva la base a la n-esima potencia; n &gt;= 0; version 2 </span><span style="color: #ff4500;">*/</span>
<span style="color: #98fb98;">int</span> <span style="color: #87cefa;">power</span>(<span style="color: #98fb98;">int</span> <span style="color: #eedd82;">base</span>, <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">n</span>)
{
  <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">p</span>;
  <span style="color: #00ffff;">for</span> (p = 1; n &gt; 0; --n)
    p = p * base;
  <span style="color: #00ffff;">return</span> p;
}
</pre>
</div>

<p>
El parametro <code>n</code> se utiliza como una variable temporal, y se
decrementa (un ciclo <code>for</code> que se ejecuta hacia atras) hasta que
llega a cero; ya no es necesaria la variable <code>i</code>. Cualquier cosa
que se le haga a <code>n</code> dentro de <code>power</code> no tiene efecto sobre el
argumento con el que se llamo originalmente <code>power</code>.
</p>

<p>
Cuando sea necesario, es posible hacer que una funcion modifique
una variable dentro de una rutina invocada. La funcion que llama
debe proporcionar la <i>direccion</i> de la variable que sera cambiada
(tecnicamente un <i>apuntador</i> a la variable), y la funcion que se
invoca debe declarar que el parametro sea un apuntador y tenga
acceso a la variable indirectamente a traves de el. Los apuntadores
se trataran en el <a href="#org69d49af">capitulo 5</a>.
</p>

<p>
La historia es diferente con los arreglos. Cuando el nombre de un
arreglo se emplea como argumento, el valor que se pasa a la funcion
es la localizacion o la direccion del principio del arreglo &#x2013;no
hay copia de los elementos del arreglo. Al colocarle subindices a
este valor, la funcion puede tener acceso y alterar cualquier
elemento del arreglo. Este es el tema de la siguiente seccion.
</p>
</div>
</div>

<div id="outline-container-org7265fff" class="outline-3">
<h3 id="org7265fff">1.9  Arreglos de caracteres                                        <a id="org6357bb7"></a></h3>
<div class="outline-text-3" id="text-org7265fff">
<p>
El tipo de arreglo mas comun en C es el de caracteres. Para
ilustrar el uso de arreglos de caracteres y funciones que los
manipulan, escriba un programa que lea un conjunto de lineas de
texto e imprima la de mayor longitud. El pseudocodigo es bastante
simple:
</p>

<div class="BLOCK">
<p>
<code>while</code> (hay otra linea)
  <code>if</code> (es mas larga que la anterior mas larga)
    (guardala)
      (guarda su longitud)
imprime la linea mas larga
</p>

</div>

<p>
Este pseudocodigo deja en claro que el programa se divide
naturalmente en partes. Una trae una nueva linea, otra la prueba y
el resto controla el proceso.
</p>

<p>
Puesto que la division de las partes es muy fina, lo correcto sera
escribirlas de ese modo. Asi pues, escribamos primero una funcion
<code>getline</code> para extraer la siguiente linea de la entrada. Trataremos
de hacer a la funcion util en otros contextos. Al menos, <code>getline</code>
tiene que regresar una señal acerca de la posibilidad de un fin de
archivo; un diseño de mas utilidad debera retornar la longitud de
la linea, o cero si se encuentra el fin de archivo. Cero es un
regreso de fin de archivo aceptable debido a que nunca es una
longitud de linea valida. Cada linea de texto tiene al menos un
caracter; incluso una linea que solo contenga un caracter nueva
linea tiene longitud 1.
</p>

<p>
Cuando se encuentre una linea que es mayor que la anteriormente mas
larga, se debe guardar en algun lugar. Esto sugiere una segunda
funcion <code>copy</code>, para copiar la nueva linea a un lugar seguro.
</p>

<p>
Finalmente, se necesita un programa principal para controlar
<code>getline</code> y <code>copy</code>.  El resultado es el siguiente:
</p>

<div class="org-src-container">
<pre class="src src-c"><span style="color: #b0c4de;">#include</span> <span style="color: #ffa07a;">&lt;stdio.h&gt;</span>
<span style="color: #b0c4de;">#define</span> <span style="color: #eedd82;">MAXLINE</span> 1000     <span style="color: #ff4500;">/* </span><span style="color: #ff4500;">tama&#241;o maximo de la linea de entrada </span><span style="color: #ff4500;">*/</span>

<span style="color: #98fb98;">int</span> <span style="color: #87cefa;">getline</span>(<span style="color: #98fb98;">char</span> <span style="color: #eedd82;">line</span>[], <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">maxline</span>);
<span style="color: #98fb98;">void</span> <span style="color: #87cefa;">copy</span>(<span style="color: #98fb98;">char</span> <span style="color: #eedd82;">to</span>[], <span style="color: #98fb98;">char</span> <span style="color: #eedd82;">from</span>[]);

<span style="color: #ff4500;">/* </span><span style="color: #ff4500;">imprime la linea de entrada mas larga </span><span style="color: #ff4500;">*/</span>
<span style="color: #87cefa;">main</span>()
{
  <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">len</span>;               <span style="color: #ff4500;">/* </span><span style="color: #ff4500;">longitud actual de la linea </span><span style="color: #ff4500;">*/</span>
  <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">max</span>;               <span style="color: #ff4500;">/* </span><span style="color: #ff4500;">maxima longitud vista hasta el momento </span><span style="color: #ff4500;">*/</span>
  <span style="color: #98fb98;">char</span> <span style="color: #eedd82;">line</span>[MAXLINE];    <span style="color: #ff4500;">/* </span><span style="color: #ff4500;">linea de entrada actual </span><span style="color: #ff4500;">*/</span>
  <span style="color: #98fb98;">char</span> <span style="color: #eedd82;">longest</span>[MAXLINE]; <span style="color: #ff4500;">/* </span><span style="color: #ff4500;">la linea mas larga se guarda aqui </span><span style="color: #ff4500;">*/</span>

  max = 0;
  <span style="color: #00ffff;">while</span> ((len = getline(line, MAXLINE)) &gt; 0)
    <span style="color: #00ffff;">if</span> (len &gt; max) {
      max = len;
      copy(longest, line);
    }
  <span style="color: #00ffff;">if</span> (max &gt; 0)           <span style="color: #ff4500;">/* </span><span style="color: #ff4500;">hubo una linea </span><span style="color: #ff4500;">*/</span>
    printf(<span style="color: #ffa07a;">"%s"</span>, longest);
  <span style="color: #00ffff;">return</span> 0;
}

<span style="color: #ff4500;">/* </span><span style="color: #ff4500;">getline: lee una linea en s, regresa su longitud </span><span style="color: #ff4500;">*/</span>
<span style="color: #98fb98;">int</span> <span style="color: #87cefa;">getline</span>(<span style="color: #98fb98;">char</span> <span style="color: #eedd82;">s</span>[],<span style="color: #98fb98;">int</span> <span style="color: #eedd82;">lim</span>)
{
  <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">c</span>, <span style="color: #eedd82;">i</span>;

  <span style="color: #00ffff;">for</span> (i=0; i &lt; lim-1 &amp;&amp; (c=getchar())!=EOF &amp;&amp; c!=<span style="color: #ffa07a;">'\n'</span>; ++i)
    s[i] = c;
  <span style="color: #00ffff;">if</span> (c == <span style="color: #ffa07a;">'\n'</span>) {
    s[i] = c;
    ++i;
  }
  s[i] = <span style="color: #ffa07a;">'\0'</span>;
  <span style="color: #00ffff;">return</span> i;
}

<span style="color: #ff4500;">/* </span><span style="color: #ff4500;">copy: copia 'from' en 'to'; supone que to es suficientemente grande </span><span style="color: #ff4500;">*/</span>
<span style="color: #98fb98;">void</span> <span style="color: #87cefa;">copy</span>(<span style="color: #98fb98;">char</span> <span style="color: #eedd82;">to</span>[], <span style="color: #98fb98;">char</span> <span style="color: #eedd82;">from</span>[])
{
  <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">i</span>;
  i = 0;
  <span style="color: #00ffff;">while</span> ((to[i] = from[i]) != <span style="color: #ffa07a;">'\0'</span>)
    ++i;
}
</pre>
</div>

<p>
Las funciones <code>getline</code> y <code>copy</code> estan declaradas al principio del
programa, que se supone esta contenido en un archivo.
</p>

<p>
<code>main</code> y <code>getline</code> se comunican a traves de un par de argumentos y
un valor de retorno. En <code>getline</code> los argumentos se declaran en la
linea
</p>

<div class="org-src-container">
<pre class="src src-c"><span style="color: #98fb98;">int</span> <span style="color: #87cefa;">getline</span>(<span style="color: #98fb98;">char</span> <span style="color: #eedd82;">s</span>[], <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">lim</span>);
</pre>
</div>

<p>
que especifica que el primer argumento, <code>s</code>, es un arreglo, y el
segundo, <code>lim</code>, es un entero. El proposito de proporcionar el
tamaño de un arreglo es fijar espacio de almacenamiento
contiguo. La longitud del arreglo <code>s</code> no es necesaria en <code>getline</code>,
puesto que su tamaño se fija en <code>main</code>. En <code>getline</code> se utiliza
<code>return</code> para regresar un valor a quien lo llama, tal como hizo la
funcion <code>power</code>. Esta linea tambien declara que <code>getline</code> regresa
un <code>int</code>; puesto que <code>int</code> es el valor de retorno por omision,
puede suprimirse.
</p>

<p>
Algunas funciones regresan un valor util; otras, como <code>copy</code>, se
emplean unicamente por su efecto y no regresan un valor. El tipo de
retorno de <code>copy</code> es <code>void</code>, el cual establece explicitamente que
ningun valor se regresa.
</p>

<p>
En <code>getline</code> se coloca el caracter '\0' (<i>caracter nulo</i>, cuyo
valor es cero) al final del arreglo que esta creando, para marcar
el fin de la cadena de caracteres. Esta convencion tambien se
utiliza por el lenguaje C: cuando una constante de caracter como:
</p>

<div class="org-src-container">
<pre class="src src-c"><span style="color: #ffa07a;">"hola\n"</span>
</pre>
</div>

<p>
aparece en un programa en C, se almacena como un arreglo que
contiene los caracteres de la cadena y termina con un '\0' para
marcar el fin.
</p>


<div class="figure">
<p><img src="img/img_01.09.png" alt="img_01.09.png" />
</p>
</div>

<p>
La especificacion de formato <code>%s</code> dentro de <a href="#org0458a76"><code>printf</code></a> espera que el
argumento correspondiente sea una cadena representada de este modo;
<code>copy</code> tambien se basa en el hecho de que su argumento de entrada
se termina con '\0', y copia este caracter dentro del argumento de
salida. (Todo esto implica que '\0', no es parte de un texto
normal.)
</p>

<p>
Es util mencionar de paso que aun un programa tan pequeño como este
presenta algunos problemas de diseño. Por ejemplo, ¿que debe hacer
<code>main</code> si encuentra una linea que es mayor que su limite?
<code>getline</code> trabaja en forma segura, en ese caso detiene la
recopilacion cuando el arreglo esta lleno, aunque no encuentre el
caracter nueva linea. Probando la longitud y el ultimo caracter
devuelto, <code>main</code> puede determinar si la linea fue demasiado larga,
y entonces realiza el tratamiento que se desee. Por brevedad, hemos
ignorado el asunto.
</p>

<p>
Para un usuario de <code>getline</code> no existe forma de saber con
anticipacion cuan larga podra ser una linea de entrada, por lo que
<code>getline</code> revisa un posible desbordamiento (<i>overflow</i>). Por otro
lado, el usuario de <code>copy</code> ya conoce (o lo puede averiguar) cual es
el tamaño de la cadena, por lo que decidimos no agregar
comprobacion de errores en ella.
</p>

<p>
<b>Ejercicio 1-16</b>. Corrija la rutina principal del programa de la
linea mas larga de modo que imprima correctamente la longitud de
lineas de entrada arbitrariamente largas, y tanto texto como sea
posible.
</p>

<p>
<b>Ejercicio 1-17</b>. Escriba un programa que imprima todas las lineas de
entrada que sean mayores de 80 caracteres.
</p>

<p>
<b>Ejercicio 1-18</b>. Escriba un programa que elimine los blancos y los
tabuladores que esten al final de cada linea de entrada, y que
borre completamente las lineas en blanco.
</p>

<p>
<b>Ejercicio 1-19</b>. Escriba una funcion <code>reverse(s)</code> que invierta la
cadena de caracteres <code>s</code>. Usela para escribir un programa que
invierta su entrada, linea a linea.
</p>
</div>
</div>

<div id="outline-container-org4e01f7d" class="outline-3">
<h3 id="org4e01f7d">1.10 Variables externas y alcance                                  <a id="orgf6e6734"></a></h3>
<div class="outline-text-3" id="text-org4e01f7d">
<p>
Las variables que estan en <code>main</code>, tal como <code>line</code>, <code>longest</code>,
etc., son privadas o locales a ella. Debido a que son declaradas
dentro de <code>main</code>, ninguna otra funcion puede tener acceso directo a
ellas. Lo mismo tambien es valido para variables de otras
funciones; por ejemplo, la variable <code>i</code> en <code>getLine</code> no tiene
relacion con la <code>i</code> que esta en <code>copy</code>. Cada variable local de una
funcion comienza a existir solo cuando se llama a la funcion, y
desaparece cuando la funcion termina. Esto es por lo que tales
variables son conocidas como variables <i>automaticas</i>, siguiendo la
terminologia de otros lenguajes. Aqui se utilizara en adelante el
termino automatico para hacer referencia a esas variables
locales. (En el <a href="#org05a38fc">capitulo 4</a> se discute la categoria de
almacenamiento estatica, en la que las variables locales si
conservan sus valores entre llamadas.)
</p>

<p>
Debido a que las variables locales aparecen y desaparecen con la
invocacion de funciones, no retienen sus valores entre dos llamadas
sucesivas, y deben ser inicializadas explicitamente en cada
entrada. De no hacerlo, contendran "basura".
</p>

<p>
Como una alternativa a las variables automaticas, es posible
definir variables que son <i>externas</i> a todas las funciones, esto
es, variables a las que toda funcion puede tener acceso por su
nombre. (Este mecanismo es parecido al <code>COMMON</code> de Fortran o a las
variables de Pascal declaradas en el bloque mas exterior.) Debido a
que es posible tener acceso global a las variables externas, estas
pueden ser usadas en lugar de listas de argumentos para comunicar
datos entre funciones. Ademas, puesto que las variables externas se
mantienen permanentemente en existencia, en lugar de aparecer y
desaparecer cuando se llaman y terminan las funciones, mantienen
sus valores aun despues de que regresa la funcion que los fijo.
</p>

<p>
Una variable externa debe <i>definirse</i>, exactamente una vez, fuera de
cualquier funcion; esto fija un espacio de almacenamiento para
ella. La variable tambien debe <i>declararse</i> en cada funcion que desee
tener acceso a ella; esto establece el tipo de la variable. La
declaracion debe ser una proposicion <code>extern</code> explicita, o bien puede
estar implicita en el contexto. Para concretar la discusion,
reescribamos el programa de la linea mas larga con <code>line</code>, <code>longest</code> y
<code>max</code> como variables externas. Esto requiere cambiar las llamadas,
declaraciones y cuerpos de las tres funciones.
</p>

<div class="org-src-container">
<pre class="src src-c"><span style="color: #b0c4de;">#include</span> <span style="color: #ffa07a;">&lt;stdio.h&gt;</span>

<span style="color: #b0c4de;">#define</span> <span style="color: #eedd82;">MAXLINE</span> 1000     <span style="color: #ff4500;">/* </span><span style="color: #ff4500;">maximo tama&#241;o de una linea de entrada  </span><span style="color: #ff4500;">*/</span>

<span style="color: #98fb98;">int</span> <span style="color: #eedd82;">max</span>;                 <span style="color: #ff4500;">/* </span><span style="color: #ff4500;">maxima longitud vista hasta el momento </span><span style="color: #ff4500;">*/</span>
<span style="color: #98fb98;">char</span> <span style="color: #eedd82;">line</span>[MAXLINE];      <span style="color: #ff4500;">/* </span><span style="color: #ff4500;">linea de entrada actual                </span><span style="color: #ff4500;">*/</span>
<span style="color: #98fb98;">char</span> <span style="color: #eedd82;">longest</span>[MAXLINE];   <span style="color: #ff4500;">/* </span><span style="color: #ff4500;">la linea mas larga se guarda aqui      </span><span style="color: #ff4500;">*/</span>

<span style="color: #98fb98;">int</span> <span style="color: #87cefa;">getLine</span>(<span style="color: #98fb98;">void</span>);
<span style="color: #98fb98;">void</span> <span style="color: #87cefa;">copy</span>(<span style="color: #98fb98;">void</span>);

<span style="color: #ff4500;">/* </span><span style="color: #ff4500;">imprime la linea de entrada mas larga; version especializada </span><span style="color: #ff4500;">*/</span>
<span style="color: #87cefa;">main</span>()
{
  <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">len</span>;
  <span style="color: #00ffff;">extern</span> <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">max</span>;
  <span style="color: #00ffff;">extern</span> <span style="color: #98fb98;">char</span> <span style="color: #eedd82;">longest</span>[];

  max = 0;
  <span style="color: #00ffff;">while</span> ((len = getLine()) &gt; 0)
    <span style="color: #00ffff;">if</span> (len &gt; max) {
      max = len;
      copy();
    }
  <span style="color: #00ffff;">if</span> (max &gt; 0)           <span style="color: #ff4500;">/* </span><span style="color: #ff4500;">hubo una linea                         </span><span style="color: #ff4500;">*/</span>
    printf(<span style="color: #ffa07a;">"%s"</span>, longest);
  <span style="color: #00ffff;">return</span> 0;
}

<span style="color: #ff4500;">/* </span><span style="color: #ff4500;">getLine: version especializada </span><span style="color: #ff4500;">*/</span>
<span style="color: #98fb98;">int</span> <span style="color: #87cefa;">getLine</span>(<span style="color: #98fb98;">void</span>)
{
  <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">c</span>, <span style="color: #eedd82;">i</span>;
  <span style="color: #00ffff;">extern</span> <span style="color: #98fb98;">char</span> <span style="color: #eedd82;">line</span>[];

  <span style="color: #00ffff;">for</span> (i = 0; i &lt; MAXLINE - 1
         &amp;&amp; (c=getchar()) != EOF &amp;&amp; c != <span style="color: #ffa07a;">'\n'</span>; ++i)
    line[i] = c;

  <span style="color: #00ffff;">if</span> (c == <span style="color: #ffa07a;">'\n'</span>) {
    line[i] = c;
    ++i;
  }

  line[i] = <span style="color: #ffa07a;">'\0'</span>;
  <span style="color: #00ffff;">return</span> i;
}

<span style="color: #ff4500;">/* </span><span style="color: #ff4500;">copy: version especializada </span><span style="color: #ff4500;">*/</span>
<span style="color: #98fb98;">void</span> <span style="color: #87cefa;">copy</span>(<span style="color: #98fb98;">void</span>)
{
  <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">i</span>;
  <span style="color: #00ffff;">extern</span> <span style="color: #98fb98;">char</span> <span style="color: #eedd82;">line</span>[], <span style="color: #eedd82;">longest</span>[];

  i = 0;
  <span style="color: #00ffff;">while</span> ((longest[i] = line[i]) != <span style="color: #ffa07a;">'\0'</span>)
    ++i;
}
</pre>
</div>

<p>
Las variables externas de <code>main</code>, <code>getLine</code> y <code>copy</code> estan
definidas en las primeras lineas del ejemplo anterior, lo que
establece su tipo y causa que se les asigne espacio de
almacenamiento. Desde el punto de vista sintactico, las
definiciones externas son exactamente como las definiciones de
variables locales, pero puesto que ocurren fuera de las funciones,
las variables son externas. Antes de que una funcion pueda usar una
variable externa, se debe hacer saber el nombre de la variable a la
funcion. Una forma de hacer esto es escribir una declaracion
<code>extern</code> dentro de la funcion; la declaracion es la misma que
antes, excepto por la palabra reservada <code>extern</code>.
</p>

<p>
Bajo ciertas circunstancias, la declaracion <code>extern</code> se puede
omitir. Si la definicion de una variable externa ocurre dentro del
archivo fuente antes de su uso por una funcion en particular,
entonces no es necesario el uso de una declaracion <code>extern</code> dentro
de la funcion. La declaracion <code>extern</code> en <code>main</code>, <code>getLine</code> y
<code>copy</code> es, por lo tanto, redundante. De hecho, una practica comun,
es poner las definiciones de todas las variables externas al
principio del archivo fuente y despues omitir todas las
declaraciones <code>extern</code>.
</p>

<p>
Si el programa esta dividido en varios archivos fuente y una
variable se define en <i>archivo1</i> y se utiliza en <i>archivo2</i> y
<i>archivo3</i>, entonces se necesitan declaraciones <code>extern</code> en
<i>archivo2</i> y <i>archivo3</i> para conectar las ocurrencias de la
variable. La practica comun es reunir declaraciones <code>extern</code> de
variables y funciones en un archivo separado, llamado
historicamente <i>header</i>, que es incluido por <code>#include</code> al
principio de cada archivo fuente. El sufijo <code>.h</code> se usa por
convencion para nombres de headers. Las funciones de la biblioteca
estandar, por ejemplo, estan declaradas en headers como
<code>&lt;stdio.h&gt;</code>. Este tema se trata ampliamente en el <a href="#org05a38fc">capitulo 4</a>, y la
biblioteca en el <a href="#orgf1abb1c">capitulo 7</a> y en el <a href="#org89d4232">apendice B</a>.
</p>

<p>
Puesto que las versiones especializadas de <code>getLine</code> y <code>copy</code> no
tienen argumentos, la logica sugeriria que sus prototipos al
principio del archivo deben ser <code>getLine()</code> y <code>copy()</code>. Pero por
compatibilidad con programas de C anteriores, el estandar toma a
una lista vacia como una declaracion al viejo estilo, y suspende
toda revision de listas de argumentos; para una lista
explicitamente vacia debe emplearse la palabra <code>void</code>. Esto se
discutira en el <a href="#org05a38fc">capitulo 4</a>.
</p>

<p>
Se debe notar que empleamos cuidadosamente las palabras
<i>definicion</i> y <i>declaracion</i> cuando nos referimos a variables
externas en esta seccion. La palabra "definicion" se refiere al
lugar donde se crea la variable o se le asigna un lugar de
almacenamiento; "declaracion" se refiere al lugar donde se
establece la naturaleza de la variable pero no se le asigna
espacio.
</p>

<p>
A proposito, existe una tendencia a convertir todo en variables
<code>extern</code>, debido a que aparentemente simplifica las comunicaciones
&#x2013;las listas de argumentos son cortas y las variables existen
siempre, cuando se les requiere. Pero las variables externas
existen siempre, aun cuando no hacen falta. Descansar fuertemente
sobre variables externas es peligroso, puesto que lleva a programas
cuyas conexiones entre datos no son completamente obvias &#x2013;las
variables pueden cambiarse en forma inesperada e inadvertida, y el
programa es dificil de modificar. La segunda version del programa
de la linea mayor es inferior a la primera, en parte por las
anteriores razones y en parte porque destruye la generalidad de dos
utiles funciones, introduciendo en ellas los nombres de las
variables que manipula.
</p>

<p>
Hasta este punto hemos descrito lo que podria llamarse los
fundamentos convencionales de C. Con estos fundamentos, es posible
escribir programas utiles de tamaño considerable, y probablemente
seria una buena idea hacer una pausa suficientemente grande para
realizarlos. Estos ejercicios sugieren programas de complejidad
algo mayor que los anteriores del capitulo.
</p>

<p>
<b>Ejercicio 1-20</b>. Escriba un programa <code>detab</code> que reemplace
tabuladores de la entrada con el numero apropiado de blancos para
espaciar hasta el siguiente paro de tabulacion. Considere un
conjunto fijo de paros de tabulacion, digamos cada \[n\]
columnas. ¿Debe ser \[n\] una variable o un parametro simbolico?
</p>

<p>
<b>Ejercicio 1-21</b>. Escriba un programa <code>entab</code> que reemplace cadenas
de blancos por el minimo numero de tabuladores y blancos para
obtener el mismo espaciado. Considere los paros de tabulacion de
igual manera que para <code>detab</code>. Cuando un tabulador o un simple
espacio en blanco fuese suficiente para alcanzar un paro de
tabulacion, ¿a cual se le debe dar preferencia?
</p>

<p>
<b>Ejercicio 1-22</b>. Escriba un programa para "doblar" lineas grandes
de entrada en dos o mas lineas mas cortas despues del ultimo
caracter no blanco que ocurra antes de la n-esima columna de
entrada. Asegurese de que su programa se comporte apropiadamente
con lineas muy largas, y de que no hay blancos o tabuladores antes
de la columna especificada.
</p>

<p>
<b>Ejercicio 1-23</b>. Escriba un programa para eliminar todos los
comentarios de un programa en C. No olvide manejar apropiadamente
las cadenas entre comillas y las constantes de caracter. Los
comentarios de C no se anidan.
</p>

<p>
<b>Ejercicio 1-24</b>. Escriba un programa para revisar los errores de
sintaxis rudimentarios de un programa en C, como parentesis, llaves
y corchetes no alineados. No olvide las comillas ni los apostrofos,
las secuencias de escape y los comentarios. (Este programa es
dificil si se hace completamente general.)
</p>
</div>
</div>
</div>

<div id="outline-container-orgf845bad" class="outline-2">
<h2 id="orgf845bad">capitulo 2: Tipos, operadores y expresiones                         <a id="org29d5b55"></a></h2>
<div class="outline-text-2" id="text-orgf845bad">
<p>
Las variables y las constantes son los objetos de datos basicos que
se manipulan en un programa. Las declaraciones muestran las
variables que se van a utilizar y establecen el tipo que tienen y
algunas veces cuales son sus valores iniciales. Los operadores
especifican lo que se hara con las variables. Las expresiones
combinan variables y constantes para producir nuevos valores. El
tipo de un objeto determina el conjunto de valores que puede tener y
que operaciones se pueden realizar sobre el. Estos son los temas de
este capitulo.
</p>

<p>
El estandar ANSI ha hecho muchos pequeños cambios y agregados a los
tipos basicos y a las expresiones. Ahora hay formas <code>signed</code> y
<code>unsigned</code> de todos los tipos enteros, y notaciones para constantes
sin signo y constantes de caracter hexadecimales. Las operaciones de
punto flotante pueden hacerse en precision sencilla; tambien hay un
tipo <code>long double</code> para precision extendida. Las constantes de
cadena pueden concatenarse al tiempo de compilacion. Las
enumeraciones son ya parte del lenguaje, formalizando una
caracteristica pendiente por mucho tiempo. Los objetos pueden ser
declarados <code>const</code>, lo que impide que cambien. Las reglas para
conversion automatica entre tipos aritmeticos se aumentaron para
manejar el ahora mas rico conjunto de tipos.
</p>
</div>

<div id="outline-container-orge1a4f79" class="outline-3">
<h3 id="orge1a4f79">2.1  Nombres de variables                                          <a id="org9f27d5c"></a></h3>
<div class="outline-text-3" id="text-orge1a4f79">
<p>
Aunque no lo mencionamos en el <a href="#orgc16243d">capitulo 1</a>, existen algunas
restricciones en los nombres de las variables y de las constantes
simbolicas. Los nombres se componen de letras y digitos; el primer
caracter debe ser una letra. El caracter de subrayado "<code>_</code>" cuenta
como una letra; algunas veces es util para mejorar la legibilidad
de nombres largos de variables. Sin embargo, no se debe comenzar
los nombres de variables con este caracter, puesto que las rutinas
de biblioteca con frecuencia usan tales nombres. Las letras
mayusculas y minusculas son distintas, de tal manera que x y X son
dos nombres diferentes. La practica tradicional de C es usar letras
minusculas para nombres de variables, y todo en mayusculas para
constantes simbolicas.
</p>

<p>
Al menos los primeros 31 caracteres de un nombre interno son
significativos, para nombres de funciones y variables externas el
numero puede ser menor que 31, puesto que los nombres externos los
pueden usar los ensambladores y los cargadores, sobre los que el
lenguaje no tiene control. Para nombres externos, el estandar
garantiza distinguir solo para 6 caracteres y sin diferenciar
mayusculas de minusculas. Las palabras clave como <code>if</code>, <code>else</code>,
<code>int</code>, <code>float</code>, etc., estan reservadas: no se pueden utilizar como
nombres de variables. Todas ellas deben escribirse con minusculas.
</p>

<p>
Es conveniente elegir nombres que esten relacionados con el
proposito de la variable, que no sea probable confundirlos
tipograficamente. Nosotros tendemos a utilizar nombres cortos
para variables locales, especialmente indices de iteraciones, y
nombres mas largos para variables externas.
</p>
</div>
</div>

<div id="outline-container-org504ea78" class="outline-3">
<h3 id="org504ea78">2.2  Tipos y tamaños de datos                                      <a id="org36459f3"></a></h3>
<div class="outline-text-3" id="text-org504ea78">
<p>
Hay unos cuantos tipos de datos basicos en C:
</p>

<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-left" />

<col  class="org-left" />
</colgroup>
<tbody>
<tr>
<td class="org-left"><code>char</code></td>
<td class="org-left">un solo byte, capaz de contener un caracter del conjunto de caracteres local.</td>
</tr>

<tr>
<td class="org-left"><code>int</code></td>
<td class="org-left">un entero, normalmente del tamaño natural de los enteros en la maquina en la que se ejecuta.</td>
</tr>

<tr>
<td class="org-left"><code>float</code></td>
<td class="org-left">punto flotante de precision normal.</td>
</tr>

<tr>
<td class="org-left"><code>double</code></td>
<td class="org-left">punto flotante de doble precision.</td>
</tr>
</tbody>
</table>

<p>
Ademas, existen algunos calificadores que se aplican a estos tipos
basicos, <code>short</code> y <code>long</code> se aplican a enteros:
</p>

<div class="org-src-container">
<pre class="src src-c"><span style="color: #98fb98;">short</span> <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">sh</span>;
<span style="color: #98fb98;">long</span> <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">counter</span>;
</pre>
</div>

<p>
La palabra <code>int</code> puede omitirse de tales declaraciones, lo que
tipicamente se hace.
</p>

<p>
La intencion es que <code>short</code> y <code>long</code> puedan proporcionar diferentes
longitudes de enteros donde sea practico; <code>int</code> sera normalmente el
tamaño natural para una maquina en particular. A menudo <code>short</code> es
de 16 bits y <code>long</code> de 32; <code>int</code> es de 16 o de 32 bits. Cada
compilador puede seleccionar libremente los tamaños apropiados para
su propio hardware, sujeto solo a la restriccion de que los shorts
e ints son, por lo menos de 16 bits, los <code>long</code> son por lo menos de
32 bits y el <code>short</code> no es mayor que <code>int</code>, el cual a su vez no es
mayor que <code>long</code>.
</p>

<p>
El calificador <code>signed</code> o <code>unsigned</code> puede aplicarse a <code>char</code> o a
cualquier entero. Los numeros <code>unsigned</code> son siempre positivos o
cero y obedecen las leyes de la aritmetica modulo 2<sup>n</sup>, donde <code>n</code> es
el numero de bits en el tipo. Asi, por ejemplo, si los <code>char</code> son
de 8 bits, las variables <code>unsigned char</code> tienen valores tentre <code>0</code>
y <code>255</code>, en tanto que las variables <code>signed char</code> tienen valores
entre <code>-128</code> y <code>127</code> (en una maquina de complemento a dos). El
hecho de que los chars ordinarios sean con signo o sin el depende
de la maquina, pero los caracteres que se pueden imprimir son
siempre positivos.
</p>

<p>
El tipo <code>long double</code> especifica punto flotante de precision
extendida. Igual que con los enteros, los tamaños de objetos de
punto flotante se definen en la implantacion; <code>float</code>, <code>double</code> y
<code>long double</code> pueden representar uno, dos o tres tamaños distintos.
</p>

<p>
Los archivos de encabezado headers estandar <code>&lt;limits.h&gt;</code> y
<code>&lt;float.h&gt;</code> contienen constantes simbolicas para todos esos
tamaños, junto con otras propiedades de la maquina y del
compilador, los cuales se discuten en el <a href="#org89d4232">apendice B</a>.
</p>

<p>
<b>Ejercicio 2-1</b>. Escriba un programa para determinar los rangos de
variables <code>char</code>, <code>short</code>, <code>int</code> y <code>long</code>, tanto <code>signed</code> como
<code>unsigned</code>, imprimiendo los valores apropiados de los <i>headers</i>
estandar y por calculo directo. Es mas dificil si los calcula:
determine los rangos de los varios tipos de punto flotante.
</p>
</div>
</div>

<div id="outline-container-orgda3bc12" class="outline-3">
<h3 id="orgda3bc12">2.3  Constantes                                                    <a id="orgc43a3e4"></a></h3>
<div class="outline-text-3" id="text-orgda3bc12">
<p>
Una constante entera como <code>1234</code> es un <code>int</code>. Una constante <code>long</code>
se escribe con una <code>l</code> (ele) o <code>L</code> terminal, como en <code>123456789L</code>;
un entero demasiado grande para caber dentro de un <code>int</code> tambien
sera tomado como <code>long</code>. Las constantes sin signo se escriben con
una <code>u</code> o <code>U</code>, terminal y el sufijo <code>ul</code> o <code>UL</code> indica <code>unsigned
   long</code>.
</p>

<p>
Las constantes de punto flotante contienen un punto decimal
(<code>123.4</code>) o un exponente (<code>1e-2</code>) o ambos; su tipo es <code>double</code>, a
menos que tengan sufijo. Los sufijos <code>f</code> o <code>F</code> indican una
constante <code>float</code>; <code>l</code> o <code>L</code> indican un <code>long double</code>.
</p>

<p>
El valor de un entero puede especificarse en forma octal o
hexadecimal en lugar de decimal. Un <code>0</code> (cero) al principio en una
constante entera significa octal; <code>0x</code> o <code>0X</code> al principio
significa hexadecimal. Por ejemplo, el decimal <code>31</code> puede
escribirse como <code>037</code> en octal y <code>0xlf</code> o <code>0X1F</code> en
hexadecimal. Las constantes octales y hexadecimales tambien pueden
ser seguidas por <code>L</code> para convertirlas en <code>long</code> y <code>U</code> para
hacerlas <code>unsigned</code>: <code>0XFUL</code> es una constante <code>unsigned long</code> con
valor de <code>15</code> en decimal.
</p>

<p>
Una <i>constante de caracter</i> es un entero, escrito como un caracter
dentro de apostrofos, tal como 'x'. El valor de una constante de
caracter es el valor numerico del caracter en el conjunto de
caracteres de la maquina. Por ejemplo, en el conjunto de caracteres
ASCII el caracter constante '0' tiene el valor de <code>48</code>, el cual no
esta relacionado con el valor numerico <code>0</code>. Si escribimos '0' en
vez de un valor numerico como <code>48</code> que depende del conjunto de
caracteres, el programa es independiente del valor particular y mas
facil de leer. Las constantes de caracter participan en operaciones
numericas tal como cualesquier otros enteros, aunque se utilizan
mas comunmente en comparaciones con otros caracteres.
</p>

<p>
Ciertos caracteres pueden ser representados en constante de
caracter y de cadena, Por medio de secuencias de escape como <code>\n</code>
(nueva linea); esas secuencias se ven como dos caracteres, pero
representan solo uno. Ademas, un patron de bits arbitrario de
tamaño de un byte puede ser especificado por
</p>

<div class="org-src-container">
<pre class="src src-c"><span style="color: #ffc0cb; font-weight: bold;">'</span>\ooo<span style="color: #ffc0cb; font-weight: bold;">'</span>
</pre>
</div>

<p>
en donde <code>ooo</code> son de uno a tres digitos octales (0&#x2026;7) o por
</p>

<div class="org-src-container">
<pre class="src src-c"><span style="color: #ffc0cb; font-weight: bold;">'</span>\xhh<span style="color: #ffc0cb; font-weight: bold;">'</span>
</pre>
</div>

<p>
en donde <code>hh</code> son uno o mas digitos hexadecimales (0&#x2026;9, a&#x2026;f,
A&#x2026;F). Asi podriamos escribir
</p>

<div class="org-src-container">
<pre class="src src-c"><span style="color: #b0c4de;">#define</span> <span style="color: #eedd82;">VTAB</span> <span style="color: #ffc0cb; font-weight: bold;">'</span>\013<span style="color: #ffc0cb; font-weight: bold;">'</span> <span style="color: #ff4500;">/* </span><span style="color: #ff4500;">tab vertical ASCII     </span><span style="color: #ff4500;">*/</span>
<span style="color: #b0c4de;">#define</span> <span style="color: #eedd82;">BELL</span> <span style="color: #ffc0cb; font-weight: bold;">'</span>\007<span style="color: #ffc0cb; font-weight: bold;">'</span> <span style="color: #ff4500;">/* </span><span style="color: #ff4500;">caracter campana ASCII </span><span style="color: #ff4500;">*/</span>
</pre>
</div>

<p>
o, en hexadecimal,
</p>

<div class="org-src-container">
<pre class="src src-c"><span style="color: #b0c4de;">#define</span> <span style="color: #eedd82;">VTAB</span> <span style="color: #ffc0cb; font-weight: bold;">'</span>\xb<span style="color: #ffc0cb; font-weight: bold;">'</span> <span style="color: #ff4500;">/* </span><span style="color: #ff4500;">tab vertical ASCII     </span><span style="color: #ff4500;">*/</span>
<span style="color: #b0c4de;">#define</span> <span style="color: #eedd82;">BELL</span> <span style="color: #ffc0cb; font-weight: bold;">'</span>\x7<span style="color: #ffc0cb; font-weight: bold;">'</span> <span style="color: #ff4500;">/* </span><span style="color: #ff4500;">caracter campana ASCII </span><span style="color: #ff4500;">*/</span>
</pre>
</div>

<p>
El conjunto completo de secuencias de escape es
</p>

<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-left" />

<col  class="org-left" />
</colgroup>
<tbody>
<tr>
<td class="org-left"><code>\a</code></td>
<td class="org-left">caracter de alarma (campana)</td>
</tr>

<tr>
<td class="org-left"><code>\b</code></td>
<td class="org-left">retroceso</td>
</tr>

<tr>
<td class="org-left"><code>\f</code></td>
<td class="org-left">avance de hoja</td>
</tr>

<tr>
<td class="org-left"><code>\n</code></td>
<td class="org-left">nueva linea</td>
</tr>

<tr>
<td class="org-left"><code>\r</code></td>
<td class="org-left">regreso de carro</td>
</tr>

<tr>
<td class="org-left"><code>\t</code></td>
<td class="org-left">tabulador horizontal</td>
</tr>

<tr>
<td class="org-left"><code>\v</code></td>
<td class="org-left">tabulador vertical</td>
</tr>

<tr>
<td class="org-left"><code>\\</code></td>
<td class="org-left">diagonal invertida</td>
</tr>

<tr>
<td class="org-left"><code>\?</code></td>
<td class="org-left">interrogacion</td>
</tr>

<tr>
<td class="org-left">\'</td>
<td class="org-left">apostrofo</td>
</tr>

<tr>
<td class="org-left">\"</td>
<td class="org-left">comillas</td>
</tr>

<tr>
<td class="org-left"><code>\ooo</code></td>
<td class="org-left">numero octal</td>
</tr>

<tr>
<td class="org-left"><code>\xhh</code></td>
<td class="org-left">numero hexadecimal</td>
</tr>
</tbody>
</table>

<p>
La constante de caracter '\0' representa el caracter con valor
cero, el caracter nulo. '\0' a menudo se escribe en vez de <code>0</code> para
enfatizar la naturaleza de caracter de algunas expresiones, pero el
valor numerico es precisamente <code>0</code>.
</p>

<p>
Una <i>expresion constante</i> es una expresion que solo inmiscuye
constantes. Tales expresiones pueden ser evaluadas durante la
compilacion en vez de que se haga en tiempo de ejecucion, y por
tanto pueden ser utilizadas en cualquier lugar en que pueda
encontrarse una constante, como en
</p>

<div class="org-src-container">
<pre class="src src-c"><span style="color: #b0c4de;">#define</span> <span style="color: #eedd82;">MAXLINE</span> 1000
<span style="color: #98fb98;">char</span> <span style="color: #eedd82;">line</span> [MAXLINE + 1];
</pre>
</div>

<p>
o
</p>

<div class="org-src-container">
<pre class="src src-c"><span style="color: #b0c4de;">#define</span> <span style="color: #eedd82;">LEAP</span> 1 <span style="color: #ff4500;">/* </span><span style="color: #ff4500;">en a&#241;os bisiestos </span><span style="color: #ff4500;">*/</span>
<span style="color: #98fb98;">int</span> <span style="color: #eedd82;">days</span> [31 + 28 + LEAP + 31 + 30 + 31 + 30 + 31 + 31 + 30 + 31 + 30 + 31];
</pre>
</div>

<p>
Una <i>constante de cadena</i> o <i>cadena literal</i>, es una secuencia de
cero o mas caracteres encerrados entre comillas, como en:
</p>

<div class="org-src-container">
<pre class="src src-c"><span style="color: #ffa07a;">"Soy una cadena"</span>
</pre>
</div>

<p>
o
</p>

<div class="org-src-container">
<pre class="src src-c"><span style="color: #ffa07a;">""</span>  <span style="color: #ff4500;">/* </span><span style="color: #ff4500;">La cadena vacia </span><span style="color: #ff4500;">*/</span>
</pre>
</div>

<p>
Las comillas no son parte de la cadena, solo sirven para
delimitarla. Las mismas secuencias de escape utilizadas en
constantes de caracter se aplican en cadenas; <code>\"</code> representa el
caracter comillas. Las constantes de cadena pueden ser concatenadas
en tiempo de compilacion:
</p>

<div class="org-src-container">
<pre class="src src-c"><span style="color: #ffa07a;">"hola,"</span> <span style="color: #ffa07a;">"mundo"</span>
</pre>
</div>

<p>
es equivalente a
</p>

<div class="org-src-container">
<pre class="src src-c"><span style="color: #ffa07a;">"hola, mundo"</span>
</pre>
</div>

<p>
Esto es util para separar cadenas largas entre varias lineas
fuente.
</p>

<p>
Tecnicamente, una constante de cadena es un arreglo de
caracteres. La representacion interna de una cadena tiene un
caracter nulo '\0' al final, de modo que el almacenamiento fisico
requerido es uno mas del numero de caracteres escritos entre las
comillas. Esta representacion significa que no hay limite en cuanto
a que tan larga puede ser una cadena, pero los programas deben leer
completamente una cadena para determinar su longitud. La funcion
<code>strlen(s)</code> de la biblioteca estandar regresa la longitud de su
argumento <code>s</code> de tipo cadena de caracteres, excluyendo el '\0'
terminal. Aqui esta nuestra version:
</p>

<div class="org-src-container">
<pre class="src src-c"><span style="color: #ff4500;">/* </span><span style="color: #ff4500;">strlen: regresa la longitud de s </span><span style="color: #ff4500;">*/</span>
<span style="color: #98fb98;">int</span> <span style="color: #87cefa;">strlen</span>(<span style="color: #98fb98;">char</span> <span style="color: #eedd82;">s</span>[])
{
  <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">i</span>;

  i = 0;
  <span style="color: #00ffff;">while</span> (s[i] != <span style="color: #ffa07a;">'\0'</span>)
    ++i;
  <span style="color: #00ffff;">return</span> i;
}
</pre>
</div>


<p>
<code>strlen</code> y otras funciones para cadenas estan declaradas en el
<i>header</i> estandar <code>&lt;string.h&gt;</code>.
</p>

<p>
Se debe ser cuidadoso al distinguir entre una constante de caracter
y una cadena que contiene un solo caracter: 'x' no es lo mismo que
"x". El primero es un entero, utilizado para producir el valor
numerico de la letra <code>x</code> en el conjunto de caracteres de la
maquina. El ultimo es un arreglo de caracteres que contiene un
caracter (la letra <code>x</code>) y un '\0'.
</p>

<p>
Existe otra clase de constante, la <i>constante de enumeracion</i>. Una
enumeracion es una lista de valores enteros constantes, como en:
</p>

<div class="org-src-container">
<pre class="src src-c"><span style="color: #00ffff;">enum</span> <span style="color: #98fb98;">boolean</span> {<span style="color: #eedd82;">NO</span>, <span style="color: #eedd82;">YES</span>};
</pre>
</div>

<p>
El primer nombre en un <code>enum</code> tiene valor <code>0</code>, el siguiente <code>1</code>, y
asi sucesivamente, a menos que sean especificados valores
explicitos. Si no todos los valores son especificados, los valores
no especificados continuan la progresion a partir del ultimo valor
que si lo fue, como en el segundo de esos ejemplos:
</p>


<div class="org-src-container">
<pre class="src src-c"><span style="color: #00ffff;">enum</span> <span style="color: #98fb98;">escapes</span> { <span style="color: #eedd82;">BELL</span>    = <span style="color: #ffa07a;">'\a'</span>, <span style="color: #eedd82;">BACKSPACE</span> = <span style="color: #ffa07a;">'\b'</span>, <span style="color: #eedd82;">TAB</span>    = <span style="color: #ffa07a;">'\t'</span>,
               <span style="color: #eedd82;">NEWLINE</span> = <span style="color: #ffa07a;">'\n'</span>, <span style="color: #eedd82;">VTAB</span>      = <span style="color: #ffa07a;">'\v'</span>, <span style="color: #eedd82;">RETURN</span> = <span style="color: #ffa07a;">'\r'</span> };

<span style="color: #00ffff;">enum</span> <span style="color: #98fb98;">months</span> { <span style="color: #eedd82;">JAN</span> = 1, <span style="color: #eedd82;">FEB</span>, <span style="color: #eedd82;">MAR</span>, <span style="color: #eedd82;">APR</span>, <span style="color: #eedd82;">MAY</span>, <span style="color: #eedd82;">JUN</span>,
              <span style="color: #eedd82;">JUL</span>    , <span style="color: #eedd82;">AUG</span>, <span style="color: #eedd82;">SEP</span>, <span style="color: #eedd82;">OCT</span>, <span style="color: #eedd82;">NOV</span>, <span style="color: #eedd82;">DEC</span> };
              <span style="color: #ff4500;">/* </span><span style="color: #ff4500;">FEB = 2, MAR = 3, etc. </span><span style="color: #ff4500;">*/</span>
</pre>
</div>

<p>
Los nombres que estan en enumeraciones diferentes deben ser
distintos. Los valores no necesitan ser distintos dentro de la
misma enumeracion.
</p>

<p>
Las enumeraciones proporcionan una manera conveniente de asociar
valores constantes con nombres, una alternativa a <code>#define</code> con la
ventaja de que los valores pueden ser generados por uno. Aunque las
variables de tipos <code>enum</code> pueden ser declaradas, los compiladores
no necesitan revisar que lo que se va a almacenar en tal variable
es un valor valido para la enumeracion. No obstante, las variables
de enumeracion ofrecen la oportunidad de revisarlas y tal cosa es a
menudo mejor que <code>#define</code>. Ademas, un depurador puede ser capaz de
imprimir los valores de variables de enumeracion en su forma
simbolica.
</p>
</div>
</div>

<div id="outline-container-orga30b21f" class="outline-3">
<h3 id="orga30b21f">2.4  Declaraciones                                                 <a id="org3da362d"></a></h3>
<div class="outline-text-3" id="text-orga30b21f">
<p>
Todas las variables deben ser declaradas antes de su uso, aunque
ciertas declaraciones pueden ser hechas en forma implicita por el
contexto. Una declaracion especifica un tipo, y contiene una lista
de una o mas variables de ese tipo, como en:
</p>

<div class="org-src-container">
<pre class="src src-c"><span style="color: #98fb98;">int</span> <span style="color: #eedd82;">lower</span>, <span style="color: #eedd82;">upper</span>, <span style="color: #eedd82;">step</span>;
<span style="color: #98fb98;">char</span> <span style="color: #eedd82;">c</span>, <span style="color: #eedd82;">line</span>[1000];
</pre>
</div>

<p>
Las variables pueden ser distribuidas entre las declaraciones en
cualquier forma; la lista de arriba podria igualmente ser escrita
como:
</p>

<div class="org-src-container">
<pre class="src src-c"><span style="color: #98fb98;">int</span> <span style="color: #eedd82;">lower</span>;
<span style="color: #98fb98;">int</span> <span style="color: #eedd82;">upper</span>;
<span style="color: #98fb98;">int</span> <span style="color: #eedd82;">step</span>;
<span style="color: #98fb98;">char</span> <span style="color: #eedd82;">c</span>;
<span style="color: #98fb98;">char</span> <span style="color: #eedd82;">line</span>[1000];
</pre>
</div>

<p>
Esta ultima forma ocupa mas espacio, pero es conveniente para
agregar un comentario a cada declaracion o para modificaciones
subsecuentes.
</p>

<p>
Una variable tambien puede ser inicializada en su declaracion. Si
el nombre es seguido por un signo de igual y una expresion, la
expresion sirve como un inicializador, como en:
</p>

<div class="org-src-container">
<pre class="src src-c"><span style="color: #98fb98;">char</span> <span style="color: #eedd82;">esc</span> = <span style="color: #ffa07a;">'\\'</span>;
<span style="color: #98fb98;">int</span> <span style="color: #eedd82;">i</span> = 0;
<span style="color: #98fb98;">int</span> <span style="color: #eedd82;">lixnit</span> = MAXLINE+1;
<span style="color: #98fb98;">float</span> <span style="color: #eedd82;">eps</span> = 1.0e-5;
</pre>
</div>

<p>
Si la variable en cuestion no es automatica, la inicializacion es
efectuada solo una vez, conceptualmente antes de que el programa
inicie su ejecucion, y el inicializador debe ser una expresion
constante. Una variable automatica explicitamente inicializada es
inicializada cada vez que se entra a la funcion o bloque en que se
encuentra; el inicializador puede ser cualquier expresion. Las
variables estaticas y externas son inicializadas en cero por
omision. Las variables automaticas para las que no hay un
inicializador explicito tienen valores indefinidos (esto es,
basura).
</p>

<p>
El calificador <code>const</code> puede aplicarse a la declaracion de
cualquier variable para especificar que su valor no sera
cambiado. Para un arreglo, el calificador <code>const</code> indica que los
elementos no seran alterados.
</p>

<div class="org-src-container">
<pre class="src src-c"><span style="color: #00ffff;">const</span> <span style="color: #98fb98;">double</span> <span style="color: #eedd82;">e</span> = 2.71828182845905;
<span style="color: #00ffff;">const</span> <span style="color: #98fb98;">char</span> <span style="color: #eedd82;">msg</span>[] = <span style="color: #ffa07a;">"precaucion: "</span>;
</pre>
</div>

<p>
La declaracion <code>const</code> tambien se puede utilizar con argumentos de
tipo arreglo, para indicar que la funcion no cambia ese arreglo:
</p>

<div class="org-src-container">
<pre class="src src-c"><span style="color: #98fb98;">int</span> <span style="color: #87cefa;">strlen</span>(<span style="color: #00ffff;">const</span> <span style="color: #98fb98;">char</span>[]);
</pre>
</div>

<p>
Si se efectua un intento de cambiar un <code>const</code>, el resultado esta
definido por la implantacion.
</p>
</div>
</div>

<div id="outline-container-orga19702e" class="outline-3">
<h3 id="orga19702e">2.5  Operadores aritmeticos                                        <a id="orgbcf7c44"></a></h3>
<div class="outline-text-3" id="text-orga19702e">
<p>
Los operadores aritmeticos binarios son <code>+</code>, <code>-</code>, <code>*</code>, <code>/</code>, y el
operador modulo <code>%</code>. La division entera trunca cualquier parte
fraccionaria. La expresion:
</p>

<div class="org-src-container">
<pre class="src src-c">x % y
</pre>
</div>

<p>
produce el residuo cuando <code>x</code> es dividido entre <code>y</code>, esto es cero
cuando <code>y</code> divide a <code>x</code> exactamente. Por ejemplo, un año es
bisiesto si es divisible entre <code>4</code> pero no entre <code>100</code>, excepto
aquellos años que son divisibles entre <code>400</code>, que si son
bisiestos. Por lo tanto:
</p>

<div class="org-src-container">
<pre class="src src-c"><span style="color: #00ffff;">if</span> ((year % 4 == 0 &amp;&amp; year % 100 != 0) || year % 400 == 0)
  printf(<span style="color: #ffa07a;">"%d es un a&#241;o bisiesto\n"</span>, year);
<span style="color: #00ffff;">else</span>
  printf(<span style="color: #ffa07a;">"%d no es un a&#241;o bisiesto\n"</span>, year);
</pre>
</div>

<p>
El operador <code>%</code> no puede aplicarse a operandos <code>float</code> o
<code>double</code>. La direccion de truncamiento para <code>/</code> y el signo del
resultado de <code>%</code> son dependientes de la maquina para operandos
negativos, asi como la accion que se toma en caso de sobreflujo o
subflujo.
</p>

<p>
Los operadores binarios <code>+</code> y <code>-</code> tienen la misma precedencia, la
cual es menor que la precedencia de <code>*</code>, <code>/</code>, y <code>%</code>, que a su vez
es menor que <code>+</code> y <code>-</code> unarios. Los operadores aritmeticos se
asocian de izquierda a derecha.
</p>

<p>
La <a href="#org28d5714">tabla 2-1</a> que se encuentra al final de este capitulo, resume la
precedencia y asociatividad para todos los operadores.
</p>
</div>
</div>

<div id="outline-container-org52e7ae4" class="outline-3">
<h3 id="org52e7ae4">2.6  Operadores de relacion y logicos                              <a id="org0402ffd"></a></h3>
<div class="outline-text-3" id="text-org52e7ae4">
<p>
Los operadores de relacion son:
</p>

<div class="org-src-container">
<pre class="src src-c">&gt; &gt;= &lt; &lt;=
</pre>
</div>

<p>
Todos ellos tienen la misma precedencia. Precisamente bajo ellos en
precedencia estan los operadores de igualdad:
</p>

<div class="org-src-container">
<pre class="src src-c">== !=
</pre>
</div>

<p>
Los operadores de relacion tienen precedencia inferior que los
operadores aritmeticos, asi que una expresion como <code>i &lt; lim-1</code> se
toma como <code>i &lt; (lim-1)</code>, como se esperaria.
</p>

<p>
Mas interesantes son los operadores logicos <code>&amp;&amp;</code> y <code>||</code> Las
expresiones conectadas por <code>&amp;&amp;</code> o <code>||</code> son evaluadas de izquierda a
derecha, y la evaluacion se detiene tan pronto como se conoce el
resultado verdadero o falso. La mayoria de los programas en C
descansan sobre esas propiedades. Por ejemplo, aqui esta un ciclo
de la funcion de entrada <code>getline</code> que escribimos en el <a href="#orgc16243d">capitulo 1</a>:
</p>


<div class="org-src-container">
<pre class="src src-c"><span style="color: #00ffff;">for</span> (i=0; i &lt; lim-1 &amp;&amp; (c=getchar()) != <span style="color: #ffa07a;">'\n'</span> &amp;&amp; c != EOF; ++i)
  <span style="color: #98fb98;">s</span>[i] = c;
</pre>
</div>

<p>
Antes de leer un nuevo caracter es necesario verificar que hay
espacio para almacenarlo en el arreglo <code>s</code>, asi que la prueba <code>i &lt;
   lim-1</code> debe hacerse primero. Ademas, si esta prueba falla, no
debemos seguir y leer otro caracter.
</p>

<p>
De manera semejante, seria desafortunado si <code>c</code> fuese probada
contra <code>EOF</code> antes de que se llame a <a href="#org4d38061"><code>getchar</code></a>; por lo tanto, la
llamada y la asignacion deben ocurrir antes de que se pruebe el
caracter <code>c</code>.
</p>

<p>
La precedencia de <code>&amp;&amp;</code> es mas alta que la de <code>||</code>, y ambas son
menores que los operadores de relacion y de asignacion, asi que
expresiones como:
</p>

<div class="org-src-container">
<pre class="src src-c">i &lt; lim-1 &amp;&amp; (c = getchar()) != <span style="color: #ffa07a;">'\n'</span> &amp;&amp; c != EOF
</pre>
</div>

<p>
no requieren de parentesis adicionales. Puesto que la precedencia
de <code>!=</code> es superior que la asignacion, los parentesis se necesitan
en:
</p>

<div class="org-src-container">
<pre class="src src-c">(c = getchar()) != <span style="color: #ffa07a;">'\n'</span>
</pre>
</div>

<p>
para obtener el resultado deseado de asignacion a <code>c</code> y despues
comparacion con '\n'.
</p>

<p>
Por definicion, el valor numerico de una expresion de relacion <code>or</code>
logica es <code>1</code> si la relacion es verdadera, y <code>0</code> si la relacion es
falsa.
</p>

<p>
El operador unario de negacion <code>!</code> convierte a un operando que no
es cero en <code>0</code>, y a un operando cero en <code>1</code>. Un uso comun de <code>!</code> es
en construcciones como:
</p>

<div class="org-src-container">
<pre class="src src-c"><span style="color: #00ffff;">if</span> (!valido)
</pre>
</div>

<p>
en lugar de:
</p>

<div class="org-src-container">
<pre class="src src-c"><span style="color: #00ffff;">if</span> (valido == 0)
</pre>
</div>

<p>
Es dificil generalizar acerca de cual es la mejor. Construcciones
como <code>!valido</code> se leen en forma agradable ("si no es valido"), pero
otras mas complicadas pueden ser dificiles de entender.
</p>

<p>
<b>Ejercicio 2-2</b>. Escriba un ciclo equivalente a la iteracion <code>for</code>
anterior sin usar <code>&amp;&amp;</code> o <code>||</code>.
</p>
</div>
</div>

<div id="outline-container-orgdf5ae32" class="outline-3">
<h3 id="orgdf5ae32">2.7  Conversiones de tipo                                          <a id="orgd14f820"></a></h3>
<div class="outline-text-3" id="text-orgdf5ae32">
<p>
Cuando un operador tiene operandos de tipos diferentes, estos se
convierten a un tipo comun de acuerdo con un reducido numero de
reglas. En general, las unicas conversiones automaticas son
aquellas que convierten un operando "angosto" en uno "amplio" sin
perdida de informacion, tal como convertir un entero a punto
flotante en una expresion como <code>f + i</code>. Las expresiones que no
tienen sentido, como utilizar un <code>float</code> como subindice, no son
permitidas. Las expresiones que podrian perder informacion, como
asignar un tipo mayor a uno mas corto, o un tipo de punto flotante
a un entero, pueden producir una advertencia, pero no son ilegales.
</p>

<p>
Un <code>char</code> solo es un entero pequeño, por lo que los <code>char</code> se
pueden utilizar libremente en expresiones aritmeticas. Esto permite
una flexibilidad considerable en ciertas clases de transformacion
de caracteres. Una es ejemplificada con esta ingenua implantacion
de la funcion <a href="#orgdd02576"><code>atoi</code></a>, que convierte una cadena de digitos en su
equivalente numerico.
</p>

<div class="org-src-container">
<pre class="src src-c"><span style="color: #ff4500;">/* </span><span style="color: #ff4500;">atoi: convierte s en entero </span><span style="color: #ff4500;">*/</span>
<span style="color: #98fb98;">int</span> <span style="color: #87cefa;">atoi</span>(<span style="color: #98fb98;">char</span> <span style="color: #eedd82;">s</span>[])
{
  <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">i</span>, <span style="color: #eedd82;">n</span>;

  n = 0;
  <span style="color: #00ffff;">for</span> (i = 0; s[i] &gt;= <span style="color: #ffa07a;">'0'</span> &amp;&amp; s[i] &lt;= <span style="color: #ffa07a;">'9'</span>; ++i)
    n = 10 * n + (s[i] - <span style="color: #ffa07a;">'0'</span>);
  <span style="color: #00ffff;">return</span> n;
}
</pre>
</div>

<p>
Tal como se discutio en el <a href="#orgc16243d">capitulo 1</a>, la expresion
</p>

<div class="org-src-container">
<pre class="src src-c"><span style="color: #98fb98;">s</span>[i] - <span style="color: #ffa07a;">'0'</span>
</pre>
</div>

<p>
da el valor numerico del caracter almacenado en <code>s[i]</code>, debido a
que los valores de '0', '1', etc., forman una secuencia ascendente
contigua.
</p>

<p>
Otro ejemplo de conversion de <code>char</code> a <code>int</code> es la funcion <code>lower</code>,
que convierte un caracter sencillo a minuscula para el conjunto de
caracteres ASCII. Si el caracter no es una letra mayuscula, <code>lower</code>
lo regresa sin cambio.
</p>

<div class="org-src-container">
<pre class="src src-c"><span style="color: #ff4500;">/* </span><span style="color: #ff4500;">lower: convierte c a minuscula; solamente ASCII </span><span style="color: #ff4500;">*/</span>
<span style="color: #98fb98;">int</span> <span style="color: #87cefa;">lower</span>(<span style="color: #98fb98;">int</span> <span style="color: #eedd82;">c</span>)
{
  <span style="color: #00ffff;">if</span> (c &gt;= <span style="color: #ffa07a;">'A'</span> &amp;&amp; c &lt;= <span style="color: #ffa07a;">'Z'</span>)
    <span style="color: #00ffff;">return</span> c + <span style="color: #ffa07a;">'a'</span> - <span style="color: #ffa07a;">'A'</span>;
  <span style="color: #00ffff;">else</span>
    <span style="color: #00ffff;">return</span> c;
}
</pre>
</div>

<p>
Esto funciona para ASCII debido a que las correspondientes letras
mayusculas y minusculas estan a una distancia fija como valores
numericos y cada alfabeto es contiguo – no hay sino letras entre
<code>A</code> y <code>Z</code>. Sin embargo, esta ultima observacion no es cierta para
el conjunto de caracteres EBCDIC, asi que este codigo podria
convertir algo mas que solo letras en EBCDIC.
</p>

<p>
El <i>header</i> estandar <code>&lt;ctype.h&gt;</code>, que se describe en el <a href="#org89d4232">apendice B</a>,
define una familia de funciones que proporcionan pruebas y
conversiones independientes de los juegos de caracteres. Por
ejemplo, la funcion <code>tolower(c)</code> regresa el valor de la letra
minuscula de <code>c</code> si <code>c</code> es una mayuscula, de modo que <code>tolower</code> es
un reemplazo transportable para la funcion <code>lower</code> mostrada
antes. De modo semejante, la prueba:
</p>

<div class="org-src-container">
<pre class="src src-c">c &gt;= <span style="color: #ffa07a;">'0'</span> &amp;&amp; c &lt; = <span style="color: #ffa07a;">'9'</span>
</pre>
</div>

<p>
puede reemplazarse por
</p>

<div class="org-src-container">
<pre class="src src-c"><span style="color: #87cefa;">isdigit</span>(c)
</pre>
</div>

<p>
Nosotros utilizaremos las funciones de <code>&lt;ctype.h&gt;</code> en adelante.
</p>

<p>
Existe un sutil punto acerca de la conversion de caracteres a
enteros.El lenguaje no especifica si las variables de tipo <code>char</code>
son valores con o sin signo. Cuando un <code>char</code> se convierte a <code>int</code>,
¿puede producir alguna vez un entero negativo? La respuesta varia
de una maquina a otra, reflejando diferencias en la arquitectura.
En algunas maquinas un <code>char</code> cuyo bit mas a la izquierda es <code>1</code> se
convertira a un entero negativo ("extension de signo"). En otras,
un <code>char</code> es promovido a un <code>int</code> agregando ceros del lado
izquierdo, asi que siempre es positivo.
</p>

<p>
La definicion de C garantiza que ningun caracter que este en el
conjunto estandar de caracteres de impresion de la maquina sera
negativo, de modo que esos caracteres siempre seran cantidades
positivas en las expresiones. Pero hay patrones arbitrarios de bits
almacenados en variables de tipo caracter que pueden aparecer como
negativos en algunas maquinas, aunque sean positivos en otras. Por
transportabilidad, se debe especificar <code>signed</code> o <code>unsigned</code> si se
van a almacenar datos que no son caracteres en variables tipo
<code>char</code>.
</p>

<p>
Las expresiones de relacion como <code>i &gt; j</code> y las expresiones logicas
conectadas por <code>&amp;&amp;</code> y <code>||</code> estan definidas para tener un valor de
<code>1</code> siendo verdaderas, y <code>0</code> al ser falsas. De este modo, la
asignacion
</p>

<div class="org-src-container">
<pre class="src src-c">d = c &gt;= <span style="color: #ffa07a;">'0'</span> &amp;&amp; c &lt;= <span style="color: #ffa07a;">'9'</span>
</pre>
</div>

<p>
hace <code>1</code> a <code>d</code> si <code>c</code> es un digito, y <code>0</code> si no lo es. Sin embargo,
las funciones como <code>isdigit</code> pueden regresar cualquier valor
diferente de cero como verdadero. En la parte de validacion de
<code>if</code>, <code>while</code>, <code>for</code>, etc., "verdadero" es solo "diferente de
cero", por lo que esto no hace diferencia.
</p>

<p>
Las conversiones aritmeticas implicitas trabajan como se espera. En
general, si un operador como <code>+</code> o <code>*</code> que toma dos operandos
(operador binario) tiene operandos de diferentes tipos, el tipo
"menor" es promovido al tipo "superior" antes de que la operacion
proceda. El resultado es el del tipo mayor. La <a href="#orgb740b71">seccion 6</a> del
<a href="#orgea26d39">apendice A</a> establece las reglas de conversion en forma precisa. Si
no hay operandos <code>unsigned</code>, sin embargo, el siguiente conjunto
informal de reglas bastara:
</p>

<ul class="org-ul">
<li>Si cualquier operando es <code>long double</code>, conviertase el otro a
<code>long double</code>.</li>

<li>De otra manera, si cualquier operando es <code>double</code>, conviertase el
otro a <code>double</code>.</li>

<li>De otra manera, si cualquier operando es <code>float</code>, conviertase el
otro a <code>float</code>.</li>

<li>De otra manera, conviertase <code>char</code> y <code>short</code> a <code>int</code>.</li>

<li>Despues, si cualquier operando es <code>long</code>, conviertase el otro a
<code>long</code>.</li>
</ul>


<p>
Notese que los <code>float</code> que estan en una expresion no se convierten
automaticamente a <code>double</code>; esto es un cambio de la definicion
original. En general, las funciones matematicas como las de
<code>&lt;math.h&gt;</code> utilizaran doble precision. La razon principal para usar
<code>float</code> es ahorrar espacio de almacenamiento en arreglos grandes o,
con menor frecuencia, ahorrar tiempo en maquinas en donde la
aritmetica de doble precision es particularmente costosa.
</p>

<p>
Las reglas de conversion son mas complicadas cuando hay operandos
<code>unsigned</code>. El problema es que las comparaciones de valores con
signo y sin signo son dependientes de la maquina, debido a que
dependen de los tamaños de los varios tipos de enteros. Por
ejemplo, supongase que <code>int</code> es de 16 bits y <code>long</code> de 32. Entonces
<code>-1L &lt; 1U</code>, debido a que <code>1U</code>, que es un <code>int</code>, es promovido a
<code>signed long</code>. Pero <code>-1L &gt; 1UL</code>, debido a que <code>-1L</code> es promovido a
<code>unsigned long</code> y asi parece ser un gran numero positivo.
</p>

<p>
Las conversiones tambien tienen lugar en las asignaciones; el valor
del lado derecho es convertido al tipo de la izquierda, el cual es
el tipo del resultado.
</p>

<p>
Un caracter es convenido a un entero, tenga o no extension de
signo, como se describio anteriormente.
</p>

<p>
Los enteros mas largos son convertidos a cortos o a <code>char</code> desechando
el exceso de bits de mas alto orden. Asi en:
</p>

<div class="org-src-container">
<pre class="src src-c"><span style="color: #98fb98;">int</span> <span style="color: #eedd82;">i</span>;
<span style="color: #98fb98;">char</span> <span style="color: #eedd82;">c</span>;

i = c;
c = i;
</pre>
</div>

<p>
el valor de <code>c</code> no cambia. Esto es verdadero ya sea que se inmiscuya
o no la extension de signo. Sin embargo, el invertir el orden de
las asignaciones podria producir perdida de informacion.
</p>

<p>
Si <code>x</code> es <code>float</code> e <code>i</code> es <code>int</code>, entonces <code>x = i</code> e <code>i = x</code>
produciran conversiones; de <code>float</code> a <code>int</code> provoca el truncamiento
de cualquier parte fraccionaria. Cuando <code>double</code> se convierte a
<code>float</code>, el que se redondee o trunque el valor es dependiente de la
implantacion.
</p>

<p>
Puesto que un argumento de la llamada a una funcion es una
expresion, tambien suceden conversiones de tipo cuando se pasan
argumentos a funciones. En ausencia del prototipo de una funcion,
<code>char</code> y <code>short</code> pasan a ser <code>int</code>, y <code>float</code> se hace <code>doble</code>. Esta
es la razon por la que hemos declarado los argumentos a funciones
como <code>int</code> y <code>double</code>, aun cuando la funcion se llama con <code>char</code> y
<code>float</code>.
</p>

<p>
Finalmente, la conversion explicita de tipo puede ser forzada
("coaccionada") en cualquier expresion, con un operador unario
llamado <i>cast</i>. En la construccion:
</p>

<pre class="example">
(nombre-de-tipo) expresion
</pre>

<p>
la <i>expresion</i> es convertida al tipo nombrado, por las reglas de
conversion anteriores. El significado preciso de un <i>cast</i> es como
si la <i>expresion</i> fuera asignada a una variable del tipo
especificado, que se utiliza entonces en lugar de la construccion
completa. Por ejemplo, la rutina de biblioteca <code>sqrt</code> espera un
argumento de doble precision y producira resultados sin sentido si
maneja inadvertidamente algo diferente, (<code>sqrt</code> esta declarado en
<code>&lt;math.h&gt;</code>.)  Asi, si <code>n</code> es un entero, podemos usar:
</p>

<div class="org-src-container">
<pre class="src src-c">sqrt((<span style="color: #98fb98;">double</span>) n)
</pre>
</div>

<p>
para convertir el valor de <code>n</code> a <code>doble</code> antes de pasarlo a
<code>sqrt</code>. Notese que la conversion forzosa produce el valor de <code>n</code> en
el tipo apropiado; <code>n</code> en si no se altera. El operador <i>cast</i> tiene
la misma alta precedencia que otros operadores unarios, como se
resume en la tabla del final de este capitulo.
</p>

<p>
Si un prototipo de funcion declara argumentos, como debe ser
normalmente, la declaracion produce conversion forzada automatica
de los argumentos cuando la funcion es llamada. Asi, dado el
prototipo de la funcion <code>sqrt</code>:
</p>

<div class="org-src-container">
<pre class="src src-c"><span style="color: #98fb98;">double</span> <span style="color: #87cefa;">sqrt</span>(<span style="color: #98fb98;">double</span>);
</pre>
</div>

<p>
la llamada:
</p>

<div class="org-src-container">
<pre class="src src-c">raiz2 = sqrt(2);
</pre>
</div>

<p>
obliga al entero 2 a ser el valor <code>double 2.0</code> sin necesidad de
ningun <i>cast</i>.
</p>

<p>
La biblioteca estandar incluye una implantacion transportable de un
generador de numeros pseudoaleatorios, y una funcion para
inicializar la semilla; lo primero ilustra un <i>cast</i>:
</p>

<div class="org-src-container">
<pre class="src src-c"><span style="color: #98fb98;">unsigned</span> <span style="color: #98fb98;">long</span> <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">next</span> = 1;

<span style="color: #ff4500;">/* </span><span style="color: #ff4500;">rand: regresa un entero pseudoaleatorio en 0..32767 </span><span style="color: #ff4500;">*/</span>
<span style="color: #98fb98;">int</span> <span style="color: #87cefa;">rand</span>(<span style="color: #98fb98;">void</span>)
{
  next = next * 1103515245 + 12345;
  <span style="color: #00ffff;">return</span> (<span style="color: #98fb98;">unsigned</span> <span style="color: #98fb98;">int</span>)(next/65536) % 32768;
}

<span style="color: #ff4500;">/* </span><span style="color: #ff4500;">srand: fija la semilla para rand( ) </span><span style="color: #ff4500;">*/</span>
<span style="color: #98fb98;">void</span> <span style="color: #87cefa;">srand</span>(<span style="color: #98fb98;">unsigned</span> <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">seed</span>)
{
  next = seed;
}
</pre>
</div>

<p>
<b>Ejercicio 2-3</b>. Escriba la funcion <code>htoi(s)</code>, que convierte una
cadena de digitos hexadecimales (incluyendo <code>0x</code> o <code>0X</code> en forma
optativa) en su valor entero equivalente. Los digitos permitidos
son del <code>0</code> al <code>9</code>, de la <code>a</code> a la <code>f</code>, y de la <code>A</code> a la <code>F</code>.
</p>
</div>
</div>

<div id="outline-container-orgc09bc02" class="outline-3">
<h3 id="orgc09bc02">2.8  Operadores de incremento y decremento                         <a id="org96f6eb0"></a></h3>
<div class="outline-text-3" id="text-orgc09bc02">
<p>
El lenguaje C proporciona dos operadores poco comunes para
incrementar y decrementar variables. El operador de aumento <code>++</code>
agrega <code>1</code> a su operando, en tanto que el operador de disminucion
<code>--</code> le resta <code>1</code>. Hemos usado frecuentemente <code>++</code> para incrementar
variables, como en:
</p>

<div class="org-src-container">
<pre class="src src-c"><span style="color: #00ffff;">if</span> (c == <span style="color: #ffa07a;">'\n'</span>)
  ++ni;
</pre>
</div>

<p>
El aspecto poco comun es que <code>++</code> y <code>--</code> pueden ser utilizado como
prefijos (antes de la variable, como en <code>++n</code>), o como postfijos
(despues de la variable: <code>n++</code>). En ambos casos, el efecto es
incrementar <code>n</code>. Pero la expresion <code>++n</code> incrementa a <code>n</code> antes de
que su valor se utilice, en tanto que <code>n++</code> incrementa a <code>n</code>
despues de que su valor se ha empleado. Esto significa que en un
contexto donde el valor esta siendo utilizado, y no solo el efecto,
<code>++n</code> y <code>n++</code> son diferentes.  Si <code>n</code> es <code>5</code>, entonces:
</p>

<div class="org-src-container">
<pre class="src src-c">x = n++;
</pre>
</div>

<p>
asigna <code>5</code> a <code>x</code>, pero
</p>

<div class="org-src-container">
<pre class="src src-c">x = ++n;
</pre>
</div>

<p>
hace que <code>x</code> sea <code>6</code>. En ambos casos, <code>n</code> se hace <code>6</code>. Los
operadores de incremento y decremento solo pueden aplicarse a
variables; una expresion como <code>(i + j)++</code> es ilegal.
</p>

<p>
Dentro de un contexto en donde no se desea ningun valor, sino solo
el efecto de incremento, como en:
</p>

<div class="org-src-container">
<pre class="src src-c"><span style="color: #00ffff;">if</span> (c == <span style="color: #ffa07a;">'\n'</span>)
  nl++;
</pre>
</div>

<p>
prefijos y postfijos son iguales. Pero existen situaciones en donde
se requiere especificamente uno u otro. Por ejemplo, considerese la
funcion <code>squeeze(s, c)</code>, que elimina todas las ocurrencias del
caracter <code>c</code> de una cadena <code>s</code>.
</p>

<div class="org-src-container">
<pre class="src src-c"><span style="color: #ff4500;">/* </span><span style="color: #ff4500;">squeeze: borra todas las c de s </span><span style="color: #ff4500;">*/</span>
<span style="color: #98fb98;">void</span> <span style="color: #87cefa;">squeeze</span>(<span style="color: #98fb98;">char</span> <span style="color: #eedd82;">s</span>[], <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">c</span>)
{
  <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">i</span>, <span style="color: #eedd82;">j</span>;

  <span style="color: #00ffff;">for</span> (i = j = 0; s[i] != <span style="color: #ffa07a;">'\0'</span>; i++ )
    <span style="color: #00ffff;">if</span> (s[i] != c)
      s[j++] = s[i];
  s[j] = <span style="color: #ffa07a;">'\0'</span>;
}
</pre>
</div>

<p>
Cada vez que se encuentra un valor diferente de <code>c</code>, este se copia en
la posicion actual <code>j</code>, y solo entonces <code>j</code> es incrementada para
prepararla para el siguiente caracter. Esto es exactamente
equivalente a:
</p>

<div class="org-src-container">
<pre class="src src-c"><span style="color: #00ffff;">if</span> (s[i] != c) {
  s[j] = s[i];
  j++;
}
</pre>
</div>

<p>
Otro ejemplo de construccion semejante viene de la funcion
<code>getline</code> que escribimos en el <a href="#orgc16243d">capitulo 1</a>, en donde podemos
reemplazar
</p>

<div class="org-src-container">
<pre class="src src-c"><span style="color: #00ffff;">if</span> (c == <span style="color: #ffa07a;">'\n'</span>) {
  s[i] = c;
  ++i;
}
</pre>
</div>

<p>
por algo mas compacto como:
</p>

<div class="org-src-container">
<pre class="src src-c"><span style="color: #00ffff;">if</span> (c == <span style="color: #ffa07a;">'\n'</span>)
  <span style="color: #98fb98;">s</span>[i++] = c;
</pre>
</div>

<p>
Como un tercer ejemplo, considerese que la funcion estandar
<code>strcat(s, t)</code>, que concatena la cadena <code>t</code> al final de la cadena
<code>s</code>. <code>strcat</code> supone que hay suficiente espacio en <code>s</code> para almacenar
la combinacion. Como la hemos escrito, <code>strcat</code> no regresa un valor;
la version de la biblioteca estandar regresa un apuntador a la
cadena resultante.
</p>

<div class="org-src-container">
<pre class="src src-c"><span style="color: #ff4500;">/* </span><span style="color: #ff4500;">strcat: concatena t al final de s; s debe ser suficientemente grande </span><span style="color: #ff4500;">*/</span>
<span style="color: #98fb98;">void</span> <span style="color: #87cefa;">strcat</span>(<span style="color: #98fb98;">char</span> <span style="color: #eedd82;">s</span>[], <span style="color: #98fb98;">char</span> <span style="color: #eedd82;">t</span>[])
{
  <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">i</span>, <span style="color: #eedd82;">j</span>;

  i = j = 0;
  <span style="color: #00ffff;">while</span> (s[i] != <span style="color: #ffa07a;">'\0'</span>) <span style="color: #ff4500;">/* </span><span style="color: #ff4500;">encuentra el fin de s </span><span style="color: #ff4500;">*/</span>
    i++;
  <span style="color: #00ffff;">while</span> ((s[i++] = t[j++]) != <span style="color: #ffa07a;">'\0'</span>) <span style="color: #ff4500;">/* </span><span style="color: #ff4500;">copia t </span><span style="color: #ff4500;">*/</span>
    ;
}
</pre>
</div>

<p>
Como cada caracter se copia de <code>t</code> a <code>s</code>, el <code>++</code> postfijo se
aplica tanto a <code>i</code> como a <code>j</code> para estar seguros de que ambos estan
en posicion para la siguiente iteracion.
</p>

<p>
<b>Ejercicio 2-4</b>. Escriba una version alterna de <code>squeeze(s1,s2)</code>
que borre cada caracter de <code>s1</code> que coincida con cualquier caracter
de la cadena <code>s2</code>.
</p>

<p>
<b>Ejercicio 2-5</b>. Escriba la funcion <code>any(s1,s2)</code>, que regresa la
primera posicion de la cadena <code>s1</code> en donde se encuentre cualquier
caracter de la cadena <code>s2</code>, o <code>-1</code> si si no contiene caracteres de
<code>s2</code>. (La funcion de biblioteca estandar <code>strpbrk</code> hace el mismo
trabajo pero regresa un apuntador a la posicion encontrada.)
</p>
</div>
</div>

<div id="outline-container-org77bf0d9" class="outline-3">
<h3 id="org77bf0d9">2.9  Operadores para manejo de bits                                <a id="orgec181ca"></a></h3>
<div class="outline-text-3" id="text-org77bf0d9">
<p>
El lenguaje C proporciona seis operadores para manejo de bits; solo
pueden ser aplicados a operandos integrales, esto es, <code>char</code>,
<code>short</code>, <code>int</code>, y <code>long</code>, con o sin signo.
</p>

<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-left" />

<col  class="org-left" />
</colgroup>
<tbody>
<tr>
<td class="org-left"><code>&amp;</code></td>
<td class="org-left">AND de bits</td>
</tr>

<tr>
<td class="org-left"><code>│</code></td>
<td class="org-left">OR inclusivo de bits</td>
</tr>

<tr>
<td class="org-left"><code>^</code></td>
<td class="org-left">OR exclusivo de bits</td>
</tr>

<tr>
<td class="org-left"><code>&lt;&lt;</code></td>
<td class="org-left">corrimiento a la izquierda</td>
</tr>

<tr>
<td class="org-left"><code>&gt;&gt;</code></td>
<td class="org-left">corrimiento a la derecha</td>
</tr>

<tr>
<td class="org-left"><code>~</code></td>
<td class="org-left">complemento a uno (unario)</td>
</tr>
</tbody>
</table>

<p>
El operador AND de bits <code>&amp;</code> a menudo es usado para enmascarar algun
conjunto de bits; por ejemplo,
</p>

<div class="org-src-container">
<pre class="src src-c">n = n &amp; 0177;
</pre>
</div>

<p>
hace cero todos los bits de <code>n</code>, menos los 7 de menor orden. El
operador OR de bits <code>|</code> es empleado para encender bits:
</p>

<div class="org-src-container">
<pre class="src src-c">x = x | SET_ON;
</pre>
</div>

<p>
fija en uno a todos los bits de <code>x</code> que son uno en <code>SET_ON</code>;
</p>

<p>
El operador OR exclusivo <code>^</code> pone un uno en cada posicion en donde
sus operandos tienen bits diferentes, y cero en donde son iguales.
</p>

<p>
Se deben distinguir los operadores de bits <code>&amp;</code> y <code>|</code> de los
operadores logicos <code>&amp;&amp;</code> y <code>||</code>, que implican evaluacion de
izquierda a derecha de un valor de verdad. Por ejemplo, si <code>x</code> es
<code>1</code> y <code>y</code> es <code>2</code>, entonces <code>x &amp; y</code> es cero en tanto que <code>x &amp;&amp; y</code> es
uno.
</p>

<p>
Los operadores de corrimiento <code>&gt;&gt;</code> y <code>&lt;&lt;</code> realizan corrimientos a
la derecha y a la izquierda de su operando que esta a la izquierda,
el numero de posiciones de bits dado por el operando de la derecha,
el cual debe ser positivo. Asi <code>x &lt;&lt; 2</code> desplaza el valor de <code>x</code> a
la izquierda dos posiciones, llenando los bits vacantes con cero;
esto es equivalente a una multiplicacion por 4. El correr a la
derecha una cantidad <code>unsigned</code> siempre llena los bits vacantes con
cero. El correr a la derecha una cantidad signada llenara con bits
de signo ("corrimiento aritmetico") en algunas maquinas y con bits
0 ("corrimiento logico") en otras.
</p>

<p>
El operador unario <code>~</code> da el complemento a uno de un entero; esto
es, convierte cada bit <code>1</code> en un bit <code>0</code> y viceversa. Por ejemplo:
</p>

<div class="org-src-container">
<pre class="src src-c">x = x &amp; ~077
</pre>
</div>

<p>
fija los ultimos seis bits de <code>x</code> en cero. Notese que <code>x &amp; ~077</code> es
independiente de la longitud de la palabra, y por lo tanto, es
preferible a, por ejemplo, <code>x &amp; 0177700</code>, que supone que <code>x</code> es una
cantidad de 16 bits. La forma transportable no involucra un costo
extra, puesto que <code>~077</code> es una expresion constante que puede ser
evaluada en tiempo de compilacion.
</p>

<p>
Como ilustracion de algunos de los operadores de bits, considere la
funcion <code>getbits(x,p,n)</code> que regresa el campo de <code>n</code> bits de <code>x</code>
(ajustado a la derecha) que principia en la posicion <code>p</code>. Se supone
que la posicion del bit <code>0</code> esta en el borde derecho y que <code>n</code> y
<code>p</code> son valores positivos adecuados. Por ejemplo, <code>getbits(x,4,3)</code>
regresa los tres bits que estan en la posicion <code>4</code>, <code>3</code> y <code>2</code>,
ajustados a la derecha.
</p>

<div class="org-src-container">
<pre class="src src-c"><span style="color: #ff4500;">/* </span><span style="color: #ff4500;">getbits: obtiene n bits desde la posicion p </span><span style="color: #ff4500;">*/</span>
<span style="color: #98fb98;">unsigned</span> <span style="color: #87cefa;">getbits</span>(<span style="color: #98fb98;">unsigned</span> <span style="color: #eedd82;">x</span>, <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">p</span>, <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">n</span>)
{
  <span style="color: #00ffff;">return</span> (x &gt;&gt; (p + 1 - n)) &amp; ~(~0 &lt;&lt; n);
}
</pre>
</div>

<p>
La expresion <code>x &gt;&gt; (p + 1 - n)</code> mueve el campo deseado al borde
derecho de la palabra. <code>~O</code> es todos los bits en <code>1</code>; corriendo <code>n</code>
bits hacia la izquierda con <code>~0 &lt;&lt; n</code> coloca ceros en los <code>n</code> bits
mas a la derecha; complementado con <code>~</code> hace una mascara de unos en
los <code>n</code> bits mas a la derecha.
</p>

<p>
<b>Ejercicio 2-6</b>. Escriba una funcion <code>setbits(x,p,n,y)</code> que regresa
<code>x</code> con los <code>n</code> bits que principian en la posicion <code>p</code> iguales a
los <code>n</code> bits mas a la derecha de <code>y</code>, dejando los otros bits sin
cambio.
</p>

<p>
<b>Ejercicio 2-7</b>. Escriba una funcion <code>invert(x,p,n)</code> que regresa
<code>x</code> con los <code>n</code> bits que principian en la posicion <code>p</code> invertidos
(esto es, <code>1</code> cambiado a <code>0</code> y viceversa), dejando los otros sin
cambio.
</p>

<p>
<b>Ejercicio 2-8</b>. Escriba una funcion <code>rightrot(x,n)</code> que regresa el
valor del entero <code>x</code> rotado a la derecha <code>n</code> posiciones de bits.
</p>
</div>
</div>

<div id="outline-container-org01da028" class="outline-3">
<h3 id="org01da028">2.10 Operadores de asignacion y expresiones                        <a id="org59031fd"></a></h3>
<div class="outline-text-3" id="text-org01da028">
<p>
Las expresiones tales como
</p>

<div class="org-src-container">
<pre class="src src-c">i = i + 2
</pre>
</div>

<p>
en las que la variable del lado izquierdo se repite inmediatamente en el derecho,
pueden ser escritas en la forma compacta
</p>

<div class="org-src-container">
<pre class="src src-c">i += 2
</pre>
</div>

<p>
El operador <code>+=</code> se llama operador de asignacion.
</p>

<p>
La mayoria de los operadores binarios (operadores como <code>+</code> que
tienen un operando izquierdo y otro derecho) tienen un
correspondiente operador de asignacion <code>op=</code>, en donde <code>op</code> es uno
de:
</p>

<div class="org-src-container">
<pre class="src src-c">+ - * / % &lt;&lt; &gt;&gt; &amp; ^ |
</pre>
</div>

<p>
Si <code>expr1</code> y <code>expr1</code> son expresiones, entonces
</p>

<pre class="example">
expr1 op= expr2
</pre>

<p>
es equivalente a
</p>

<pre class="example">
expr1 = (expr1) op (expr2)
</pre>

<p>
exceptuando que <code>expr1</code> se calcula solo una vez. Notense los
parentesis alrededor de <code>expr2</code>:
</p>

<div class="org-src-container">
<pre class="src src-c">x *= y + 1
</pre>
</div>

<p>
significa
</p>

<div class="org-src-container">
<pre class="src src-c">x = x * (y + 1)
</pre>
</div>

<p>
y no
</p>

<div class="org-src-container">
<pre class="src src-c">x = x * y + 1
</pre>
</div>

<p>
Como ejemplo, la funcion <code>bitcount</code> cuenta el numero de bits en <code>1</code>
en su argumento entero.
</p>

<div class="org-src-container">
<pre class="src src-c"><span style="color: #ff4500;">/* </span><span style="color: #ff4500;">bitcount: cuenta bits 1 en x </span><span style="color: #ff4500;">*/</span>
<span style="color: #98fb98;">int</span> <span style="color: #87cefa;">bitcount</span>(<span style="color: #98fb98;">unsigned</span> <span style="color: #eedd82;">x</span>)
{
  <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">b</span>;

  <span style="color: #00ffff;">for</span> (b = 0; x != 0; x &gt;&gt;= 1)
    <span style="color: #00ffff;">if</span> (x &amp; 01)
      b++;
  <span style="color: #00ffff;">return</span> b;
}
</pre>
</div>

<p>
Declarar al argumento <code>x</code> como <code>unsigned</code> asegura que cuando se
corre a la derecha, los bits vacantes se llenaran con ceros, no con
bits de signo, sin importar la maquina en la que se ejecute el
programa.
</p>

<p>
Muy aparte de su concision, los operadores de asignacion tienen la
ventaja de que corresponden mejor con la forma en que la gente
piensa. Decimos "suma 2 a i" o "incrementa i en 2", no "toma i,
agregale 2, despues pon el resultado de nuevo en i". Asi la
expresion <code>i += 2</code> es preferible a <code>i = i + 2</code>. Ademas, para una
expresion complicada como:
</p>

<div class="org-src-container">
<pre class="src src-c"><span style="color: #98fb98;">yyva1</span>[yypv[p3 + p4] + yypv[p1]] += 2
</pre>
</div>

<p>
el operador de asignacion hace al codigo mas facil de entender,
puesto que el lector no tiene que verificar arduamente que dos
expresiones muy largas son en realidad iguales, o preguntarse por
que no lo son, y un operador de asignacion puede incluso ayudar al
compilador a producir codigo mas eficiente.
</p>

<p>
Ya hemos visto que la proposicion de asignacion tiene un valor y
puede estar dentro de expresiones; el ejemplo mas comun es
</p>

<div class="org-src-container">
<pre class="src src-c"><span style="color: #00ffff;">while</span> ((c = getchar()) != EOF)
  ...
</pre>
</div>

<p>
Los otros operadores de asignacion (<code>+=</code>, <code>-=</code>, etc.) tambien
pueden estar dentro de expresiones, aunque esto es menos frecuente.
</p>

<p>
En todas esas expresiones, el tipo de una expresion de asignacion
es el tipo de su operando del lado izquierdo, y su valor es el
valor despues de la asignacion.
</p>

<p>
<b>Ejercicio 2-9</b>. En un sistema de numeros de complemento a dos, <code>x
   &amp;= (x-1)</code> borra el bit <code>1</code> de mas a la derecha en <code>x</code>. Explique el
porque. Utilice esta observacion para escribir una version mas
rapida de <code>bitcount</code>.
</p>
</div>
</div>

<div id="outline-container-orga67c522" class="outline-3">
<h3 id="orga67c522">2.11 Expresiones condicionales                                     <a id="orga6dae2b"></a></h3>
<div class="outline-text-3" id="text-orga67c522">
<p>
Las proposiciones
</p>

<div class="org-src-container">
<pre class="src src-c"><span style="color: #00ffff;">if</span> (a &gt; b)
  z = a;
<span style="color: #00ffff;">else</span>
  z = b;
</pre>
</div>

<p>
calculan en <code>z</code> el maximo de <code>a</code> y <code>b</code>. La expresion condicional,
escrita con el operador ternario proporciona una forma
alternativa para escribir esta y otras construcciones
semejantes. En la expresion
</p>

<pre class="example">
expr1 ? expr2 : expr3
</pre>

<p>
la expresion <code>expr1</code> es evaluada primero. Si es diferente de cero
(verdadero), entonces la expresion <code>expr2</code> es evaluada, y ese es el
valor de la expresion condicional. De otra forma, <code>expr3</code> se
evalua, y ese es el valor. Solo uno de entre <code>expr2</code>, y <code>expr3</code> se
evalua. Asi, para hacer <code>z</code> el maximo de <code>a</code> y <code>b</code>,
</p>

<div class="org-src-container">
<pre class="src src-c">z = (a &gt; b) ? a : b; <span style="color: #ff4500;">/* </span><span style="color: #ff4500;">z = max(a, b) </span><span style="color: #ff4500;">*/</span>
</pre>
</div>

<p>
Se debe notar que la expresion condicional es en si una expresion,
y se puede utilizar en cualquier lugar donde otra expresion pueda
estar. Si \[expr_2\], y \[expr_3\] son de tipos diferentes, el tipo
del resultado se determina por las reglas de conversion discutidas
anteriormente en este capitulo. Por ejemplo, si <code>f</code> es un <code>float</code> y
<code>i</code> es un <code>int</code>, entonces la expresion
</p>

<div class="org-src-container">
<pre class="src src-c">(i &gt; 0) ? f : i
</pre>
</div>

<p>
es de tipo <code>float</code> sea <code>i</code> positivo o no.
</p>

<p>
Los parentesis no son necesarios alrededor de la primera expresion
de una expresion condicional, puesto que la precedencia de <code>?:</code> es
muy baja, solo arriba de la asignacion. De cualquier modo son
recomendables, puesto que hacen mas facil de ver la parte de
condicion de la expresion.
</p>

<p>
La expresion condicional frecuentemente lleva a un codigo
conciso. Por ejemplo, este ciclo imprime <code>n</code> elementos de un
arreglo, 10 por linea, con cada columna separada por un blanco, y
con cada linea (incluida la ultima) terminada por una nueva linea.
</p>

<div class="org-src-container">
<pre class="src src-c"><span style="color: #00ffff;">for</span> (i = 0; i &lt; n; i++)
  printf(<span style="color: #ffa07a;">"%6d%c"</span>, a[i], ( i % 10 == 9 || i == n-1) ? <span style="color: #ffa07a;">'\n'</span> : <span style="color: #ffa07a;">' '</span>);
</pre>
</div>

<p>
Se imprime un caracter nueva linea despues de cada diez elementos,
y despues del n-esimo. Todos los otros elementos son seguidos por
un espacio en blanco. Esto podria verse oscuro, pero es mas
compacto que el <code>if-else</code> equivalente. Otro buen ejemplo es
</p>

<div class="org-src-container">
<pre class="src src-c">printf(<span style="color: #ffa07a;">"Hay %d elemento%s.\n"</span>, n, n == 1 ? <span style="color: #ffa07a;">""</span> : <span style="color: #ffa07a;">"s"</span>);
</pre>
</div>

<p>
<b>Ejercicio 2-10</b>. Reescriba la funcion <code>lower</code>, que convierte
letras mayusculas a minusculas, con una expresion condicional en
vez de un <code>if-else</code>.
</p>
</div>
</div>

<div id="outline-container-org465098e" class="outline-3">
<h3 id="org465098e">2.12 Precedencia y orden de evaluacion                             <a id="orgff17268"></a></h3>
<div class="outline-text-3" id="text-org465098e">
<p>
La <a href="#org28d5714">tabla 2-1</a> resume las reglas de precedencia y asociatividad de
todos los operadores, incluyendo aquellos que aun no se han
tratado. Los operadores que estan en la misma linea tienen la misma
precedencia; los renglones estan en orden de precedencia
decreciente, asi, por ejemplo, <code>*</code>, <code>/</code>, y <code>%</code> tienen todos la
misma precedencia, la cual es mas alta que la de <code>+</code> y <code>-</code>
binarios. El "operador" <code>()</code> se refiere a la llamada a una
funcion. Los operadores <code>-&gt;</code> y <code>.</code> son utilizados para tener acceso
a miembros de estructuras; seran cubiertos en el <a href="#org09ddcb4">capitulo 6</a>, junto
con <code>sizeof</code> (tamaño de un objeto). En el <a href="#org69d49af">capitulo 5</a> se discuten
<code>*</code> (indireccion a traves de un apuntador) y <code>&amp;</code> (direccion de un
objeto), y en el <a href="#org35eee87">capitulo 3</a> se trata al operador coma.
</p>

<dl class="org-dl">
<dt><a id="org28d5714">Tabla 2-1</a></dt><dd><p>
Precedencia y asociatividad de operadores
</p>

<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-left" />

<col  class="org-left" />
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">Operadores</th>
<th scope="col" class="org-left">Asociatividad</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left"><code>()</code> <code>[]</code> <code>-&gt;</code> <code>.</code></td>
<td class="org-left">izquierda a derecha</td>
</tr>

<tr>
<td class="org-left"><code>!</code> <code>~</code> <code>++</code> <code>--</code> <code>+</code> <code>-</code> <code>*</code> <code>(tipo)</code> <code>sizeof</code></td>
<td class="org-left">derecha a izquierda</td>
</tr>

<tr>
<td class="org-left"><code>*</code> <code>/</code> <code>%</code></td>
<td class="org-left">izquierda a derecha</td>
</tr>

<tr>
<td class="org-left"><code>+</code> <code>-</code></td>
<td class="org-left">izquierda a derecha</td>
</tr>

<tr>
<td class="org-left"><code>&gt;&gt;</code> <code>&lt;&lt;</code></td>
<td class="org-left">izquierda a derecha</td>
</tr>

<tr>
<td class="org-left"><code>&lt;</code> <code>&lt;=</code> <code>&gt;</code> <code>&gt;=</code></td>
<td class="org-left">izquierda a derecha</td>
</tr>

<tr>
<td class="org-left"><code>==</code> <code>!=</code></td>
<td class="org-left">izquierda a derecha</td>
</tr>

<tr>
<td class="org-left"><code>&amp;</code></td>
<td class="org-left">izquierda a derecha</td>
</tr>

<tr>
<td class="org-left"><code>^</code></td>
<td class="org-left">izquierda a derecha</td>
</tr>

<tr>
<td class="org-left"><code>│</code></td>
<td class="org-left">izquierda a derecha</td>
</tr>

<tr>
<td class="org-left"><code>&amp;&amp;</code></td>
<td class="org-left">izquierda a derecha</td>
</tr>

<tr>
<td class="org-left"><code>││</code></td>
<td class="org-left">izquierda a derecha</td>
</tr>

<tr>
<td class="org-left"><code>?:</code></td>
<td class="org-left">derecha a izquierda</td>
</tr>

<tr>
<td class="org-left"><code>=</code> <code>+=</code> <code>-=</code> <code>*=</code> <code>/=</code> <code>%=</code> <code>&amp;=</code> <code>^=</code> <code>│</code> <code>&gt;&gt;=</code> <code>&lt;&lt;=</code></td>
<td class="org-left">derecha a izquierda</td>
</tr>

<tr>
<td class="org-left">,</td>
<td class="org-left">izquierda a derecha</td>
</tr>
</tbody>
</table></dd>
</dl>

<p>
Los <code>+</code>, <code>-</code>, y <code>*</code> unarios, tienen mayor precedencia que las
formas binarias.
</p>

<p>
Notese que la precedencia de los operadores de bits <code>&amp;</code>, <code>^</code> y <code>|</code>
esta debajo de <code>==</code> y <code>!=</code>. Esto implica que las expresiones de
prueba de bits como
</p>

<div class="org-src-container">
<pre class="src src-c"><span style="color: #00ffff;">if</span> ((x &amp; MASK) == 0) ...
</pre>
</div>

<p>
deben ser completamente colocadas entre parentesis para dar los
resultados apropiados.
</p>

<p>
Como muchos lenguajes, C no especifica el orden en el cual los
operandos de un operador seran evaluados. (Las excepciones son <code>&amp;&amp;</code>,
<code>||</code>, <code>?:</code> y ',') Por ejemplo, en proposiciones como
</p>

<div class="org-src-container">
<pre class="src src-c">x = f() + g();
</pre>
</div>

<p>
<code>f</code> puede ser evaluada antes de <code>g</code> o viceversa; de este modo si
<code>f</code> o <code>g</code> alteran una variable de la que la otra depende, <code>x</code> puede
depender del orden de evaluacion. Se pueden almacenar resultados
intermedios en variables temporales para asegurar una secuencia
particular.
</p>

<p>
De manera semejante, el orden en el que se evaluan los argumentos
de una funcion no esta especificado, de modo que la proposicion
</p>

<div class="org-src-container">
<pre class="src src-c">printf(<span style="color: #ffa07a;">"%d %d\n"</span>, ++n, power(2, n)); <span style="color: #ff4500;">/* </span><span style="color: #ff4500;">EQUIVOCADO </span><span style="color: #ff4500;">*/</span>
</pre>
</div>

<p>
puede producir resultados diferentes con distintos compiladores,
dependiendo de si <code>n</code> es incrementada antes de que se llame a
<code>power</code>. La solucion, por supuesto, es escribir
</p>

<div class="org-src-container">
<pre class="src src-c">++n;
printf(<span style="color: #ffa07a;">"%d %d\n"</span>, n, power(2, n));
</pre>
</div>

<p>
Las llamadas a funciones, proposiciones de asignacion anidadas, y
los operadores de incremento y decremento provocan "efectos
colaterales" – alguna variable es modificada como producto de la
evaluacion de una expresion. En cualquier expresion que involucra
efectos colaterales, pueden existir sutiles dependencias del orden
en que las variables involucradas en la expresion se actualizan. La
infortunada situacion es tipificada por la proposicion
</p>

<div class="org-src-container">
<pre class="src src-c"><span style="color: #98fb98;">a</span>[i] = i++;
</pre>
</div>

<p>
La pregunta es si el subindice es el viejo o el nuevo valor de
<code>i</code>. Los compiladores pueden interpretar esto en formas diferentes,
y generar diferentes respuestas dependiendo de su
interpretacion. El estandar deja intencionalmente sin
especificacion la mayoria de tales aspectos. Cuando hay efectos
colaterales (asignacion a variables) dentro de una expresion, se
deja a la prudencia del compilador, puesto que el mejor orden
depende grandemente de la arquitectura de la maquina. (El estandar
si especifica que todos los efectos colaterales sobre argumentos
sucedan antes de que la funcion sea llamada, pero eso podria no
ayudar en la llamada a <a href="#org0458a76"><code>printf</code></a> mostrada anteriormente.)
</p>

<p>
La moraleja es que escribir un codigo que dependa del orden de
evaluacion es una mala practica de programacion en cualquier
lenguaje. Naturalmente, es necesario conocer que cosas evitar,
pero si no sabe como se hacen las cosas en varias maquinas, no debe
intentar aprovechar una implantacion en particular.
</p>
</div>
</div>
</div>

<div id="outline-container-org4490919" class="outline-2">
<h2 id="org4490919">capitulo 3: Control de flujo                                        <a id="org35eee87"></a></h2>
<div class="outline-text-2" id="text-org4490919">
<p>
Las proposiciones de control de flujo de un lenguaje especifican el
orden en que se realiza el procesamiento. Ya hemos visto la mayoria
de las construcciones de control de flujo en ejemplos anteriores;
aqui completaremos el conjunto, y seremos mas precisos acerca de las
discutidas con anterioridad.
</p>
</div>

<div id="outline-container-org012d070" class="outline-3">
<h3 id="org012d070">3.1  Proposiciones y bloques                                       <a id="org9d13412"></a></h3>
<div class="outline-text-3" id="text-org012d070">
<p>
Una expresion como <code>x = 0</code> o <code>i++</code> o <code>printf(...)</code> se convierte en
una <i>proposicion</i> cuando va seguida de un punto y coma, como en
</p>

<div class="org-src-container">
<pre class="src src-c">x = 0;
i++;
printf(...);
</pre>
</div>

<p>
En C, el punto y coma es un terminador de proposicion, en lugar de
un separador, como lo es en un lenguaje tipo Pascal.
</p>

<p>
Las llaves <code>{</code> y <code>}</code> se emplean para agrupar declaraciones y
proposiciones dentro de una <i>proposicion compuesta</i> o <i>bloque</i>, de
modo que son sintacticamente equivalentes a una proposicion
sencilla. Las llaves que encierran las proposiciones de una funcion
son un ejemplo obvio; otros ejemplos son las llaves alrededor de
proposiciones multiples despues de un <code>if</code>, <code>else</code>, <code>while</code> o
<code>for</code>. (Pueden declararse variables dentro de <i>cualquier</i> bloque;
esto se expondra en el <a href="#org05a38fc">capitulo 4</a>.) No hay punto y coma despues de
la llave derecha que termina un bloque.
</p>
</div>
</div>

<div id="outline-container-orge44b8dd" class="outline-3">
<h3 id="orge44b8dd">3.2  <code>if-else</code>                                                     <a id="org12eea3b"></a></h3>
<div class="outline-text-3" id="text-orge44b8dd">
<p>
La proposicion <code>if-else</code> se utiliza para expresar decisiones.
Formalmente, la sintaxis es
</p>

<div class="BLOCK">
<p>
<code>if</code> (expresion)
  proposicion1
<code>else</code>
  proposicion2
</p>

</div>

<p>
donde la parte del <code>else</code> es optativa. La <i>expresion</i> se evalua; si
es verdadera (esto es, si la <i>expresion</i> tiene un valor diferente
de cero), la <code>proposicion1</code>, se ejecuta. Si es falsa (<i>expresion</i>
es cero) y si existe una parte de <code>else</code>, la <code>proposicion2</code>, se
ejecuta en su lugar.
</p>

<p>
Puesto que un <code>if</code> simplemente prueba el valor numerico de una
expresion, son posibles ciertas abreviaciones de codigo. Lo mas
obvio es escribir
</p>

<div class="org-src-container">
<pre class="src src-c"><span style="color: #00ffff;">if</span> (expresion)
</pre>
</div>

<p>
en lugar de
</p>

<div class="org-src-container">
<pre class="src src-c"><span style="color: #00ffff;">if</span> ( expresion != 0 )
</pre>
</div>

<p>
Algunas veces esto es claro y natural; otras puede ser misterioso.
</p>

<p>
Debido a que la parte <code>else</code> de un <code>if-else</code> es optativa, existe
una ambigüedad cuando un <code>else</code> se omite de una secuencia <code>if</code>
anidada. Esto se resuelve al asociar el <code>else</code> con el <code>if</code> anterior
sin <code>else</code> mas cercano. Por ejemplo, en
</p>

<div class="org-src-container">
<pre class="src src-c"><span style="color: #00ffff;">if</span> (n &gt; 0 )
  <span style="color: #00ffff;">if</span> (a &gt; b)
    z = a;
  <span style="color: #00ffff;">else</span>
    z = b;
</pre>
</div>

<p>
el <code>else</code> va con el <code>if</code> mas interno, como se muestra con el
sangrado. Si eso no es lo que se desea, se deben utilizar llaves
para forzar la asociacion correcta:
</p>

<div class="org-src-container">
<pre class="src src-c"><span style="color: #00ffff;">if</span> (n &gt; 0 ) {
  <span style="color: #00ffff;">if</span> (a &gt; b)
    z = a;
}
<span style="color: #00ffff;">else</span>
  z = b;
</pre>
</div>

<p>
La ambigüedad es especialmente perniciosa en situaciones como esta:
</p>

<div class="org-src-container">
<pre class="src src-c"><span style="color: #00ffff;">if</span> (n &gt; 0 )
  <span style="color: #00ffff;">for</span> (i = 0 ; i &lt; n; i ++)
    <span style="color: #00ffff;">if</span> (s[i] &gt; 0) {
      printf(<span style="color: #ffa07a;">"..."</span>);
      <span style="color: #00ffff;">return</span> i;
    }
<span style="color: #00ffff;">else</span>   <span style="color: #ff4500;">/* </span><span style="color: #ff4500;">MAL </span><span style="color: #ff4500;">*/</span>
  printf (<span style="color: #ffa07a;">"error -- n es negativo \n"</span>);
</pre>
</div>

<p>
El sangrado muestra en forma inequivoca lo que se desea, pero el
compilador no entiende el mensaje y asocia el <code>else</code> con el <code>if</code>
mas interno. Puede ser dificil encontrar esta clase de errores; es
buena idea utilizar llaves cuando hay varios <code>if</code> anidados.
</p>

<p>
A proposito, notese que hay un punto y coma despues de <code>z = a</code> en
</p>

<div class="org-src-container">
<pre class="src src-c"><span style="color: #00ffff;">if</span> (a &gt; b )
  z = a;
<span style="color: #00ffff;">else</span>
  z = b;
</pre>
</div>

<p>
Esto se debe a que gramaticalmente al <code>if</code> sigue una <i>proposicion</i>,
y una expresion como <code>z = a;</code> siempre se termina con punto y coma.
</p>
</div>
</div>

<div id="outline-container-org6a03fb6" class="outline-3">
<h3 id="org6a03fb6">3.3  <code>else-if</code>                                                     <a id="org5628cc0"></a></h3>
<div class="outline-text-3" id="text-org6a03fb6">
<p>
La construccion
</p>

<div class="org-src-container">
<pre class="src src-c"><span style="color: #00ffff;">if</span> (expresion)
  proposicion
<span style="color: #00ffff;">else</span> <span style="color: #00ffff;">if</span> (expresion)
  proposicion
<span style="color: #00ffff;">else</span> <span style="color: #00ffff;">if</span> (expresion)
  proposicion
<span style="color: #00ffff;">else</span> <span style="color: #00ffff;">if</span> (expresion)
  proposicion
<span style="color: #00ffff;">else</span>
  proposicion
</pre>
</div>

<p>
ocurre de modo tan frecuente que bien vale una pequeña discusion
aparte. Esta secuencia de proposiciones <code>if</code> es la forma mas
general de escribir una decision multiple. Las <i>expresiones</i> se
evaluan en orden; si cualquier <i>expresion</i> es verdadera, la
<i>proposicion</i> asociada con ella se ejecuta, y esto termina toda la
cadena. Como siempre, el codigo para cada <i>proposicion</i> es una
proposicion simple o un grupo dentro de llaves.
</p>

<p>
La parte del ultimo <code>else</code> maneja el caso "ninguno de los anteriores"
o caso por omision cuando ninguna de las otras condiciones se
satisface. En algunos casos no hay una accion explicita para la
omision; en ese caso el
</p>

<div class="org-src-container">
<pre class="src src-c"><span style="color: #00ffff;">else</span>
  proposicion
</pre>
</div>

<p>
del final puede omitirse, o puede utilizarse para deteccion de
errores al atrapar una condicion "imposible".
</p>

<p>
Para ilustrar una decision de tres vias, se muestra una funcion de
busqueda binaria que decide si un valor particular de <code>x</code> se
encuentra en el arreglo ordenado <code>v</code>. Los elementos de <code>v</code> deben
estar en orden ascendente. La funcion regresa la posicion (un
numero entre <code>0</code> y <code>n - 1</code>) si <code>x</code> esta en <code>v</code>, y <code>-1</code> si no es
asi.
</p>

<p>
La busqueda binaria primero compara el valor de entrada <code>x</code> con el
elemento medio del arreglo <code>v</code>. Si <code>x</code> es menor que el valor del
medio, la busqueda se enfoca sobre la mitad inferior de la tabla;
de otra manera lo hace en la mitad superior, en cualquier caso, el
siguiente paso es comparar a <code>x</code> con el elemento medio de la mitad
seleccionada. Este proceso de dividir en dos continua hasta que se
encuentra el valor o ya no hay elementos.
</p>

<div class="org-src-container">
<pre class="src src-c"><span style="color: #ff4500;">/* </span><span style="color: #ff4500;">binsearch: encuentra x en v[0] &lt;= v[1] &lt;= ... &lt;= v[n-1] </span><span style="color: #ff4500;">*/</span>
<span style="color: #98fb98;">int</span> <span style="color: #87cefa;">binsearch</span>(<span style="color: #98fb98;">int</span> <span style="color: #eedd82;">x</span>, <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">v</span>[], <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">n</span>)
{
  <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">low</span>, <span style="color: #eedd82;">high</span>, <span style="color: #eedd82;">mid</span>;
  low = 0;
  high = n - 1;
  <span style="color: #00ffff;">while</span> (low &lt;= high) {
    mid = (low + high)/2;
    <span style="color: #00ffff;">if</span> (x &lt; v[mid])
      high = mid - 1;
    <span style="color: #00ffff;">else</span> <span style="color: #00ffff;">if</span> (x &gt; v[mid])
      low = mid + 1;
    <span style="color: #00ffff;">else</span>     <span style="color: #ff4500;">/* </span><span style="color: #ff4500;">found match </span><span style="color: #ff4500;">*/</span>
      <span style="color: #00ffff;">return</span> mid;
  }
  <span style="color: #00ffff;">return</span> -1; <span style="color: #ff4500;">/* </span><span style="color: #ff4500;">no match    </span><span style="color: #ff4500;">*/</span>
}
</pre>
</div>

<p>
La decision fundamental es si <code>x</code> es menor que, mayor que o igual al
elemento medio <code>v[mid]</code> en cada paso; esto es un <code>else-if</code> natural.
</p>

<p>
<b>Ejercicio 3-1</b>. Nuestra busqueda binaria realiza dos pruebas
dentro del ciclo, cuando una podria ser suficiente (al precio de
mas pruebas en el exterior). Escriba una version con solo una
prueba dentro del ciclo y mida la diferencia en tiempo de
ejecucion.
</p>
</div>
</div>

<div id="outline-container-orge1cacbd" class="outline-3">
<h3 id="orge1cacbd">3.4  <code>switch</code>                                                      <a id="org0173be2"></a></h3>
<div class="outline-text-3" id="text-orge1cacbd">
<p>
La proposicion <code>switch</code> es una decision multiple que prueba si una
expresion coincide con uno de un numero de valores constantes
enteros, y traslada el control adecuadamente.
</p>

<div class="org-src-container">
<pre class="src src-c"><span style="color: #00ffff;">switch</span> (expresion) {
  <span style="color: #00ffff;">case</span> exp-<span style="color: #00ffff;">const</span>: proposiciones
  <span style="color: #00ffff;">case</span> exp-<span style="color: #00ffff;">const</span>: proposiciones
  <span style="color: #00ffff;">default</span>: proposiciones
}
</pre>
</div>

<p>
Cada <code>case</code> se etiqueta con uno o mas valores constantes enteros o
expresiones constantes enteras. Si un <code>case</code> coincide con el valor
de la expresion, la ejecucion comienza alli. Todas las expresiones
<code>case</code> deben ser diferentes. El etiquetado como <code>default</code> se
ejecuta si ninguno de los otros se satisface. El <code>default</code> es
optativo; si no esta y ninguno de los casos coincide, no se toma
accion alguna. Las clausulas <code>case</code> y <code>default</code> pueden ocurrir en
cualquier orden.
</p>

<p>
En el <a href="#orgc16243d">capitulo 1</a> se escribio un programa para contar las
ocurrencias de cada digito, espacios en blanco y todos los demas
caracteres, usando una secuencia de <code>if ... else if ... else</code>. Aqui
esta el mismo programa con un <code>switch</code>:
</p>

<div class="org-src-container">
<pre class="src src-c"><span style="color: #b0c4de;">#include</span> <span style="color: #ffa07a;">&lt;stdio.h&gt;</span>

<span style="color: #87cefa;">main</span>() <span style="color: #ff4500;">/* </span><span style="color: #ff4500;">cuenta digitos, espacios blancos, y otros</span><span style="color: #ff4500;">*/</span>
{
  <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">c</span>, <span style="color: #eedd82;">i</span>, <span style="color: #eedd82;">nwhite</span>, <span style="color: #eedd82;">nother</span>, <span style="color: #eedd82;">ndigit</span>[10];

  nwhite = nother = 0;
  <span style="color: #00ffff;">for</span> (i = 0; i &lt; 10; i++)
    ndigit[i] = 0;
  <span style="color: #00ffff;">while</span> ((c = getchar()) != EOF) {
      <span style="color: #00ffff;">switch</span> (c) {
      <span style="color: #00ffff;">case</span> <span style="color: #ffa07a;">'0'</span>: <span style="color: #00ffff;">case</span> <span style="color: #ffa07a;">'1'</span>: <span style="color: #00ffff;">case</span> <span style="color: #ffa07a;">'2'</span>: <span style="color: #00ffff;">case</span> <span style="color: #ffa07a;">'3'</span>: <span style="color: #00ffff;">case</span> <span style="color: #ffa07a;">'4'</span>:
      <span style="color: #00ffff;">case</span> <span style="color: #ffa07a;">'5'</span>: <span style="color: #00ffff;">case</span> <span style="color: #ffa07a;">'6'</span>: <span style="color: #00ffff;">case</span> <span style="color: #ffa07a;">'7'</span>: <span style="color: #00ffff;">case</span> <span style="color: #ffa07a;">'8'</span>: <span style="color: #00ffff;">case</span> <span style="color: #ffa07a;">'9'</span>:
        ndigit[c-<span style="color: #ffa07a;">'0'</span>]++;
        <span style="color: #00ffff;">break</span>;
      <span style="color: #00ffff;">case</span> <span style="color: #ffa07a;">' '</span>:
      <span style="color: #00ffff;">case</span> <span style="color: #ffa07a;">'\n'</span>:
      <span style="color: #00ffff;">case</span> <span style="color: #ffa07a;">'\t'</span>:
        nwhite++;
        <span style="color: #00ffff;">break</span>;
      <span style="color: #00ffff;">default</span>:
        nother++;
        <span style="color: #00ffff;">break</span>;
      }
  }
  printf(<span style="color: #ffa07a;">"digits ="</span>);
  <span style="color: #00ffff;">for</span> (i = 0; i &lt; 10; i++)
    printf(<span style="color: #ffa07a;">" %d"</span>, ndigit[i]);
  printf(<span style="color: #ffa07a;">", espacios blancos = %d, otros = %d\n"</span>, nwhite, nother);
  <span style="color: #00ffff;">return</span> 0;
}
</pre>
</div>

<p>
La proposicion <code>break</code> provoca una salida inmediata del
<code>switch</code>. Puesto que los <code>case</code> sirven solo como etiquetas, despues
de que se ejecuta el codigo para uno, la ejecucion pasa al
siguiente, a menos que se tome una accion especifica para terminar
el <code>switch</code>. Las formas mas comunes de dejar un <code>switch</code> son
<code>break</code> y <code>return</code>. Una proposicion <code>break</code> tambien se puede
emplear para forzar una salida inmediata de los ciclos <code>while</code>,
<code>for</code> y <code>do</code>, como se vera mas adelante en este capitulo.
</p>

<p>
Pasar a traves de los <code>case</code> es en parte bueno y en parte no. Por
el lado positivo, esto permite conectar varios <code>case</code> a una accion
simple, como con los digitos de este ejemplo. Pero eso tambien
implica que cada <code>case</code> normalmente debe terminar con un <code>break</code>
para prevenir pasar al siguiente. Pasar de un <code>case</code> a otro no es
una practica muy solida y es susceptible a la desintegracion cuando
se modifica el programa. Con la excepcion de etiquetas multiples
para un calculo simple, lo anterior se debe utilizar con cautela y
emplear comentarios.
</p>

<p>
Como formalidad, coloque un <code>break</code> despues del ultimo <code>case</code> (en
este caso el <code>default</code>) aun si es logicamente innecesario. Algun
dia, cuando se agregue otro <code>case</code> al final, esta practica de
programacion defensiva lo salvara.
</p>

<p>
<b>Ejercicio 3-2</b>. Escriba una funcion <code>escape(s,t)</code> que convierte
caracteres como nueva linea y tabulacion en secuencias de escape
visibles como <code>\n</code> y <code>\t</code> mientras copia la cadena <code>t</code> a
<code>s</code>. Utilice un <code>switch</code>. Escriba tambien una funcion para la
direccion inversa, convirtiendo secuencias de escape en caracteres
reales.
</p>
</div>
</div>

<div id="outline-container-orgd5e84fe" class="outline-3">
<h3 id="orgd5e84fe">3.5  Ciclos <code>while</code> y <code>for</code>                                        <a id="orgb4c7c9f"></a></h3>
<div class="outline-text-3" id="text-orgd5e84fe">
<p>
Ya hemos aplicado los ciclos <code>while</code> y <code>for</code>. En
</p>

<div class="org-src-container">
<pre class="src src-c"><span style="color: #00ffff;">while</span> (expresion)
  proposicion
</pre>
</div>

<p>
la <i>expresion</i> se evalua. Si es diferente de cero, se ejecuta la
<i>proposicion</i> y se reevalua la <i>expresion</i>. Este ciclo continua
hasta que la <i>expresion</i> se hace cero, punto en el cual se suspende
la ejecucion para continuar despues de la <i>proposicion</i>.
</p>

<p>
La proposicion <code>for</code>
</p>

<div class="org-src-container">
<pre class="src src-c"><span style="color: #00ffff;">for</span> (expr1; expr2; expr3)
  proposicion
</pre>
</div>

<p>
es equivalente a
</p>

<div class="org-src-container">
<pre class="src src-c">expr1;
<span style="color: #00ffff;">while</span> (expr2 ) {
  <span style="color: #98fb98;">proposicion</span>
  <span style="color: #eedd82;">expr3</span> ;
}
</pre>
</div>

<p>
excepto por el comportamiento de <code>continue</code> que se describe en la
<a href="#org4b67125">seccion 3.7</a>.
</p>

<p>
Gramaticalmente, las tres componentes de un ciclo <code>for</code> son
expresiones. Por lo comun, <code>expr1</code> y <code>expr3</code> son asignaciones o
llamadas a funcion y <code>expr2</code> es una expresion de
relacion. Cualquiera de las tres partes se puede omitir, aunque
deben permanecer los punto y coma. Si <code>expr1</code> o <code>expr3</code> se omite,
solo se desecha de la expansion. Si la prueba <code>expr2</code> no esta
presente, se toma como permanentemente verdadera, asi que
</p>

<div class="org-src-container">
<pre class="src src-c"><span style="color: #00ffff;">for</span> (;;) {
  ...
}
</pre>
</div>

<p>
es una iteracion "infinita", que presumiblemente sera interrumpida
por otros medios, como un <code>break</code> o un <code>return</code>.
</p>

<p>
El usar <code>while</code> o <code>for</code> es principalmente cuestion de preferencia
personal. Por ejemplo, en
</p>

<div class="org-src-container">
<pre class="src src-c"><span style="color: #00ffff;">while</span> ((c = getchar()) == <span style="color: #ffa07a;">' '</span> || c == <span style="color: #ffa07a;">'\n'</span> || c == <span style="color: #ffa07a;">'\t'</span>)
  ; <span style="color: #ff4500;">/* </span><span style="color: #ff4500;">ignora caracteres espaciadores </span><span style="color: #ff4500;">*/</span>
</pre>
</div>

<p>
no hay inicializacion o reinicializacion, por lo que el <code>while</code> es
mas natural.
</p>

<p>
El <code>for</code> se prefiere cuando existe una inicializacion simple e
incrementos, puesto que mantiene las proposiciones de control del
ciclo juntas y visibles al principio del mismo. Esto es mas obvio
en
</p>

<div class="org-src-container">
<pre class="src src-c"><span style="color: #00ffff;">for</span> (i = 0; i &lt; n; i++)
  ...
</pre>
</div>

<p>
que es la forma caracteristica de procesar los primeros <code>n</code>
elementos de un arreglo en C, lo analogo al ciclo <code>DO</code> de Fortran o
al <code>for</code> de Pascal. Sin embargo, la analogia no es perfecta puesto
que tanto el indice como el limite de un ciclo <code>for</code> en C pueden
ser alterados desde dentro del ciclo, y la variable del indice <code>i</code>
retiene su valor cuando las iteraciones terminan por cualquier
razon. Debido a que las componentes del <code>for</code> son expresiones
arbitrarias, sus ciclos no estan restringidos a progresiones
aritmeticas. Por otra parte, considere que es un mal estilo incluir
en las secciones de inicializacion e incremento operaciones no
relacionadas con esas actividades, que mas bien se reservan para
acciones de control del ciclo.
</p>

<p>
Como un ejemplo mas amplio, aqui esta otra version de <a href="#orgdd02576"><code>atoi</code></a> para
convertir una cadena a su equivalente numerico. Esta es ligeramente
mas general que la del <a href="#org29d5b55">capitulo 2</a>; trata tambien los espacios en
blanco previos al numero, y los signos <code>+</code> o <code>-</code>. (El <a href="#org05a38fc">capitulo 4</a>
muestra <a href="#org9f52a73"><code>atof</code></a>, que realiza la misma conversion para numeros de
punto flotante.)
</p>

<p>
La estructura del programa refleja la forma de la entrada:
</p>

<pre class="example">
ignora espacios en blanco, si los hay
toma el signo, si lo hay
toma la parte entera y conviertela
</pre>

<p>
Cada paso realiza su parte, y deja las cosas en forma clara para el
siguiente. La totalidad del proceso termina con el primer caracter
que no pueda ser parte de un numero.
</p>

<div class="org-src-container">
<pre class="src src-c"><span style="color: #b0c4de;">#include</span> <span style="color: #ffa07a;">&lt;ctype.h&gt;</span>

<span style="color: #ff4500;">/* </span><span style="color: #ff4500;">atoi: convierte s a entero; version 2 </span><span style="color: #ff4500;">*/</span>
<span style="color: #98fb98;">int</span> <span style="color: #87cefa;">atoi</span>(<span style="color: #98fb98;">char</span> <span style="color: #eedd82;">s</span>[])
{
  <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">i</span>, <span style="color: #eedd82;">n</span>, <span style="color: #eedd82;">sign</span>;
  <span style="color: #00ffff;">for</span> (i = 0; isspace(s[i]); i++) <span style="color: #ff4500;">/* </span><span style="color: #ff4500;">ignora espacio en blanco </span><span style="color: #ff4500;">*/</span>
    ;
  sign = (s[i] == <span style="color: #ffa07a;">'-'</span>) ? -1 : 1;
  <span style="color: #00ffff;">if</span> (s[i] == <span style="color: #ffa07a;">'+'</span> || s[i] == <span style="color: #ffa07a;">'-'</span>) <span style="color: #ff4500;">/* </span><span style="color: #ff4500;">ignora el signo </span><span style="color: #ff4500;">*/</span>
    i++;
  <span style="color: #00ffff;">for</span> (n = 0; isdigit(s[i]); i++)
    n = 10 * n + (s[i] - <span style="color: #ffa07a;">'0'</span>);
  <span style="color: #00ffff;">return</span> sign * n;
}
</pre>
</div>

<p>
La biblioteca estandar proporciona una funcion mas elaborada,
<a href="#orge761d6c"><code>strtol</code></a>, para la conversion de cadenas a enteros largos; vease la
<a href="#orge762181">seccion 5</a> del <a href="#org89d4232">apendice B</a>.
</p>

<p>
Las ventajas de mantener centralizado el control del ciclo son aun
mas obvias cuando existen ciclos anidados. La siguiente funcion es
un ordenamiento Shell para ordenar un arreglo de enteros. La idea
basica de este algoritmo de ordenamiento, que fue inventado en 1959
por D.L. Shell, es que en las primeras etapas sean comparados
elementos lejanos, en lugar de los adyacentes, como en los
ordenamientos de intercambio mas simples. Esto tiende a eliminar
rapidamente gran cantidad de desorden, asi que los estados
posteriores tienen menos trabajo por hacer. El intervalo entre los
elementos comparados disminuye en forma gradual hasta uno, punto en
el que el ordenamiento viene a ser efectivamente un metodo
adyacente de intercambio.
</p>

<div class="org-src-container">
<pre class="src src-c"><span style="color: #ff4500;">/* </span><span style="color: #ff4500;">shellsort: ordena v[0]...v[n-1] en orden ascendente </span><span style="color: #ff4500;">*/</span>
<span style="color: #98fb98;">void</span> <span style="color: #87cefa;">shellsort</span>(<span style="color: #98fb98;">int</span> <span style="color: #eedd82;">v</span>[], <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">n</span>)
{
  <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">gap</span>, <span style="color: #eedd82;">i</span>, <span style="color: #eedd82;">j</span>, <span style="color: #eedd82;">temp</span>;
  <span style="color: #00ffff;">for</span> (gap = n/2; gap &gt; 0; gap /= 2)
    <span style="color: #00ffff;">for</span> (i = gap; i &lt; n; i++)
      <span style="color: #00ffff;">for</span> (j=i-gap; j&gt;=0 &amp;&amp; v[j]&gt;v[j+gap]; j-=gap) {
        temp = v[j];
        v[j] = v[j+gap];
        v[j+gap] = temp;
      }
}
</pre>
</div>

<p>
Existen tres ciclos anidados. El mas externo controla el espacio
entre los elementos comparados, reduciendolo desde <code>n/2</code> por un
factor de dos en cada paso hasta que llega a cero. El ciclo
intermedio recorre los elementos. El ciclo mas interno compara cada
pareja de elementos que esta separada por el espacio <code>gap</code> e
invierte a las que esten desordenadas. Puesto que <code>gap</code> finalmente
se reduce a uno, todos los elementos se ordenan
correctamente. Notese como la generalidad del <code>for</code> hace que el
ciclo mas externo coincida con la forma de los otros, aun cuando no
es una progresion aritmetica.
</p>

<p>
Un ultimo operador de C es la coma ",", que frecuentemente
encuentra uso en la proposicion <code>for</code>. Una pareja de expresiones
separadas por una coma se evalua de izquierda a derecha, y el tipo
y valor del resultado son el tipo y valor del operando
derecho. Asi, en una proposicion <code>for</code> es posible colocar
expresiones multiples en las diferentes partes, por ejemplo, para
procesar dos indices en paralelo. Esto se ilustra en la funcion
<code>reverse(s)</code>, que invierte a la cadena <code>s</code> en el mismo lugar.
</p>


<div class="org-src-container">
<pre class="src src-c"><span style="color: #b0c4de;">#include</span> <span style="color: #ffa07a;">&lt;string.h&gt;</span>

<span style="color: #ff4500;">/* </span><span style="color: #ff4500;">reverse: invierte la cadena s en el mismo lugar </span><span style="color: #ff4500;">*/</span>
<span style="color: #98fb98;">void</span> <span style="color: #87cefa;">reverse</span>(<span style="color: #98fb98;">char</span> <span style="color: #eedd82;">s</span>[])
{
  <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">c</span>, <span style="color: #eedd82;">i</span>, <span style="color: #eedd82;">j</span>;
  <span style="color: #00ffff;">for</span> (i = 0, j = strlen(s)-1; i &lt; j; i++, j--) {
    c = s[i];
    s[i] = s[j];
    s[j] = c;
  }
}
</pre>
</div>

<p>
Las comas que separan a los argumentos de una funcion, las
variables en declaraciones, etc., no son operadores coma, y no
garantizan evaluacion de izquierda a derecha.
</p>

<p>
Los operadores coma deberan utilizarse poco. Los usos mas adecuados
son en construcciones fuertemente relacionadas una con la otra,
como en el ciclo <code>for</code> de <code>reverse</code>, y en macros en donde un
calculo de paso multiple debe ser una expresion simple. Una
expresion coma podria tambien ser apropiada para el intercambio de
elementos en <code>reverse</code>, donde el intercambio puede ser a traves de
una operacion simple:
</p>


<div class="org-src-container">
<pre class="src src-c"><span style="color: #00ffff;">for</span> (i = 0, j = strlen(s)-1; i &lt; j; i++, j--)
  c = s[i], s[i] = s[j], s[j] = c;
</pre>
</div>

<p>
<b>Ejercicio 3-3</b>. Escriba la funcion <code>expand(s1,s2)</code> que expande
notacion abreviada como <code>a-z</code>, que viene en la cadena <code>s1</code>, en la
lista equivalente completa <code>abc...xyz</code>, en <code>s2</code>. Permita letras
mayusculas y minusculas, asi como digitos, y este preparado para
manejar casos como <code>a-b-c</code> y <code>a-zO-9</code> y <code>-a-z</code>. Haga que los
guiones al inicio o al final se tomen literalmente.
</p>
</div>
</div>

<div id="outline-container-org11f9b93" class="outline-3">
<h3 id="org11f9b93">3.6  Ciclos <code>do-while</code>                                             <a id="org8eb8fc8"></a></h3>
<div class="outline-text-3" id="text-org11f9b93">
<p>
Como ya se expuso en el <a href="#orgc16243d">capitulo 1</a>, los ciclos <code>while</code> y <code>for</code>
verifican al principio la condicion de termino. En contraste, el
tercer ciclo en C, el <code>do-while</code>, prueba al final <i>despues</i> de
realizar cada paso a traves del cuerpo del ciclo, el cual se
ejecuta siempre por lo menos una vez.
</p>

<p>
La sintaxis del do es
</p>

<div class="org-src-container">
<pre class="src src-c"><span style="color: #00ffff;">do</span>
  proposicion
<span style="color: #00ffff;">while</span> (expresion);
</pre>
</div>

<p>
La <i>proposicion</i> se ejecuta y despues se evalua la <i>expresion</i>. Si
es verdadera, la <i>proposicion</i> se evalua de nuevo, y asi
sucesivamente. Cuando la <i>expresion</i> se hace falsa, el ciclo
termina. Excepto por el sentido de la prueba, el <code>do-while</code> es
equivalente a la proposicion <code>repeat-until</code> de Pascal.
</p>

<p>
La experiencia demuestra que el <code>do-while</code> es mucho menos utilizado
que el <code>while</code> y el <code>for</code>. Aunque de cuando en cuando es valioso, como
en la siguiente funcion <code>itoa</code>, que convierte un numero a una cadena
de caracteres (lo inverso de <a href="#orgdd02576"><code>atoi</code></a>). El trabajo es ligeramente mas
complicado de lo que podria pensarse en un principio, debido a que
los metodos faciles para generar digitos los generan en el orden
incorrecto. Hemos elegido generar la cadena al reves y despues
invertirla.
</p>

<div class="org-src-container">
<pre class="src src-c"><span style="color: #ff4500;">/* </span><span style="color: #ff4500;">itoa: convierte n a caracteres en s </span><span style="color: #ff4500;">*/</span>
<span style="color: #98fb98;">void</span> <span style="color: #87cefa;">itoa</span>(<span style="color: #98fb98;">int</span> <span style="color: #eedd82;">n</span>, <span style="color: #98fb98;">char</span> <span style="color: #eedd82;">s</span>[])
{
  <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">i</span>, <span style="color: #eedd82;">sign</span>;

  <span style="color: #00ffff;">if</span> ((sign = n) &lt; 0) <span style="color: #ff4500;">/* </span><span style="color: #ff4500;">registra el signo </span><span style="color: #ff4500;">*/</span>
    n = -n;           <span style="color: #ff4500;">/* </span><span style="color: #ff4500;">vuelve a n positivo </span><span style="color: #ff4500;">*/</span>
  i = 0;
  <span style="color: #00ffff;">do</span> {    <span style="color: #ff4500;">/* </span><span style="color: #ff4500;">genera digitos en orden inverso </span><span style="color: #ff4500;">*/</span>
    s[i++] = n % 10 + <span style="color: #ffa07a;">'0'</span>;  <span style="color: #ff4500;">/* </span><span style="color: #ff4500;">toma el siguiente digito </span><span style="color: #ff4500;">*/</span>
  } <span style="color: #00ffff;">while</span> ((n /= 10) &gt; 0);  <span style="color: #ff4500;">/* </span><span style="color: #ff4500;">borralo </span><span style="color: #ff4500;">*/</span>
  <span style="color: #00ffff;">if</span> (sign &lt; 0)
    s[i++] = <span style="color: #ffa07a;">'-'</span>;
  s[i] = <span style="color: #ffa07a;">'\0'</span>;
  reverse(s);
}
</pre>
</div>

<p>
El <code>do-while</code> es necesario, o al menos conveniente, puesto que por
lo menos se debe instalar un caracter en el arreglo <code>s</code>, aun si <code>n</code>
es cero. Tambien empleamos llaves alrededor de la proposicion
simple que hace el cuerpo del <code>do-while</code>, aunque son innecesarias,
y asi el lector apresurado no confundira la seccion del <code>while</code> con
el <i>principio</i> de un ciclo <code>while</code>.
</p>

<p>
<b>Ejercicio 3-4</b>. En una representacion de numeros en complemento a
dos, nuestra version de <code>itoa</code> no maneja el numero negativo mas
grande, esto es, el valor de <code>n</code> igual a
\[-(2^wordsize-1)\]. Explique por que. Modifiquelo para imprimir el
valor correctamente, sin importar la maquina en que ejecute.
</p>

<p>
<b>Ejercicio 3-5</b>. Escriba la funcion <code>itob(n,s,b)</code> que convierte al
entero <code>n</code> en una representacion de caracteres con base <code>b</code> dentro
de la cadena <code>s</code>. En particular, <code>itob(n,s,16)</code> da formato a <code>n</code>
como un entero hexadecimal en <code>s</code>.
</p>

<p>
<b>Ejercicio 3-6</b>. Escriba una version de <code>itoa</code> que acepte tres
argumentos en lugar de dos. El tercer argumento es un ancho minimo
de campo; al numero convertido se deben agregar blancos a la
izquierda si es necesario para hacerlo suficientemente ancho.
</p>
</div>
</div>

<div id="outline-container-orgd6f8690" class="outline-3">
<h3 id="orgd6f8690">3.7  <code>break</code> y <code>continue</code>                                          <a id="org4b67125"></a></h3>
<div class="outline-text-3" id="text-orgd6f8690">
<p>
Algunas veces es conveniente tener la posibilidad de abandonar un
ciclo de otra manera que no sea probando al inicio o al final. La
proposicion <code>break</code> proporciona una salida anticipada de un <code>for</code>,
<code>while</code> y <code>do</code>, tal como lo hace el <code>switch</code>. Un <code>break</code> provoca
que el ciclo o <code>switch</code> mas interno que lo encierra termine
inmediatamente.
</p>

<p>
La siguiente funcion, <code>trim</code>, elimina espacios blancos, tabuladores
y nuevas lineas al final de una cadena, utilizando un <code>break</code> para
salir de un ciclo cuando se encuentra el no-blanco, no-tabulador o
no-nueva linea de mas a la derecha.
</p>

<div class="org-src-container">
<pre class="src src-c"><span style="color: #ff4500;">/* </span><span style="color: #ff4500;">trim: elimina blancos, tabuladores y nueva linea al final </span><span style="color: #ff4500;">*/</span>
<span style="color: #98fb98;">int</span> <span style="color: #87cefa;">trim</span>(<span style="color: #98fb98;">char</span> <span style="color: #eedd82;">s</span>[])
{
  <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">n</span>;
  <span style="color: #00ffff;">for</span> (n = strlen(s)-1; n &gt;= 0; n--)
    <span style="color: #00ffff;">if</span> (s[n] != <span style="color: #ffa07a;">' '</span> &amp;&amp; s[n] != <span style="color: #ffa07a;">'\t'</span> &amp;&amp; s[n] != <span style="color: #ffa07a;">'\n'</span>)
      <span style="color: #00ffff;">break</span>;
  s[n+1] = <span style="color: #ffa07a;">'\0'</span>;
  <span style="color: #00ffff;">return</span> n;
}
</pre>
</div>

<p>
<code>strlen</code> regresa la longitud de la cadena. El ciclo <code>for</code> inicia al
final y rastrea hacia atras, buscando el primer caracter que no sea
blanco o tabulador o nueva linea. El ciclo se interrumpe cuando se
encuentra alguno o cuando <code>n</code> se hace negativa (esto es, cuando se
ha rastreado toda la cadena. Se debera verificar que este
comportamiento es correcto, aun cuando la cadena este vacia o solo
contiene espatos en blanco.
</p>

<p>
La proposicion <code>continue</code> esta relacionada con el <code>break</code>, pero se
utiliza menos; Provoca que inicie la siguiente iteracion del ciclo
<code>for</code>, <code>while</code> o <code>do</code> que la contiene. Dentro de <code>while</code> y <code>do</code>,
esto significa que la parte de la prueba se ejecuta inmediatamente;
en el <code>for</code>, el control se traslada al paso de incremento. La
proposicion <code>continue</code> se aplica solamente a ciclos, no a
<code>switch</code>. Un <code>continue</code> dentro de un <code>switch</code> que esta a su vez en
un ciclo, provoca la siguiente iteracion del ciclo.
</p>

<p>
Como un ejemplo, el siguiente fragmento procesa solo los elementos
no negativos que estan en el arreglo <code>a</code>; los valores negativos son
ignorados.
</p>

<div class="org-src-container">
<pre class="src src-c"><span style="color: #00ffff;">for</span> (i = 0; i &lt; n; i++ ) {
  <span style="color: #00ffff;">if</span> (a[i] &lt; 0) <span style="color: #ff4500;">/* </span><span style="color: #ff4500;">ignora elementos negativos </span><span style="color: #ff4500;">*/</span>
    <span style="color: #00ffff;">continue</span>;
  ... <span style="color: #ff4500;">/* </span><span style="color: #ff4500;">trabaja con elementos positivos </span><span style="color: #ff4500;">*/</span>
}
</pre>
</div>

<p>
La proposicion <code>continue</code> se emplea a menudo cuando la parte del
ciclo que sigue es complicada, de modo que invertir la prueba y
sangrar otro nivel podria anidar profundamente el programa.
</p>
</div>
</div>

<div id="outline-container-orga5166c6" class="outline-3">
<h3 id="orga5166c6">3.8  <code>goto</code> y etiquetas                                            <a id="org0644439"></a></h3>
<div class="outline-text-3" id="text-orga5166c6">
<p>
C proporciona la infinitamente abusable proposicion <code>goto</code>, y
etiquetas para saltar hacia ellas. Formalmente, el <code>goto</code> nunca es
necesario, y en la practica es casi siempre mas facil escribir
codigo sin el. En este libro no se ha usado <code>goto</code> alguno.
</p>

<p>
Sin embargo, hay algunas situaciones donde los <code>goto</code> pueden
encontrar un lugar. La mas comun es abandonar el procesamiento en
alguna estructura profundamente anidada, tal como salir de dos o
mas ciclos a la vez. La proposicion <code>break</code> no se puede utilizar
directamente, puesto que solo sale del ciclo mas interno. Asi:
</p>

<div class="org-src-container">
<pre class="src src-c">  <span style="color: #00ffff;">for</span> ( ... )
    <span style="color: #00ffff;">for</span> ( ... ) {
      ...
      <span style="color: #00ffff;">if</span> (desastre)
        <span style="color: #00ffff;">goto</span> <span style="color: #7fffd4;">error</span>;
    }
  ...
error:
  <span style="color: #ff4500;">/* </span><span style="color: #ff4500;">arregla el desorden </span><span style="color: #ff4500;">*/</span>
</pre>
</div>

<p>
Esta organizacion es util si el codigo de manejo de error no es
trivial y si los errores pueden ocurrir en varios lugares.
</p>

<p>
Una etiqueta tiene la misma forma que un nombre de variable y es
seguida por dos puntos. Puede ser adherida a cualquier proposicion
de la misma funcion en la que esta el <code>goto</code>. El alcance de una
etiqueta es toda la funcion.
</p>

<p>
Como otro ejemplo, considerese el problema de determinar si dos
arreglos, <code>a</code> y <code>b</code>, tienen un elemento en comun. Una posibilidad
es
</p>

<div class="org-src-container">
<pre class="src src-c">  <span style="color: #00ffff;">for</span> (i = 0; i &lt; n; i++)
    <span style="color: #00ffff;">for</span> (j = 0; j &lt; m; j++)
      <span style="color: #00ffff;">if</span> (a[i] == b[j])
        <span style="color: #00ffff;">goto</span> <span style="color: #7fffd4;">encontrado</span>;
  <span style="color: #ff4500;">/* </span><span style="color: #ff4500;">no se encontro ningun elemento en comun </span><span style="color: #ff4500;">*/</span>
  ...
encontrado:
  <span style="color: #ff4500;">/* </span><span style="color: #ff4500;">se tiene uno: a[i] == b[j] </span><span style="color: #ff4500;">*/</span>
  ...
</pre>
</div>

<p>
El codigo que involucra un goto siempre puede escribirse sin el,
aunque tal vez al precio de algunas pruebas repetidas o variables
extra. Por ejemplo, la busqueda en los arreglos quedara
</p>

<div class="org-src-container">
<pre class="src src-c">encontrado = 0;
<span style="color: #00ffff;">for</span> (i = 0; i &lt; n &amp;&amp; !encontrado; i++)
  <span style="color: #00ffff;">for</span> (j = 0; j &lt; m &amp;&amp; !encontrado; j++)
    <span style="color: #00ffff;">if</span>(a[i] == b[j])
      encontrado = 1;
<span style="color: #00ffff;">if</span> (encontrado)
  <span style="color: #ff4500;">/* </span><span style="color: #ff4500;">se tiene uno: a[i-1] == b[j-1] </span><span style="color: #ff4500;">*/</span>
  ...
<span style="color: #00ffff;">else</span>
  <span style="color: #ff4500;">/* </span><span style="color: #ff4500;">no se encontro algun elemento en comun </span><span style="color: #ff4500;">*/</span>
  ...
</pre>
</div>

<p>
Con pocas excepciones, como las citadas aqui, el codigo que se basa
en proposiciones <code>goto</code> es generalmente mas dificil de entender y
de mantener que el codigo sin ellas. Aunque no somos dogmaticos
acerca del asunto, se ve que las proposiciones <code>goto</code> deben ser
utilizadas raramente, si acaso.
</p>
</div>
</div>
</div>

<div id="outline-container-orgf6a9aca" class="outline-2">
<h2 id="orgf6a9aca">capitulo 4: Funciones y la estructura del programa                  <a id="org05a38fc"></a></h2>
<div class="outline-text-2" id="text-orgf6a9aca">
<p>
Las funciones dividen tareas grandes de computacion en varias mas
pequeñas, y permiten la posibilidad de construir sobre lo que otros
ya han hecho, en lugar de comenzar desde cero. Las funciones
apropiadas ocultan los detalles de operacion de las partes del
programa que no necesitan saber acerca de ellos, asi que dan
claridad a la totalidad y facilitan la penosa tarea de hacer
cambios.
</p>

<p>
El lenguaje C se diseño para hacer que las funciones fueran
eficientes y faciles de usar; los programas escritos en C se
componen de muchas funciones pequeñas en lugar de solo algunas
grandes. Un programa puede residir en uno o mas archivos fuente, los
cuales pueden compilarse por separado y cargarse junto con funciones
de biblioteca previamente compiladas. No trataremos aqui tales
procesos, puesto que los detalles varian de un sistema a otro.
</p>

<p>
La declaracion y definicion de funciones es el area donde el
estandar ANSI ha hecho los cambios mas visibles a C. Tal como
mencionamos en el <a href="#orgc16243d">capitulo 1</a>, ahora es posible declarar los tipos de
los argumentos cuando se declara una funcion. La sintaxis de la
definicion de funciones tambien cambia, de modo que las
declaraciones y las definiciones coincidan. Esto hace posible que el
compilador pueda detectar muchos mas errores de lo que podia
anteriormente. Ademas, cuando los argumentos se declaran con
propiedad, se realizan automaticamente las conversiones
convenientes.
</p>

<p>
El estandar clarifica las reglas sobre el alcance de los nombres; en
particular, requiere que solo haya una definicion de cada objeto
externo. La inicializacion es mas general: los arreglos y las
estructuras automaticas ahora se pueden inicializar.
</p>

<p>
El preprocesador de C tambien se ha mejorado. Las nuevas facilidades
del procesador incluyen un conjunto mas completo de directivas para
la compilacion condicional, una forma de crear cadenas
entrecomilladas a partir de argumentos, macros y un mejor control
sobre el proceso de expansion de macros.
</p>
</div>

<div id="outline-container-orgcb61671" class="outline-3">
<h3 id="orgcb61671">4.1  Conceptos basicos de funciones                                <a id="org4bf01e4"></a></h3>
<div class="outline-text-3" id="text-orgcb61671">
<p>
Para comenzar, diseñemos y escribamos un programa que imprima cada
linea de su entrada que contenga un "patron" o cadena de caracteres
en particular. (Este es un caso especial del programa <code>grep</code> de
UNIX.) Por ejemplo, al buscar el patron de letras "ould" en el
conjunto de lineas
</p>

<p class="verse">
Ah Love! could you and I with Fate conspire<br />
To grasp this sorry Scheme of Things entire,<br />
Would not we shatter it to bits &#x2013; and then<br />
Re-mould it nearer to the Heart's Desire!<br />
</p>

<p>
producira la salida
</p>

<p class="verse">
Ah Love! could you and I with Fate conspire<br />
Would not we shatter it to bits &#x2013; and then<br />
Re-mould it nearer to the Heart's Desire!<br />
</p>

<p>
El trabajo se ajusta ordenadamente en tres partes:
</p>

<div class="org-src-container">
<pre class="src src-c"><span style="color: #00ffff;">while</span> (hay <span style="color: #98fb98;">otra</span> <span style="color: #eedd82;">linea</span>)
  <span style="color: #00ffff;">if</span> (la linea contiene <span style="color: #98fb98;">el</span> <span style="color: #eedd82;">patron</span>)
    imprimela
</pre>
</div>

<p>
Aunque ciertamente es posible poner el codigo de todo esto en
<code>main</code>, una mejor forma es aprovechar la estructura haciendo de
cada parte una funcion separada. Es mas facil trabajar con tres
piezas pequeñas que con una grande, debido a que los detalles
irrelevantes se pueden ocultar dentro de las funciones, y minimizar
asi el riesgo de interacciones no deseadas. Los fragmentos incluso
se pueden emplear en otros programas.
</p>

<p>
"Mientras hay otra linea" es <code>getline</code>, funcion que ya escribimos
en el <a href="#orgc16243d">capitulo 1</a>, e "imprimela" es <a href="#org0458a76"><code>printf</code></a>, que alguien ya nos
proporciono. Esto significa que solo necesitamos escribir una
rutina para decidir si la linea contiene una ocurrencia del patron.
</p>

<p>
Podemos resolver ese problema escribiendo una funcion
<code>strindex(s,t)</code>, que regresa la posicion o indice en la cadena <code>s</code>
en donde comienza la cadena <code>t</code>, o <code>-1</code> si <code>s</code> no contiene
<code>t</code>. Debido a que los arreglos en C principian en la posicion cero,
los indices seran cero o positivos, y asi un valor negativo como
<code>-1</code> es conveniente para señalar una falla. Cuando posteriormente
se necesite una coincidencia de patrones mas elaborada, solo se
debe reemplazar <code>strindex</code>; el resto del codigo puede permanecer
igual. (La biblioteca estandar provee una funcion <code>strstr</code> que es
semejante a <code>strindex</code>, excepto en que regresa un apuntador en
lugar de un indice.)
</p>

<p>
Una vez definido todo este diseño, llenar los detalles del programa
es simple. Aqui esta en su totalidad, de modo que se puede ver como
las piezas quedan juntas. Por ahora, el patron que se buscara es
una cadena literal, lo cual no es el mecanismo mas general.
Regresaremos en breve a una discusion sobre como inicializar
arreglos de caracteres, y en el <a href="#org69d49af">capitulo 5</a> mostraremos como hacer
que el patron de caracteres sea un parametro fijado cuando se
ejecuta el programa. Tambien hay una version ligeramente diferente
de <code>getline</code>, que se podra comparar con la del <a href="#orgc16243d">capitulo 1</a>.
</p>

<div class="org-src-container">
<pre class="src src-c"><span style="color: #b0c4de;">#include</span> <span style="color: #ffa07a;">&lt;stdio.h&gt;</span>
<span style="color: #b0c4de;">#define</span> <span style="color: #eedd82;">MAXLINE</span> 1000 <span style="color: #ff4500;">/* </span><span style="color: #ff4500;">longitud maxima por linea de entrada </span><span style="color: #ff4500;">*/</span>

<span style="color: #98fb98;">int</span> <span style="color: #87cefa;">getLine</span>(<span style="color: #98fb98;">char</span> <span style="color: #eedd82;">line</span>[], <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">max</span>);
<span style="color: #98fb98;">int</span> <span style="color: #87cefa;">strindex</span>(<span style="color: #98fb98;">char</span> <span style="color: #eedd82;">source</span>[], <span style="color: #98fb98;">char</span> <span style="color: #eedd82;">searchfor</span>[]);
<span style="color: #98fb98;">char</span> <span style="color: #eedd82;">pattern</span>[] = <span style="color: #ffa07a;">"ould"</span>; <span style="color: #ff4500;">/* </span><span style="color: #ff4500;">patron por buscar </span><span style="color: #ff4500;">*/</span>

<span style="color: #ff4500;">/* </span><span style="color: #ff4500;">encuentra todas las lineas que coincidan con el patron </span><span style="color: #ff4500;">*/</span>
<span style="color: #87cefa;">main</span>()
{
  <span style="color: #98fb98;">char</span> <span style="color: #eedd82;">line</span>[MAXLINE];
  <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">found</span> = 0;

  <span style="color: #00ffff;">while</span> (getLine(line, MAXLINE) &gt; 0)
    <span style="color: #00ffff;">if</span> (strindex(line, pattern) &gt;= 0) {
      printf(<span style="color: #ffa07a;">"%s"</span>, line);
      found++;
    }
  <span style="color: #00ffff;">return</span> found;
}

<span style="color: #ff4500;">/* </span><span style="color: #ff4500;">getLine: trae linea y la pone en s, regresa su longitud </span><span style="color: #ff4500;">*/</span>
<span style="color: #98fb98;">int</span> <span style="color: #87cefa;">getLine</span>(<span style="color: #98fb98;">char</span> <span style="color: #eedd82;">s</span>[], <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">lim</span>)
{
  <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">c</span>, <span style="color: #eedd82;">i</span>;
  i = 0;
  <span style="color: #00ffff;">while</span> (--lim &gt; 0 &amp;&amp; (c=getchar()) != EOF &amp;&amp; c != <span style="color: #ffa07a;">'\n'</span>)
    s[i++] = c;
  <span style="color: #00ffff;">if</span> (c == <span style="color: #ffa07a;">'\n'</span>)
    s[i++] = c;
  s[i] = <span style="color: #ffa07a;">'\0'</span>;
  <span style="color: #00ffff;">return</span> i;
}

<span style="color: #ff4500;">/* </span><span style="color: #ff4500;">strindex: regresa el indice de t en s, -1 si no existe </span><span style="color: #ff4500;">*/</span>
<span style="color: #98fb98;">int</span> <span style="color: #87cefa;">strindex</span>(<span style="color: #98fb98;">char</span> <span style="color: #eedd82;">s</span>[], <span style="color: #98fb98;">char</span> <span style="color: #eedd82;">t</span>[])
{
  <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">i</span>, <span style="color: #eedd82;">j</span>, <span style="color: #eedd82;">k</span>;
  <span style="color: #00ffff;">for</span> (i = 0; s[i] != <span style="color: #ffa07a;">'\0'</span>; i++) {
    <span style="color: #00ffff;">for</span> (j=i, k=0; t[k]!=<span style="color: #ffa07a;">'\0'</span> &amp;&amp; s[j]==t[k]; j++, k++)
      ;
    <span style="color: #00ffff;">if</span> (k &gt; 0 &amp;&amp; t[k] == <span style="color: #ffa07a;">'\0'</span>)
      <span style="color: #00ffff;">return</span> i;
  }
  <span style="color: #00ffff;">return</span> -1;
}
</pre>
</div>

<p>
Cada definicion de funcion tiene la forma
</p>

<div class="org-src-container">
<pre class="src src-c">tipo-regresado nombre-de-funcion(declaraciones <span style="color: #98fb98;">de</span> <span style="color: #eedd82;">argumentos</span>)
{
  declaraciones <span style="color: #98fb98;">y</span> <span style="color: #eedd82;">proposiciones</span>
}
</pre>
</div>

<p>
Varias partes pueden omitirse; una funcion minima es
</p>

<div class="org-src-container">
<pre class="src src-c"><span style="color: #87cefa;">nada</span>() {}
</pre>
</div>

<p>
que no hace ni regresa nada. Una funcion <i>hacer-nada</i>, como esta,
es algunas veces util para reservar lugar al desarrollar un
programa. Si el tipo que regresa se omite, se supone <code>int</code>.
</p>

<p>
Un programa es solo un conjunto de definiciones de variables y
funciones. La comunicacion entre funciones es por argumentos y
valores regresados por las funciones, y a traves de variables
externas. Las funciones pueden presentarse en cualquier orden
dentro del archivo fuente, y el programa fuente se puede dividir en
varios archivos, mientras las funciones no se dividan.
</p>

<p>
La proposicion <code>return</code> es el mecanismo para que la funcion que se
llama regrese un valor a su invocador. Al <code>return</code> le puede seguir
cualquier expresion:
</p>

<div class="org-src-container">
<pre class="src src-c"><span style="color: #00ffff;">return</span> expresion;
</pre>
</div>

<p>
La expresion se convertira al tipo de retorno de la funcion si es
necesario. Con frecuencia se utilizan parentesis para encerrar la
expresion, pero son optativos.
</p>

<p>
La funcion que llama tiene la libertad de ignorar el valor
regresado. Incluso, no hay necesidad de una expresion despues de
<code>return</code>; en tal caso, ningun valor regresa al invocador. Tambien
el control regresa, sin valor, cuando la ejecucion "cae al final"
de la funcion al alcanzar la llave derecha que cierra. No es
ilegal, aunque probablemente un signo de problemas, el que una
funcion regrese un valor desde un lugar y ninguno desde otro. En
cualquier caso, si una funcion no regresa explicitamente un valor,
su "valor" es ciertamente basura.
</p>

<p>
El programa de busqueda del patron regresa un estado desde <code>main</code>,
el numero de coincidencias encontradas. Este valor esta disponible
para ser empleado por el medio ambiente que llamo al programa.
</p>

<p>
El mecanismo de como compilar y cargar un programa en C que reside
en varios archivos fuente varia de un sistema a otro. En el sistema
UNIX, por ejemplo, la orden <code>cc</code> mencionada en el <a href="#orgc16243d">capitulo 1</a> hace
el trabajo. Supongase que las tres funciones se almacenan en tres
archivos llamados <code>main.c</code>, <code>getline.c</code>, y <code>strindex.c</code>. Entonces
la orden
</p>

<div class="org-src-container">
<pre class="src src-sh">cc main.c getline.c strindex.c
</pre>
</div>

<p>
compila los tres archivos, situa el codigo objeto resultante en los
archivos <code>main.o</code>, <code>getline.o</code>, y <code>strindex.o</code>, y despues los carga
todos dentro de un archivo ejecutable llamado <code>a.out</code>. Si existe un
error, digamos en <code>main.c</code>, ese archivo puede volverse a compilar
por si mismo y el resultado cargado con los archivos objeto
previos, con la orden.
</p>

<div class="org-src-container">
<pre class="src src-sh">cc main.c getline.o strindex.o
</pre>
</div>

<p>
<code>cc</code> emplea la convencion ".c" contra ".o" para distinguir los
archivos fuente de los archivos objeto.
</p>

<p>
<b>Ejercicio 4-1</b>. Escriba la funcion <code>strindex(s,t)</code>, que regresa la
posicion de la ocurrencia de mas a la derecha de <code>t</code> en <code>s</code>, o <code>-1</code>
si no hay alguna.
</p>
</div>
</div>

<div id="outline-container-orgc06f3b2" class="outline-3">
<h3 id="orgc06f3b2">4.2  Funciones que regresan valores no enteros                     <a id="org222dad5"></a></h3>
<div class="outline-text-3" id="text-orgc06f3b2">
<p>
Hasta ahora los ejemplos de funciones han regresado o ningun valor
(<code>void</code>) o un <code>int</code>. ¿Que pasa si una funcion debe regresar algo de
otro tipo? Muchas funciones numericas como <code>sqrt</code>, <code>sin</code> y <code>cos</code>
regresan <code>double</code>; otras funciones especializadas regresan tipos
diferentes. Para ilustrar como tratar con esto, escribamos y usemos
la funcion <code>atof(s)</code>, que convierte la cadena <code>s</code> a su valor
equivalente de punto flotante de doble precision. La funcion <a href="#org9f52a73"><code>atof</code></a>
es una extension de <a href="#orgdd02576"><code>atoi</code></a>, de la que mostramos versiones en los
capitulos <a href="#org29d5b55">2</a> y <a href="#org35eee87">3</a>. Maneja signo y punto decimal optativos, y
presencia o ausencia de parte entera o fraccionaria. Nuestra
version no es una rutina de conversion de alta calidad; tomaria mas
espacio del que podemos dedicarle. La biblioteca estandar incluye
un <a href="#orgdd02576"><code>atoi</code></a>; el <i>header</i> <code>&lt;math.h&gt;</code> la declara.
</p>

<p>
Primero, <a href="#org9f52a73"><code>atof</code></a> por si misma debe declarar el tipo del valor que
regresa, puesto que no es <code>int</code>. El nombre del tipo precede al
nombre de la funcion:
</p>

<div class="org-src-container">
<pre class="src src-c"><span style="color: #b0c4de;">#include</span> <span style="color: #ffa07a;">&lt;ctype.h&gt;</span>

<span style="color: #ff4500;">/* </span><span style="color: #ff4500;">atof: convierte la cadena s a double </span><span style="color: #ff4500;">*/</span>
<span style="color: #98fb98;">double</span> <span style="color: #87cefa;">atof</span>(<span style="color: #98fb98;">char</span> <span style="color: #eedd82;">s</span>[])
{
  <span style="color: #98fb98;">double</span> <span style="color: #eedd82;">val</span>, <span style="color: #eedd82;">power</span>;
  <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">i</span>, <span style="color: #eedd82;">sign</span>;

  <span style="color: #00ffff;">for</span> (i = 0; isspace(s[i]); i++) <span style="color: #ff4500;">/* </span><span style="color: #ff4500;">ignora espacios blancos </span><span style="color: #ff4500;">*/</span>
    ;
  sign = (s[i] == <span style="color: #ffa07a;">'-'</span>) ? -1 : 1;
  <span style="color: #00ffff;">if</span> (s[i] == <span style="color: #ffa07a;">'+'</span> || s[i] == <span style="color: #ffa07a;">'-'</span>)
    i++;
  <span style="color: #00ffff;">for</span> (val = 0.0; isdigit(s[i]); i++)
    val = 10.0 * val + (s[i] - <span style="color: #ffa07a;">'0'</span>);
  <span style="color: #00ffff;">if</span> (s[i] == <span style="color: #ffa07a;">'.'</span>)
    i++;
  <span style="color: #00ffff;">for</span> (power = 1.0; isdigit(s[i]); i++) {
    val = 10.0 * val + (s[i] - <span style="color: #ffa07a;">'0'</span>);
    power *= 10;
  }
  <span style="color: #00ffff;">return</span> sign * val / power;
}
</pre>
</div>

<p>
Segundo, e igualmente importante, la rutina que llama debe indicar
que <a href="#org9f52a73"><code>atof</code></a> regresa un valor que no es <code>int</code>. Una forma de asegurar esto
es declarar <a href="#org9f52a73"><code>atof</code></a> explicitamente en la rutina que la llama. La
declaracion se muestra en esta primitiva calculadora (apenas
adecuada para un balance de chequera), que lee un numero por linea,
precedido en forma optativa por un signo, y lo acumula, imprimiendo
la suma actual despues de cada entrada:
</p>

<div class="org-src-container">
<pre class="src src-c"><span style="color: #b0c4de;">#include</span> <span style="color: #ffa07a;">&lt;stdio.h&gt;</span>

<span style="color: #b0c4de;">#define</span> <span style="color: #eedd82;">MAXLINE</span> 100

<span style="color: #ff4500;">/* </span><span style="color: #ff4500;">calculadora rudimentaria </span><span style="color: #ff4500;">*/</span>
<span style="color: #87cefa;">main</span>()
{
  <span style="color: #98fb98;">double</span> <span style="color: #eedd82;">sum</span>, <span style="color: #87cefa;">atof</span>(<span style="color: #98fb98;">char</span> []);
  <span style="color: #98fb98;">char</span> <span style="color: #eedd82;">line</span>[MAXLINE];
  <span style="color: #98fb98;">int</span> <span style="color: #87cefa;">getline</span>(<span style="color: #98fb98;">char</span> <span style="color: #eedd82;">line</span>[], <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">max</span>);

  sum = 0;
  <span style="color: #00ffff;">while</span> (getline(line, MAXLINE) &gt; 0)
    printf(<span style="color: #ffa07a;">"\t%g\n"</span>, sum += atof(line));
  <span style="color: #00ffff;">return</span> 0;
}
</pre>
</div>

<p>
La declaracion
</p>

<div class="org-src-container">
<pre class="src src-c"><span style="color: #98fb98;">double</span> <span style="color: #eedd82;">sum</span>, <span style="color: #87cefa;">atof</span>(<span style="color: #98fb98;">char</span> []);
</pre>
</div>

<p>
señala que <code>sum</code> es una variable <code>double</code>, y que <a href="#org9f52a73"><code>atof</code></a> es una funcion
que toma un argumento <code>char[]</code> y regresa un <code>double</code>.
</p>

<p>
La funcion <a href="#org9f52a73"><code>atof</code></a> se debe declarar y definir consistentemente. Si
<a href="#org9f52a73"><code>atof</code></a> en si misma y la llamada a ella en <code>main</code> tienen tipos
inconsistentes dentro del mismo archivo fuente, el error sera
detectado por el compilador. Pero si (como es probable) <a href="#org9f52a73"><code>atof</code></a>
fuera compilada separadamente, la falta de consistencia no se
detectaria, <a href="#org9f52a73"><code>atof</code></a> regresaria un valor <code>double</code> que <code>main</code> trataria
como <code>int</code>, y se producirian resultados incongruentes.
</p>

<p>
A la luz de lo que hemos mencionado acerca de como deben coincidir
las declaraciones con las definiciones, esto podria ser
sorprendente. La razon de que ocurra una falta de coincidencia es
que, si no existe el prototipo de una funcion, esta es declarada
implicitamente la primera vez que aparece en una expresion, como
</p>

<div class="org-src-container">
<pre class="src src-c">sum += atof(line)
</pre>
</div>

<p>
Si en una expresion se encuentra un nombre que no ha sido declarado
previamente y esta seguido por parentesis izquierdo, se declara por
contexto, de modo que se supone que es el nombre de una funcion que
regresa un <code>int</code>, y nada se supone acerca de sus argumentos. Aun
mas, si la declaracion de una funcion no incluye argumentos como en
</p>

<div class="org-src-container">
<pre class="src src-c"><span style="color: #98fb98;">double</span> <span style="color: #87cefa;">atof</span>();
</pre>
</div>

<p>
tambien es tomada de modo que no se supone nada acerca de los
argumentos de <a href="#org9f52a73"><code>atof</code></a>; se desactiva toda revision de
parametros. Este significado especial de la lista de argumentos
vacia se hace para permitir que los programas en C viejos se
compilen con los nuevos compiladores. Pero es una mala tactica usar
esto con programas nuevos. Si la funcion toma argumentos,
declarelos; si no los toma, use <code>void</code>.
</p>

<p>
Dado <a href="#org9f52a73"><code>atof</code></a>, propiamente declarado, podemos escribir <a href="#orgdd02576"><code>atoi</code></a>
(convierte una cadena a <code>int</code>) en terminos de el:
</p>

<div class="org-src-container">
<pre class="src src-c"><span style="color: #ff4500;">/* </span><span style="color: #ff4500;">atoi: convierte la cadena s a entero usando atof </span><span style="color: #ff4500;">*/</span>
<span style="color: #98fb98;">int</span> <span style="color: #87cefa;">atoi</span>(<span style="color: #98fb98;">char</span> <span style="color: #eedd82;">s</span>[])
{
  <span style="color: #98fb98;">double</span> <span style="color: #87cefa;">atof</span>(<span style="color: #98fb98;">char</span> <span style="color: #eedd82;">s</span>[]);
  <span style="color: #00ffff;">return</span> (<span style="color: #98fb98;">int</span>) atof(s);
}
</pre>
</div>

<p>
Notese la estructura de las declaraciones y la proposicion
<code>return</code>. El valor de la expresion en
</p>

<div class="org-src-container">
<pre class="src src-c"><span style="color: #00ffff;">return</span> expresion;
</pre>
</div>

<p>
se convierte al tipo de la funcion antes de que se tome el
<code>return</code>. Por lo tanto, el valor de <a href="#org9f52a73"><code>atof</code></a>, un <code>double</code>, se
convierte automaticamente a <code>int</code> cuando aparece en este <code>return</code>,
puesto que la funcion <a href="#orgdd02576"><code>atoi</code></a> regresa un <code>int</code>. Sin embargo, esta
operacion potencialmente descarta informacion, asi que algunos
compiladores lo previenen. El <i>cast</i> establece explicitamente lo
que la operacion intenta y suprime las advertencias.
</p>

<p>
<b>Ejercicio 4-2</b>. Extienda <a href="#org9f52a73"><code>atof</code></a> para que maneje notacion
cientifica de la forma
</p>

<div class="org-src-container">
<pre class="src src-c">123.45e-6
</pre>
</div>

<p>
donde un numero de punto flotante puede ir seguido por <code>e</code> o <code>E</code> y
opcionalmente un exponente con signo.
</p>
</div>
</div>

<div id="outline-container-org5eb7291" class="outline-3">
<h3 id="org5eb7291">4.3  Variables externas                                            <a id="org043af2c"></a></h3>
<div class="outline-text-3" id="text-org5eb7291">
<p>
Un programa en C consta de un conjunto de objetos externos, que son
variables o funciones. El adjetivo "externo" se emplea en contraste
con "interno", que describe los argumentos y las variables
definidas dentro de las funciones. Las variables externas se
definen fuera de cualquier funcion, y por lo tanto, estan
potencialmente disponibles para muchas funciones. Las funciones en
si mismas son siempre externas, puesto que C no permite definir
funciones dentro de otras funciones. Por omision, las variables y
funciones externas tienen la propiedad de que todas las referencias
a ellas por el mismo nombre, incluso desde funciones compiladas
separadamente, son referencias a la misma cosa. (El estandar llama
a esta propiedad <i>ligado externo</i>.) En este sentido, las variables
externas son analogas a los bloques COMMON de Fortran o a las
variables del bloque mas externo de Pascal. Mas adelante veremos
como definir variables y funciones externas que sean visibles solo
dentro de un archivo fuente.
</p>

<p>
Debido a que las variables externas son accesibles globalmente,
proporcionan una alternativa a los argumentos en funciones y a los
valores de retorno para comunicar datos entre
funciones. Cualquier funcion puede tener acceso a variables
externas haciendo referencia a ellas solamente por su nombre, si
este ha sido declarado de alguna manera.
</p>

<p>
Si un gran numero de variables se debe compartir entre funciones,
las variables externas son mas covenientes y eficientes que las
largas listas de argumentos. Sin embargo, como se señalo en el
<a href="#orgc16243d">capitulo 1</a>, este razonamiento se debera aplicar con precaucion,
pues puede tener un efecto negativo sobre la estructura del
programa y dar lugar a programas con demasiadas conexiones de datos
entre funciones.
</p>

<p>
Las variables externas son tambien utiles debido a su mayor alcance
y tiempo de vida. Las variables automaticas son internas a una
funcion y su existencia se inicia cuando se entra a la funcion y
desaparecen cuando esta se abandona. Por otro lado, las variables
externas son permanentes, de modo que retienen sus valores de la
invocacion de una funcion a la siguiente. Asi, si dos funciones
deben compartir algunos datos, aun si ninguna llama a la otra, con
frecuencia es mas conveniente que los datos compartidos se
mantengan en variables externas, en lugar de que sean pasados como
argumentos de entrada y salida.
</p>

<p>
Examinemos mas a fondo este tema con un ejemplo mas amplio. El
problema es escribir el programa de una calculadora que provea los
operadores <code>+</code>, <code>-</code>, <code>*</code> y <code>/</code>. Por ser mas facil su implantacion,
la calculadora utilizara notacion polaca inversa en lugar de
infija. (La polaca inversa es utilizada por algunas calculadoras de
bolsillo, y en lenguajes como Forth y PostScript.)
</p>

<p>
En notacion polaca inversa, cada operador sigue a sus operandos;
una expresion infija como
</p>

<pre class="example">
(1 - 2) * (4 + 5)
</pre>

<p>
se introduce como
</p>

<pre class="example">
1 2 - 4 5 + *
</pre>

<p>
Los parentesis no son necesarios; la notacion no es ambigua
mientras sepamos cuantos operandos espera cada operador.
</p>

<p>
La implantacion es simple. Cada operando se introduce en una pila o
stack; cuando un operador llega, el numero correcto de operandos
(dos para operadores binarios) son extraidos, se aplica el operador
y el resultado se regresa a la pila. En el ejemplo anterior, se
introducen 1 y 2, despues se reemplazan por su diferencia, -1. En
seguida se introducen 4 y 5 y luego se reemplazan por su
suma, 9. El producto de -1 y 9, que es -9, los reemplaza en la
pila. El valor que se encuentra en el tope de la pila se extrae e
imprime cuando se encuentra el fin de la linea de entrada.
</p>

<p>
La estructura del programa es asi un ciclo que realiza las
operaciones adecuadas sobre cada operador y operando que aparece:
</p>

<div class="org-src-container">
<pre class="src src-c"><span style="color: #00ffff;">while</span> (siguiente operador u operando no es fin <span style="color: #98fb98;">de</span> <span style="color: #eedd82;">archivo</span>)
  <span style="color: #00ffff;">if</span> (numero)
    introducirlo
  <span style="color: #00ffff;">else</span> <span style="color: #00ffff;">if</span> (operador)
    extraer operandos
    hacer operaciones
    introducir <span style="color: #98fb98;">el</span> <span style="color: #87cefa;">resultado</span>
  <span style="color: #00ffff;">else</span> <span style="color: #00ffff;">if</span> (<span style="color: #98fb98;">nueva</span> <span style="color: #eedd82;">linea</span>)
    extrae e imprime <span style="color: #98fb98;">el</span> tope <span style="color: #98fb98;">de</span> <span style="color: #98fb98;">la</span> <span style="color: #eedd82;">pila</span>
  <span style="color: #00ffff;">else</span>
    error
</pre>
</div>

<p>
Las operaciones de introducir (<code>push</code>) y extraer de una pila
(<code>pop</code>) son sencillas, Pero cuando se les agrega deteccion y
recuperacion de errores, son suficientemenfe largas como para que
sea mejor ponerlas en funciones separadas en lugar del codigo a lo
largo de todo el programa. Ademas, debe existir una funcion
separada para buscar el siguiente operador u operando.
</p>

<p>
La principal decision de diseño que aun no se ha explicado es donde
esta la pila, esto es, cuales rutinas tienen acceso a ella
directamente. Una posibilidad es mantenerla en <code>main</code>, y pasar la
pila y la posicion actual a las rutinas que introducen y extraen
elementos. Pero <code>main</code> no necesita saber acerca de las variables
que controlan a la pila; solo efectua operaciones de introducir y
extraer. Asi, hemos decidido almacenar la pila y su informacion
asociada en variables externas accesibless a las funciones <code>push</code> y
<code>pop</code>, pero no a <code>main</code>.
</p>

<p>
Traducir este bosquejo a codigo es suficientemente facil. Si por
ahora pensamos que el programa existe en un archivo fuente, se vera
asi:
</p>

<div class="org-center">
<div class="org-src-container">
<pre class="src src-c"><span style="color: #b0c4de;">#includeS</span>
<span style="color: #b0c4de;">#defineS</span>
</pre>
</div>

<p>
declaracion de funciones para <code>main</code>
</p>

<div class="org-src-container">
<pre class="src src-c"><span style="color: #87cefa;">main</span>() { ... }
</pre>
</div>

<p>
variables externas para <code>push</code> y <code>pop</code>
</p>

<div class="org-src-container">
<pre class="src src-c"><span style="color: #98fb98;">void</span> <span style="color: #87cefa;">push</span>(<span style="color: #98fb98;">double</span> <span style="color: #eedd82;">f</span>) { ... }
<span style="color: #98fb98;">double</span> <span style="color: #87cefa;">pop</span>(<span style="color: #98fb98;">void</span>) { ... }

<span style="color: #98fb98;">int</span> <span style="color: #87cefa;">getop</span>(<span style="color: #98fb98;">char</span> <span style="color: #eedd82;">s</span>[]) { ... }
</pre>
</div>

<p>
rutinas llamadas por <code>getop</code>
</p>
</div>

<p>
Mas adelante se vera como esto se puede dividir entre dos o mas
archivos fuente.
</p>

<p>
La funcion <code>main</code> es un ciclo que contiene un gran <code>switch</code> sobre
el tipo de operador y operando; este es un uso del <code>switch</code> mas
tipico que el mostrado en la <a href="#org0173be2">seccion 3.4</a>.
</p>

<div class="org-src-container">
<pre class="src src-c"><span style="color: #b0c4de;">#include</span> <span style="color: #ffa07a;">&lt;stdio.h&gt;</span>
<span style="color: #b0c4de;">#include</span> <span style="color: #ffa07a;">&lt;stdlib.h&gt;</span>  <span style="color: #ff4500;">/* </span><span style="color: #ff4500;">para atof() </span><span style="color: #ff4500;">*/</span>

<span style="color: #b0c4de;">#define</span> <span style="color: #eedd82;">MAXOP</span>   100  <span style="color: #ff4500;">/* </span><span style="color: #ff4500;">max tama&#241;o de operando u operador </span><span style="color: #ff4500;">*/</span>
<span style="color: #b0c4de;">#define</span> <span style="color: #eedd82;">NUMBER</span>  <span style="color: #ffa07a;">'0'</span>  <span style="color: #ff4500;">/* </span><span style="color: #ff4500;">se&#241;al de que un numero se encontro </span><span style="color: #ff4500;">*/</span>

<span style="color: #98fb98;">int</span> <span style="color: #87cefa;">getop</span>(<span style="color: #98fb98;">char</span> []);
<span style="color: #98fb98;">void</span> <span style="color: #87cefa;">push</span>(<span style="color: #98fb98;">double</span>);
<span style="color: #98fb98;">double</span> <span style="color: #87cefa;">pop</span>(<span style="color: #98fb98;">void</span>);

<span style="color: #ff4500;">/* </span><span style="color: #ff4500;">calculadora polaca inversa </span><span style="color: #ff4500;">*/</span>
<span style="color: #87cefa;">main</span>()
{
  <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">type</span>;
  <span style="color: #98fb98;">double</span> <span style="color: #eedd82;">op2</span>;
  <span style="color: #98fb98;">char</span> <span style="color: #eedd82;">s</span>[MAXOP];
  <span style="color: #00ffff;">while</span> ((type = getop(s)) != EOF) {
    <span style="color: #00ffff;">switch</span> (type) {
    <span style="color: #00ffff;">case</span> NUMBER:
      push(atof(s));
      <span style="color: #00ffff;">break</span>;
    <span style="color: #00ffff;">case</span> <span style="color: #ffa07a;">'+'</span>:
      push(pop() + pop());
      <span style="color: #00ffff;">break</span>;
    <span style="color: #00ffff;">case</span> <span style="color: #ffa07a;">'*'</span>:
      push(pop() * pop());
      <span style="color: #00ffff;">break</span>;
    <span style="color: #00ffff;">case</span> <span style="color: #ffa07a;">'-'</span>:
      op2 = pop();
      push(pop() - op2);
      <span style="color: #00ffff;">break</span>;
    <span style="color: #00ffff;">case</span> <span style="color: #ffa07a;">'/'</span>:
      op2 = pop();
      <span style="color: #00ffff;">if</span> (op2 != 0.0)
        push(pop() / op2);
      <span style="color: #00ffff;">else</span>
        printf(<span style="color: #ffa07a;">"error: divisor cero\n"</span>);
      <span style="color: #00ffff;">break</span>;
    <span style="color: #00ffff;">case</span> <span style="color: #ffa07a;">'\n'</span>:
      printf(<span style="color: #ffa07a;">"\t%.8g\n"</span>, pop());
      <span style="color: #00ffff;">break</span>;
    <span style="color: #00ffff;">default</span>:
      printf(<span style="color: #ffa07a;">"error: comando desconocido %s\n"</span>, s);
      <span style="color: #00ffff;">break</span>;
    }
  }
  <span style="color: #00ffff;">return</span> 0;
}
</pre>
</div>

<p>
Puesto que <code>+</code> y <code>*</code> son operadores conmutativos, el orden en el
que se combinan los operandos extraidos es irrelevante, pero para
<code>-</code> y <code>/</code> deben distinguirse los operandos izquierdo y derecho. En
</p>

<div class="org-src-container">
<pre class="src src-c"><span style="color: #87cefa;">push</span>(<span style="color: #98fb98;">pop</span>() - pop()); <span style="color: #ff4500;">/* </span><span style="color: #ff4500;">INCORRECTO </span><span style="color: #ff4500;">*/</span>
</pre>
</div>

<p>
no se define el orden en el que se evaluan las dos llamadas de
<code>pop</code>. Para garantizar el orden correcto, es necesario extraer el
primer valor en una variable temporal, como se hizo en <code>main</code>.
</p>

<div class="org-src-container">
<pre class="src src-c"><span style="color: #b0c4de;">#define</span> <span style="color: #eedd82;">MAXVAL</span> 100   <span style="color: #ff4500;">/* </span><span style="color: #ff4500;">maxima profundidad de la pila val </span><span style="color: #ff4500;">*/</span>

<span style="color: #98fb98;">int</span> <span style="color: #eedd82;">sp</span> = 0;          <span style="color: #ff4500;">/* </span><span style="color: #ff4500;">siguiente posicion libre en la pila </span><span style="color: #ff4500;">*/</span>
<span style="color: #98fb98;">double</span> <span style="color: #eedd82;">val</span>[MAXVAL];  <span style="color: #ff4500;">/* </span><span style="color: #ff4500;">valores de la pila </span><span style="color: #ff4500;">*/</span>

<span style="color: #ff4500;">/* </span><span style="color: #ff4500;">push: introduce f a la pila </span><span style="color: #ff4500;">*/</span>
<span style="color: #98fb98;">void</span> <span style="color: #87cefa;">push</span>(<span style="color: #98fb98;">double</span> <span style="color: #eedd82;">f</span>)
{
  <span style="color: #00ffff;">if</span> (sp &lt; MAXVAL)
    val[sp++] = f;
  <span style="color: #00ffff;">else</span>
    printf(<span style="color: #ffa07a;">"error: pila llena, no puede efectuar push %g\n"</span>, f);
}

<span style="color: #ff4500;">/* </span><span style="color: #ff4500;">pop: extrae y regresa el valor superior de la pila </span><span style="color: #ff4500;">*/</span>
<span style="color: #98fb98;">double</span> <span style="color: #87cefa;">pop</span>(<span style="color: #98fb98;">void</span>)
{
  <span style="color: #00ffff;">if</span> (sp &gt; 0)
    <span style="color: #00ffff;">return</span> val[--sp];
  <span style="color: #00ffff;">else</span> {
    printf(<span style="color: #ffa07a;">"error: pila vacia\n"</span>);
    <span style="color: #00ffff;">return</span> 0.0;
  }
}
</pre>
</div>

<p>
Una variable es externa si se encuentra definida fuera de cualquier
funcion. Asi, la pila y el indice de la pila que deben ser
compartidos por <code>push</code> y por <code>pop</code> se definen fuera de estas
funciones. Pero <code>main</code> en si misma no hace referencia a la pila o a
la posicion de la pila – la representacion puede estar oculta.
</p>

<p>
Pasemos ahora a la implantacion de <code>getop</code>, la funcion que toma el
siguiente operador u operando. La tarea es facil. Ignorar blancos y
tabuladores. Si el siguiente caracter no es un digito o punto
decimal, regresarlo. De otra manera, reunir una cadena de digitos
(que pueda incluir un punto decimal), y regresar <code>NUMBER</code>, la señal
de que ha sido reunido un numero.
</p>

<div class="org-src-container">
<pre class="src src-c"><span style="color: #b0c4de;">#include</span> <span style="color: #ffa07a;">&lt;ctype.h&gt;</span>

<span style="color: #98fb98;">int</span> <span style="color: #87cefa;">getch</span>(<span style="color: #98fb98;">void</span>);
<span style="color: #98fb98;">void</span> <span style="color: #87cefa;">ungetch</span>(<span style="color: #98fb98;">int</span>);

<span style="color: #ff4500;">/* </span><span style="color: #ff4500;">getop: obtiene el siguiente operador u operando numerico </span><span style="color: #ff4500;">*/</span>
<span style="color: #98fb98;">int</span> <span style="color: #87cefa;">getop</span>(<span style="color: #98fb98;">char</span> <span style="color: #eedd82;">s</span>[])
{
  <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">i</span>, <span style="color: #eedd82;">c</span>;
  <span style="color: #00ffff;">while</span> ((s[0] = c = getch()) == <span style="color: #ffa07a;">' '</span> || c == <span style="color: #ffa07a;">'\t'</span>)
    ;
  s[1] = <span style="color: #ffa07a;">'\0'</span>;
  <span style="color: #00ffff;">if</span> (!isdigit(c) &amp;&amp; c != <span style="color: #ffa07a;">'.'</span>)
    <span style="color: #00ffff;">return</span> c;      <span style="color: #ff4500;">/* </span><span style="color: #ff4500;">no es un numero </span><span style="color: #ff4500;">*/</span>
  i = 0;
  <span style="color: #00ffff;">if</span> (isdigit(c))  <span style="color: #ff4500;">/* </span><span style="color: #ff4500;">reune la parte entera </span><span style="color: #ff4500;">*/</span>
    <span style="color: #00ffff;">while</span> (isdigit(s[++i] = c = getch()))
      ;
  <span style="color: #00ffff;">if</span> (c == <span style="color: #ffa07a;">'.'</span>)    <span style="color: #ff4500;">/* </span><span style="color: #ff4500;">reune la parte fraccionaria </span><span style="color: #ff4500;">*/</span>
    <span style="color: #00ffff;">while</span> (isdigit(s[++i] = c = getch()))
      ;
  s[i] = <span style="color: #ffa07a;">'\0'</span>;
  <span style="color: #00ffff;">if</span> (c != EOF)
    ungetch(c);
  <span style="color: #00ffff;">return</span> NUMBER;
}
</pre>
</div>

<p>
¿Que son <code>getch</code> y <code>ungetch</code>? Por lo comun se da el caso de que un
programa no puede determinar si ha leido suficiente de la entrada
hasta que ha leido demasiado. Un ejemplo es reunir los caracteres
que forman un numero: hasta que se vea el primer no-digito, el
numero no esta completo. Pero entonces el programa ha leido un
caracter de mas, para el cual no esta preparado.
</p>

<p>
El problema podria ser resuelto si fuera posible "desleer" el
caracter no deseado. Entonces, cada vez que el programa lea un
caracter de mas, podria regresarlo a la entrada, asi que el resto
del codigo se podra comportar como si nunca se hubiese
leido. Afortunadamente, es facil simular el regreso de un caracter,
escribiendo un par de funciones cooperativas, <code>getch</code> entrega el
siguiente caracter de la entrada que va a ser considerado;
<code>ungetch</code> reintegra el caracter devuelto a la entrada, de modo que
llamadas posteriores a <code>getch</code> lo regresaran antes de leer algo
nuevo de la entrada.
</p>

<p>
Como trabajan juntas es sencillo, <code>ungetch</code> coloca el caracter
regresado en un buffer compartido – un arreglo de caracteres,
<code>getch</code> lee del buffer si hay algo alli y llama a <a href="#org4d38061"><code>getchar</code></a> si el
buffer esta vacio. Tambien debe existir una variable indice que
registre la posicion del caracter actual en el buffer temporal.
</p>

<p>
Puesto que el buffer y el indice son compartidos por <code>getch</code> y
<code>ungetch</code> y deben retener sus valores entre llamadas, deben ser
externos a ambas rutinas. Asi, podemos escribir <code>getch</code>, <code>ungetch</code>
y sus variables compartidas como:
</p>

<div class="org-src-container">
<pre class="src src-c"><span style="color: #b0c4de;">#define</span> <span style="color: #eedd82;">BUFSIZE</span> 100

<span style="color: #98fb98;">char</span> <span style="color: #eedd82;">buf</span>[BUFSIZE];  <span style="color: #ff4500;">/* </span><span style="color: #ff4500;">buffer para ungetch </span><span style="color: #ff4500;">*/</span>
<span style="color: #98fb98;">int</span> <span style="color: #eedd82;">bufp</span> = 0;       <span style="color: #ff4500;">/* </span><span style="color: #ff4500;">siguiente posicion libre en buf </span><span style="color: #ff4500;">*/</span>

<span style="color: #98fb98;">int</span> <span style="color: #87cefa;">getch</span>(<span style="color: #98fb98;">void</span>)     <span style="color: #ff4500;">/* </span><span style="color: #ff4500;">obtiene un (posiblemente ya regresado) caracter </span><span style="color: #ff4500;">*/</span>
{
  <span style="color: #00ffff;">return</span> (bufp &gt; 0) ? buf[--bufp] : getchar();
}

<span style="color: #98fb98;">void</span> <span style="color: #87cefa;">ungetch</span>(<span style="color: #98fb98;">int</span> <span style="color: #eedd82;">c</span>) <span style="color: #ff4500;">/* </span><span style="color: #ff4500;">regresa caracter a la entrada </span><span style="color: #ff4500;">*/</span>
{
  <span style="color: #00ffff;">if</span> (bufp &gt;= BUFSIZE)
    printf(<span style="color: #ffa07a;">"ungetch: demasiados caracteres\n"</span>);
  <span style="color: #00ffff;">else</span>
    buf[bufp++] = c;
}
</pre>
</div>

<p>
La biblioteca estandar incluye una funcion <code>ungetch</code> que
proporciona el regreso de Un caracter; esto se vera en el
<a href="#orgf1abb1c">capitulo 7</a>. Se ha utilizado un arreglo para lo que se regresa a la
entrada, en lugar de un caracter sencillo, para dar una idea mas
general.
</p>

<p>
<b>Ejercicio 4-3</b>. Dada la estructura basica, es facil extender la
calculadora. Agregue el operador modulo (<code>%</code>) y consideraciones
para numeros negativos.
</p>

<p>
<b>Ejercicio 4-4</b>. Agregue ordenes para imprimir el elemento al tope
de la pila sin sacarlo de ella, para duplicarlo y para intercambiar
los dos elementos del tope. Agregue una orden para limpiar la pila.
</p>

<p>
<b>Ejercicio 4-5</b>. Agregue acceso a funciones de biblioteca como
<code>sin</code>, <code>exp</code> y <code>pow</code>. Consulte <code>&lt;math.h&gt;</code> en el <a href="#org89d4232">apendice B</a>,
seccion 4.
</p>

<p>
<b>Ejercicio 4-6</b>. Agregue ordenes para manipular variables. (Es
facil proporcionar veintiseis variables con nombres de una letra.)
Añada una variable para el valor impreso mas reciente.
</p>

<p>
<b>Ejercicio 4-7</b>. Escriba una rutina <code>ungets(s)</code> que regresa a la
entrada una cadena completa. ¿Debe <code>ungets</code> conocer acerca de <code>buf</code>
y <code>bufp</code>, o solo debe usar <code>ungetch</code>?
</p>

<p>
<b>Ejercicio 4-8</b>. Suponga que nunca existira mas de un caracter de
regreso. Modifique <code>getch</code> y <code>ungetch</code> de acuerdo con eso.
</p>

<p>
<b>Ejercicio 4-9</b>. Nuestros <code>getch</code> y <code>ungetch</code> no manejan
correctamente un <code>EOF</code> que se regresa. Decida cuales deben ser sus
propiedades si se regresa un <code>EOF</code>, y despues realice su diseño.
</p>

<p>
<b>Ejercicio 4-10</b>. Una organizacion alternativa emplea <code>getline</code>
para leer una linea completa de entrada; esto hace innecesarios a
<code>getch</code> y a <code>ungetch</code>. Corrija la calculadora para que use este
planteamiento.
</p>
</div>
</div>

<div id="outline-container-org92f5d93" class="outline-3">
<h3 id="org92f5d93">4.4  Reglas de alcance                                             <a id="orgb6a72f5"></a></h3>
<div class="outline-text-3" id="text-org92f5d93">
<p>
Las funciones y variables externas que constituyen un programa en C
no necesitan ser compiladas a la vez; el texto fuente del programa
se puede tener en varios archivos y se pueden cargar rutinas de
biblioteca previamente compiladas. Entre las preguntas de interes
estan
</p>

<ul class="org-ul">
<li>¿Como se escriben las declaraciones de modo que las variables
sean declaradas adecuadamente durante la compilacion?</li>

<li>¿Como se arreglan las declaraciones de modo que todas las piezas
se conecten adecuadamente cuando se carga el programa?</li>

<li>¿Como se organizan las declaraciones de modo que solo haya una
copia?</li>

<li>¿Como se inicializan las variables externas?</li>
</ul>


<p>
Discutamos estos temas reorganizando el programa de la calculadora
en varios archivos. En terminos practicos, la calculadora es
demasiado pequeña para que convenga separarla, pero es una
excelente ilustracion de los conceptos que surgen en programas
mayores.
</p>

<p>
El alcance de un nombre es la parte del programa dentro del cual se
puede usar el nombre. Para una variable automatica declarada al
principio de una funcion, el alcance es la funcion dentro de la
cual esta declarado el nombre. Las variables locales con el mismo
nombre que esten en funciones diferentes no tienen relacion. Lo
mismo es valido para los parametros de una funcion, que en efecto
son variables locales.
</p>

<p>
El <i>alcance</i> de una variable o funcion externa abarca desde el
punto en que se declara hasta el fin del archivo que se esta
compilando. Por ejemplo, si <code>main</code>, <code>sp</code>, <code>val</code>, <code>push</code>, y <code>pop</code>
estan definidas en un archivo, en el orden expuesto anteriormente,
esto es,
</p>

<div class="org-src-container">
<pre class="src src-c"><span style="color: #87cefa;">main</span>() { ... }

<span style="color: #98fb98;">int</span> <span style="color: #eedd82;">sp</span> = 0;
<span style="color: #98fb98;">double</span> <span style="color: #eedd82;">val</span>[MAXVAL];

<span style="color: #98fb98;">void</span> <span style="color: #87cefa;">push</span>(<span style="color: #98fb98;">double</span> <span style="color: #eedd82;">f</span>) { ... }

<span style="color: #98fb98;">double</span> <span style="color: #87cefa;">pop</span>(<span style="color: #98fb98;">void</span>) { ... }
</pre>
</div>

<p>
entonces las variables <code>sp</code> y <code>val</code> se pueden utilizar en <code>push</code> y
<code>pop</code> simplemente nombrandolas; no se necesita ninguna otra
declaracion. Pero estos nombres no son visibles en <code>main</code>, ni
<code>push</code> ni <code>pop</code>.
</p>

<p>
Por otro lado, si se va a hacer referencia a una variable externa
antes de su definicion, o si esta definida en un archivo fuente
diferente al que se esta utilizando, entonces es obligatoria una
declaracion <code>extern</code>.
</p>

<p>
Es importante distinguir entre la <i>declaracion</i> de una variable
externa y su <i>definicion</i>. Una declaracion expone las propiedades
de una variable (principalmente su tipo); una definicion tambien
provoca que reserve un espacio para almacenamiento. Si las lineas
</p>

<div class="org-src-container">
<pre class="src src-c"><span style="color: #98fb98;">int</span> <span style="color: #eedd82;">sp</span>;
<span style="color: #98fb98;">double</span> <span style="color: #eedd82;">val</span>[MAX VAL];
</pre>
</div>

<p>
aparecen fuera de cualquier funcion, definen las variables externas
<code>sp</code> y <code>val</code>, reservan un espacio para almacenamiento y tambien
sirven como declaracion para el resto de ese archivo fuente. Por
otro lado, las lineas
</p>

<div class="org-src-container">
<pre class="src src-c"><span style="color: #00ffff;">extern</span> <span style="color: #98fb98;">in</span> <span style="color: #eedd82;">sp</span>;
<span style="color: #00ffff;">extern</span> <span style="color: #98fb98;">double</span> <span style="color: #eedd82;">val</span>[];
</pre>
</div>

<p>
<i>declaran</i> para el resto del archivo que <code>sp</code> es un <code>int</code> y que
<code>val</code> es un arreglo <code>double</code> (cuyo tamaño se determina en algun
otro lugar), pero no crean las variables ni les reservan espacio.
</p>

<p>
Solo debe existir una <i>definicion</i> de una variable externa entre
todos los archivos que forman un programa fuente; otros archivos
pueden contener declaraciones <code>extern</code> para tener acceso a
ellas. (Tambien puede haber declaraciones <code>extern</code> en el archivo
que contiene la definicion.) Los tamaños de los arreglos deben ser
especificados con la definicion, pero es optativo hacerlo en una
declaracion <code>extern</code>.
</p>

<p>
La inicializacion de una variable externa solo va con su
definicion.
</p>

<p>
Aunque no es una organizacion idonea para este programa, las
funciones <code>push</code> y <code>pop</code> pueden definirse en un archivo, y las
variables <code>val</code> y <code>sp</code> podrian ser definidas e inicializadas en
otro. Entonces se necesitarian las siguientes definiciones y
declaraciones para enlazarlas:
</p>

<dl class="org-dl">
<dt>En el archivo 1</dt><dd><div class="org-src-container">
<pre class="src src-c"><span style="color: #00ffff;">extern</span> <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">sp</span>;
<span style="color: #00ffff;">extern</span> <span style="color: #98fb98;">double</span> <span style="color: #eedd82;">val</span>[]

<span style="color: #98fb98;">void</span> push(<span style="color: #98fb98;">double</span> <span style="color: #eedd82;">f</span>) { ... }

<span style="color: #98fb98;">double</span> <span style="color: #87cefa;">pop</span>(<span style="color: #98fb98;">void</span>) { ... }
</pre>
</div></dd>

<dt>En el archivo 2</dt><dd><div class="org-src-container">
<pre class="src src-c"><span style="color: #98fb98;">int</span> <span style="color: #eedd82;">sp</span> = 0;
<span style="color: #98fb98;">double</span> <span style="color: #eedd82;">val</span>[MAXVAL];
</pre>
</div></dd>
</dl>


<p>
Debido a que las declaraciones <code>extern</code> que se encuentran en el
<i>archivo 1</i> estan situadas antes y afuera de las definiciones de
funciones, se aplican a todas las funciones; un conjunto de
declaraciones basta para todo el <i>archivo 1</i>. Esta misma
organizacion tambien seria necesaria si las definiciones de <code>sp</code> y
<code>val</code> se encontraran despues de su uso en un archivo.
</p>
</div>
</div>

<div id="outline-container-orga1df3f2" class="outline-3">
<h3 id="orga1df3f2">4.5  Archivo de encabezamiento <code>header</code>                            <a id="org148b216"></a></h3>
<div class="outline-text-3" id="text-orga1df3f2">
<p>
Consideremos ahora la division del programa de la calculadora en
varios archivos fuente, como podria ser si cada uno de los
componentes fuera sustancialmente mayor. La funcion <code>main</code> ira
dentro de un archivo, al que llamaremos <code>main.c</code>; <code>push</code>, <code>pop</code> y
sus variables van dentro de un segundo archivo, <code>stack.c</code>; <code>getop</code>
va en un tercero, <code>getop.c</code>. Finalmente, <code>getch</code> y <code>ungetch</code> van
dentro de un cuarto archivo, <code>getch.c</code>; las separaremos de las
otras debido a que podrian venir de una biblioteca compilada
separadamente en un programa realista.
</p>

<p>
Hay algo mas de que preocuparse – las definiciones y declaraciones
compartidas entre archivos. Debemos centralizarlas hasta donde sea
posible, de modo que haya solo una copia por mantener mientras se
desarrolla el programa. En consecuencia, situaremos este material
comun en un archivo tipo <i>header</i>, <code>calc.h</code>,que se incluira donde
sea necesario. (La linea <code>#include</code> se describe en la <a href="#org0f22d95">seccion 4.11</a>)
Entonces, el programa resultante se ve como sigue:
</p>

<div class="org-src-container">
<pre class="src src-ditaa">                                 calc.h
                               +---------------------+
                               | #define NUMBER '0'  |
                               | void push(double);  |
                               | double pop(void);   |
                               | int getop(char []); |
                               | int getch(void);    |
                               | void ungetch(int);  |
                               +---------------------+


  main.c:                        getop. c:                      stack.c:
+---------------------+        +---------------------+        +---------------------+
| #include &lt;stdio.h&gt;  |        | #include &lt;stdio.h&gt;  |        | #include &lt;stdio.h&gt;  |
| #include &lt;stdlib.h&gt; |        | #include &lt;ctype.h&gt;  |        | #include <span style="color: #ffa07a;">"calc.h"</span>   |
| #include <span style="color: #ffa07a;">"calc.h"</span>   |        | #include <span style="color: #ffa07a;">"calc.h"</span>   |        | #define MAXVAL 100  |
| #define MAXOP 100   |        | getop() {           |        | int sp = 0;         |
| main () {           |        |   ...               |        | double val[MAXVAL]; |
|   ...               |        | }                   |        | void push(double) { |
| }                   |        +---------------------+        |   ...               |
+---------------------+                                       | }                   |
                                                              | double pop(void) {  |
                                                              |   ...               |
                                 getch. c:                    | }                   |
                               +---------------------+        +---------------------+
                               | #include &lt;stdio.h&gt;  |
                               | #define BUFSIZE 100 |
                               | char buf[BUFSIZE];  |
                               | int bufp = 0;       |
                               | int getch(void) {   |
                               |   ...               |
                               | }                   |
                               | void ungetch(int) { |
                               |   ...               |
                               | }                   |
                               +---------------------+
</pre>
</div>

<p>
Existe un compromiso entre el deseo de que cada archivo solo tenga
acceso a la informacion que necesita para su trabajo y la realidad
practica de que es mas dificil mantener mas archivos tipo
<i>header</i>. Hasta un tamaño moderado de programa, probablemente es
mejor tener un archivo de encabezamiento que contenga todo lo que
sera compartido entre las partes del programa; esta es la decision
que tomamos aqui. Para un programa mucho mas grande, se necesitaria
mas organizacion y mas archivos tipo <i>header</i>.
</p>
</div>
</div>

<div id="outline-container-org2d32506" class="outline-3">
<h3 id="org2d32506">4.6  Variables estaticas                                           <a id="org707577f"></a></h3>
<div class="outline-text-3" id="text-org2d32506">
<p>
Las variables <code>sp</code> y <code>val</code> en <code>stack.c</code>, y <code>buf</code> y <code>bufp</code> en
<code>getch.c</code>, son para el uso privado de las funciones que estan en
sus respectivos archivos fuente, y se supone que nada mas tiene
acceso a ellas. La declaracion <code>static</code>, aplicada a una variable o
funcion externa, limita el alcance de ese objeto al resto del
archivo fuente que se esta compilando. Asi las variables <code>static</code>
externas proporcionan una forma de ocultar nombres como <code>buf</code> y
<code>bufp</code> en la combinacion <code>getch-ungetch</code>, que deben ser externas
para que puedan ser compartidas, aunque no deben ser visibles a los
usuarios de <code>getch</code> y <code>ungetch</code>.
</p>

<p>
El almacenamiento estatico se especifica al anteponer a la
declaracion normal la palabra <code>static</code>. Si las dos rutinas y las dos
variables se compilan en un archivo, como en
</p>


<div class="org-src-container">
<pre class="src src-c"><span style="color: #00ffff;">static</span> <span style="color: #98fb98;">char</span> <span style="color: #eedd82;">buf</span>[BUFSIZE];  <span style="color: #ff4500;">/* </span><span style="color: #ff4500;">buffer para ungetch </span><span style="color: #ff4500;">*/</span>
<span style="color: #00ffff;">static</span> <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">bufp</span> = 0;       <span style="color: #ff4500;">/* </span><span style="color: #ff4500;">siguiente posicion libre en buf </span><span style="color: #ff4500;">*/</span>

<span style="color: #98fb98;">int</span> <span style="color: #87cefa;">getch</span>(<span style="color: #98fb98;">void</span>) { ... }

<span style="color: #98fb98;">void</span> <span style="color: #87cefa;">ungetch</span>(<span style="color: #98fb98;">int</span> <span style="color: #eedd82;">c</span>) { ... }
</pre>
</div>

<p>
entonces ninguna otra rutina sera capaz de tener acceso a <code>buf</code> ni
a <code>bufp</code>, y esos nombres no entraran en conflicto con los mismos
nombres que esten en otros archivos del mismo programa. De la misma
manera, las variables que <code>push</code> y <code>pop</code> utilizan para la
manipulacion de la pila se pueden ocultar, declarando <code>sp</code> y <code>val</code>
como <code>static</code>.
</p>

<p>
La declaracion <code>static</code> externa se usa con mas frecuencia en
variables, pero tambien se puede aplicar a funciones. Normalmente,
los nombres de funciones son globales, visibles a cualquier parte
del programa completo. Sin embargo, si una funcion se declara como
<code>static</code>, su nombre es invisible fuera del archivo en el que esta
declarada.
</p>

<p>
La declaracion <code>static</code> tambien puede aplicarse a variables
internas. Las variables internas <code>static</code> son locales a una funcion
en particular, tal como lo son las variables automaticas, pero a
diferencia de ellas, mantienen su existencia en lugar de ir y venir
cada vez que se activa la funcion. Eso significa que las variables
internas <code>static</code> proporcionan almacenamiento privado y permanente
dentro de una funcion.
</p>

<p>
<b>Ejercicio 4-11</b>. Modifique <code>getop</code> de modo que no necesite
utilizar <code>ungetch</code>. Sugerencia: emplee una variable <code>static</code>
interna.
</p>
</div>
</div>

<div id="outline-container-org4505195" class="outline-3">
<h3 id="org4505195">4.7  Variables tipo registro                                       <a id="org1368d6a"></a></h3>
<div class="outline-text-3" id="text-org4505195">
<p>
Una declaracion <code>register</code> indica al compilador que la variable en
cuestion se empleara intensamente. La idea es que las variables
<code>register</code> se coloquen en registros de la maquina, lo que puede dar
como resultado programas mas pequeños y rapidos. Pero los
compiladores tienen la libertad de ignorar esta sugerencia.
</p>

<p>
La declaracion <code>register</code> se ve asi:
</p>

<div class="org-src-container">
<pre class="src src-c"><span style="color: #00ffff;">register</span> <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">x</span>;
<span style="color: #00ffff;">register</span> <span style="color: #98fb98;">char</span> <span style="color: #eedd82;">c</span>;
</pre>
</div>

<p>
etcetera. La declaracion <code>register</code> solo se puede aplicar a
variables automaticas y a los parametros formales de una
funcion. En este ultimo caso, aparece como
</p>

<div class="org-src-container">
<pre class="src src-c">f(<span style="color: #00ffff;">register</span> <span style="color: #98fb98;">unsigned</span> <span style="color: #eedd82;">m</span>, <span style="color: #00ffff;">register</span> <span style="color: #98fb98;">long</span> <span style="color: #eedd82;">n</span>)
{
  <span style="color: #00ffff;">register</span> <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">i</span>;
  ...
}
</pre>
</div>

<p>
En la practica existen restricciones en las variables tipo
registro, que reflejan la realidad del equipo donde se opera. Solo
algunas variables de cada funcion se pueden mantener en registros,
y solo se permiten ciertos tipos. Sin embargo, el exceso de
declaraciones tipo registro no provoca daños, puesto que la palabra
<code>register</code> se ignora en las declaraciones excesivas o no
permitidas. Ademas, no es posible tomar la direccion de una
variable de tipo registro (tema que se tratara en el <a href="#org69d49af">capitulo 5</a>),
sin importar si la variable esta o no realmente en un registro. Las
restricciones especificas sobre el numero y tipo de estas variables
varian de una maquina a otra.
</p>
</div>
</div>

<div id="outline-container-orgc66d62b" class="outline-3">
<h3 id="orgc66d62b">4.8  Estructura de bloques                                         <a id="orgd0d2266"></a></h3>
<div class="outline-text-3" id="text-orgc66d62b">
<p>
C no es un lenguaje estructurado en bloques en el sentido de Pascal
o lenguajes semejantes, puesto que las funciones no se pueden
definir dentro de otras funciones. Por otra parte, las variables se
pueden definir en una modalidad de estructura de bloques dentro de
una funcion. Las declaraciones de variables (incluyendo la
inicializacion) pueden seguir a la llave izquierda que indica
<i>cualquier</i> proposicion compuesta, no solo la que inicia a una
funcion. Las variables declaradas de esta manera ocultan cualquier
nombre identico de variables en bloques externos, y permanecen
hasta que se encuentra la llave derecha que corresponde con la
inicial. Por ejemplo, en
</p>

<div class="org-src-container">
<pre class="src src-c"><span style="color: #00ffff;">if</span> (n &gt; 0) {
  <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">i</span>; <span style="color: #ff4500;">/* </span><span style="color: #ff4500;">declara una nueva i </span><span style="color: #ff4500;">*/</span>

  <span style="color: #00ffff;">for</span> (i = 0; i &lt; n; i++)
    ...
}
</pre>
</div>

<p>
el alcance de la variable <code>i</code> es la rama "verdadera" del <code>if</code>; esta
<code>i</code> no tiene nada que ver con alguna <code>i</code> fuera del bloque. Una
variable automatica declarada e inicializada en un bloque se
inicializa cada vez que se entra al bloque. Una variable <code>static</code>
se inicializa solo la primera vez que se entra al bloque.
</p>

<p>
Las variables automaticas, incluyendo los parametros formales,
tambien esconden a las variables y funciones externas del mismo
nombre. Dadas las declaraciones
</p>

<div class="org-src-container">
<pre class="src src-c"><span style="color: #98fb98;">int</span> <span style="color: #eedd82;">x</span>;
<span style="color: #98fb98;">int</span> <span style="color: #eedd82;">y</span>;

<span style="color: #87cefa;">f</span> (<span style="color: #98fb98;">double</span> <span style="color: #eedd82;">x</span>)
{
  <span style="color: #98fb98;">double</span> <span style="color: #eedd82;">y</span>;
}
</pre>
</div>

<p>
en la funcion <code>f</code>, las ocurrencias de <code>x</code> se refieren al parametro,
que es un <code>double</code>; fuera de <code>f</code>, se refieren al <code>int</code> externo. Lo
mismo es valido para la variable <code>y</code>.
</p>

<p>
Por estilo, es mejor evitar nombres de variables que coinciden con
nombres de un alcance exterior; la potencialidad de confusion y
error es muy grande.
</p>
</div>
</div>

<div id="outline-container-org6e74dcc" class="outline-3">
<h3 id="org6e74dcc">4.9  Inicializacion                                                <a id="org50d6e03"></a></h3>
<div class="outline-text-3" id="text-org6e74dcc">
<p>
La incializacion ya se ha mencionado muchas veces, pero siempre
alrededor de algun otro tema. Esta seccion resume algunas de las
reglas, ahora que ya se han discutido las diferentes categorias de
almacenamiento.
</p>

<p>
En ausencia de una inicializacion explicita, se garantiza que las
variables externas y estaticas se inicializaran en cero; las
variables automaticas y tipo registro tienen valores iniciales
indefinidos (esto es, basura).
</p>

<p>
Las variables escalares se pueden inicializar cuando se definen,
siguiendo al nombre con un signo de igual y una expresion:
</p>

<div class="org-src-container">
<pre class="src src-c"><span style="color: #98fb98;">int</span> <span style="color: #eedd82;">x</span> = 1;
<span style="color: #98fb98;">char</span> <span style="color: #eedd82;">squote</span> = <span style="color: #ffa07a;">'\''</span>;
<span style="color: #98fb98;">long</span> <span style="color: #eedd82;">day</span> = 1000L * 60L * 60L * 24L; <span style="color: #ff4500;">/* </span><span style="color: #ff4500;">milisegundos/dia </span><span style="color: #ff4500;">*/</span>
</pre>
</div>

<p>
Para variables externas y estaticas, el inicializador debe ser una
expresion constante; la inicializacion se realiza una vez,
conceptualmente antes de que el programa inicie su ejecucion. Para
variables automaticas y tipo registro, se hace cada vez que se
entra a la funcion o bloque.
</p>

<p>
Para variables automaticas y tipo registro, el inicializador no se
limita a una constante: puede ser cualquier expresion que contenga
valores previamente definidos, incluso llamadas a funciones. Por
ejemplo, la inicializacion del programa de busqueda binaria de la
<a href="#org5628cc0">seccion 3.3</a> podria escribirse como
</p>

<div class="org-src-container">
<pre class="src src-c"><span style="color: #98fb98;">int</span> <span style="color: #87cefa;">binsearch</span>(<span style="color: #98fb98;">int</span> <span style="color: #eedd82;">x</span>, <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">v</span>[], <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">n</span>)
{
  <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">low</span> = 0;
  <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">high</span> = n - 1;
  <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">mid</span>;
  ...
}
</pre>
</div>

<p>
en lugar de
</p>

<div class="org-src-container">
<pre class="src src-c"><span style="color: #98fb98;">int</span> <span style="color: #eedd82;">low</span>, <span style="color: #eedd82;">high</span>, <span style="color: #eedd82;">mid</span>;

low = 0;
high = n - 1;
</pre>
</div>

<p>
En efecto, las inicializaciones de variables automaticas son solo
abreviaturas de proposiciones de asignacion. La eleccion es en gran
medida cuestion de gusto. Nosotros hemos empleado generalmente
asignaciones explicitas, debido a que los inicializadores en las
declaraciones son dificiles de ver y lejanos del lugar de uso.
</p>

<p>
Un arreglo puede ser inicializado al seguir su declaracion con una
lista de inicializadores encerrados entre llaves y separados por
comas. Por ejemplo, para inicializar un arreglo <code>days</code> con el
numero de dias de cada mes:
</p>

<div class="org-src-container">
<pre class="src src-c"><span style="color: #98fb98;">int</span> <span style="color: #eedd82;">days</span>[] = { 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31 };
</pre>
</div>

<p>
Cuando se omite el tamaño de un arreglo, el compilador calculara la
longitud contando los inicializadores, los cuales son 12 en este
caso.
</p>

<p>
Si existen menos inicializadores para un arreglo que los del tamaño
especificado, los otros seran cero para variables externas o
estaticas, pero basura para automaticas. Es un error tener
demasiados inicializadores. No hay forma de indicar la repeticion
de un inicializador, ni de inicializar un elemento que esta a la
mitad de un arreglo sin proporcionar tambien todos los valores
precedentes.
</p>

<p>
Los arreglos de caracteres son un caso especial de inicializacion;
se puede utilizar una cadena en lugar de la notacion de llaves y
comas:
</p>

<div class="org-src-container">
<pre class="src src-c"><span style="color: #98fb98;">char</span> <span style="color: #eedd82;">pattern</span>[] = <span style="color: #ffa07a;">"ould"</span>;
</pre>
</div>

<p>
es mas corto pero equivalente a
</p>

<div class="org-src-container">
<pre class="src src-c"><span style="color: #98fb98;">char</span> <span style="color: #eedd82;">pattern</span>[] = { <span style="color: #ffa07a;">'o'</span>, <span style="color: #ffa07a;">'u'</span>, <span style="color: #ffa07a;">'l'</span>, <span style="color: #ffa07a;">'d'</span>, <span style="color: #ffa07a;">'\0'</span>};
</pre>
</div>

<p>
En este caso, el tamaño del arreglo es cinco (cuatro caracteres mas
el terminador '\0').
</p>
</div>
</div>

<div id="outline-container-org80ccc0d" class="outline-3">
<h3 id="org80ccc0d">4.10 Recursividad                                                  <a id="orgc53ca03"></a></h3>
<div class="outline-text-3" id="text-org80ccc0d">
<p>
Las funciones de C pueden emplearse recursivamente; esto es, una
funcion puede llamarse a si misma ya sea directa o
indirectamente. Considere la impresion de un numero como una cadena
de caracteres. Como ya se menciono anteriormente, los digitos se
generan en orden incorrecto: los digitos de orden inferior estan
disponibles antes de los digitos de orden superior, pero se deben
imprimir en el orden invertido.
</p>

<p>
Existen dos soluciones a este problema. Una es almacenar los
digitos en un arreglo tal como se generan, y despues imprimirlos en
orden inverso, como se hizo con <code>itoa</code> en la <a href="#org8eb8fc8">seccion 3.6</a>. La
alternativa es una solucion recursiva, en la que <code>printd</code> primero
se llama a si misma para tratar con los primeros digitos, y despues
imprime el digito del final. De nuevo, esta version puede fallar
con el numero negativo mas grande.
</p>

<div class="org-src-container">
<pre class="src src-c"><span style="color: #b0c4de;">#include</span> <span style="color: #ffa07a;">&lt;stdio.h&gt;</span>

<span style="color: #ff4500;">/* </span><span style="color: #ff4500;">printd: imprime n en decimal </span><span style="color: #ff4500;">*/</span>
<span style="color: #98fb98;">void</span> <span style="color: #87cefa;">printd</span>(<span style="color: #98fb98;">int</span> <span style="color: #eedd82;">n</span>)
{
  <span style="color: #00ffff;">if</span> (n &lt; 0) {
    putchar(<span style="color: #ffa07a;">'-'</span>);
    n = -n;
  }
  <span style="color: #00ffff;">if</span> (n / 10)
    printd(n / 10);
  putchar(n % 10 + <span style="color: #ffa07a;">'0'</span>);
}
</pre>
</div>

<p>
Cuando una funcion se llama a si misma recursivamente, cada
invocacion obtiene un conjunto nuevo de todas las variables
automaticas, independiente del conjunto previo. Asi, en
<code>printd(123)</code> el primer <code>printd</code> recibe el argumento <code>n =
   123</code>. Pasa <code>12</code> al segundo <code>printd</code>, que a su vez pasa <code>1</code> a un
tercero. El <code>printd</code> del tercer nivel imprime <code>1</code>, despues regresa
al segundo nivel. Ese <code>printd</code> imprime <code>2</code>, despues regresa al
primer nivel. Ese imprime <code>3</code> y termina.
</p>

<p>
Otro buen ejemplo de recursividad es <i>quicksort</i>, un algoritmo de
ordenamiento desarrollado en 1962 por C. A. R. Hoare. Dado un
arreglo, un elemento se selecciona y los otros se particionan en
dos subconjuntos – aquellos menores que el elemento de la particion
y aquellos mayores o iguales a el. El mismo proceso se aplica
despues recursivamente a los dos subconjuntos. Cuando un
subconjunto tiene menos de dos elementos no necesita ya de ningun
ordenamiento; esto detiene la recursividad.
</p>

<p>
Nuestra version de <i>quicksort</i> no es la mas rapida posible, pero es
una de las mas simples. Empleamos el elemento intermedio de cada
subarreglo para particionar.
</p>

<div class="org-src-container">
<pre class="src src-c"><span style="color: #ff4500;">/* </span><span style="color: #ff4500;">qsort: ordena v[left]...v[right] en orden ascendente </span><span style="color: #ff4500;">*/</span>
<span style="color: #98fb98;">void</span> <span style="color: #87cefa;">qsort</span>(<span style="color: #98fb98;">int</span> <span style="color: #eedd82;">v</span>[], <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">left</span>, <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">right</span>)
{
  <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">i</span>, <span style="color: #eedd82;">last</span>;
  <span style="color: #98fb98;">void</span> <span style="color: #87cefa;">swap</span>(<span style="color: #98fb98;">int</span> <span style="color: #eedd82;">v</span>[], <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">i</span>, <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">j</span>);

  <span style="color: #00ffff;">if</span> (left &gt;= right)                  <span style="color: #ff4500;">/* </span><span style="color: #ff4500;">no hace nada si el arreglo contiene </span><span style="color: #ff4500;">*/</span>
    <span style="color: #00ffff;">return</span>;                           <span style="color: #ff4500;">/* </span><span style="color: #ff4500;">menos de dos elementos              </span><span style="color: #ff4500;">*/</span>
  swap(v, left, (left + right)/2);    <span style="color: #ff4500;">/* </span><span style="color: #ff4500;">mueve el elemento de particion      </span><span style="color: #ff4500;">*/</span>
  last = left;                        <span style="color: #ff4500;">/* </span><span style="color: #ff4500;">a v[0]                              </span><span style="color: #ff4500;">*/</span>
  <span style="color: #00ffff;">for</span> (i = left + 1; i &lt;= right; i++) <span style="color: #ff4500;">/* </span><span style="color: #ff4500;">particion                           </span><span style="color: #ff4500;">*/</span>
    <span style="color: #00ffff;">if</span> (v[i] &lt; v[left])
      swap(v, ++last, i);
  swap(v, left, last);                <span style="color: #ff4500;">/* </span><span style="color: #ff4500;">regresa el elemento de particion    </span><span style="color: #ff4500;">*/</span>
  qsort(v, left, last-1);
  qsort(v, last+1, right);
}
</pre>
</div>

<p>
Pasamos la operacion de intercambio a una funcion separada <code>swap</code>,
puesto que ocurre tres veces en <code>qsort</code>.
</p>

<div class="org-src-container">
<pre class="src src-c"><span style="color: #ff4500;">/* </span><span style="color: #ff4500;">swap: intercambia v[i] y v[j] </span><span style="color: #ff4500;">*/</span>
<span style="color: #98fb98;">void</span> <span style="color: #87cefa;">swap</span>(<span style="color: #98fb98;">int</span> <span style="color: #eedd82;">v</span>[], <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">i</span>, <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">j</span>)
{
  <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">temp</span>;

  temp = v[i];
  v[i] = v[j];
  v[j] = temp;
}
</pre>
</div>

<p>
La biblioteca estandar incluye una version de <a href="#org2fd9ddd"><code>qsort</code></a> que puede
ordenar objetos de cualquier <code>tipo</code>.
</p>

<p>
La recursividad no puede proporcionar un ahorro en almacenamiento,
puesto que en algun lugar se debe mantener una pila de los valores
procesados. Ni sera mas rapida. Pero el codigo recursivo es mas
compacto y frecuentemente mucho mas facil de escribir y de entender
que su equivalente no recursivo. La recursividad es especialmente
conveniente para estructuras de datos definidas en forma recursiva,
como arboles; veremos un agradable ejemplo en la <a href="#org2b6b892">seccion 6.5</a>.
</p>

<p>
<b>Ejercicio 4-12</b>. Adapte las ideas de <code>printd</code> al escribir la
version recursiva del programa <code>itoa</code>; esto es, convierta un entero
en una cadena llamando a una rutina recursiva.
</p>

<p>
<b>Ejercicio 4-13</b>. Escriba una version recursiva de la funcion
<code>reverse(s)</code>, que invierte la cadena <code>s</code> en su lugar.
</p>
</div>
</div>

<div id="outline-container-orgdc3914a" class="outline-3">
<h3 id="orgdc3914a">4.11 El preprocesador de C                                         <a id="org0f22d95"></a></h3>
<div class="outline-text-3" id="text-orgdc3914a">
<p>
C proporciona ciertas facilidades de lenguaje por medio de un
preprocesador, que conceptualmente es un primer paso separado en la
compilacion. Los dos elementos que se usan con mas frecuencia son
<code>#include</code>, para incluir el contenido de un archivo durante la
compilacion, y <code>#define</code>, para reemplazar un simbolo por una
secuencia arbitraria de caracteres. Otras caracteristicas que se
describen en esta seccion incluyen compilacion condicional y macros
con argumentos.
</p>
</div>

<div id="outline-container-orgc847546" class="outline-4">
<h4 id="orgc847546">4.11.1 Inclusion de archivos                                      <a id="orgd470aba"></a></h4>
<div class="outline-text-4" id="text-orgc847546">
<p>
La inclusion de archivos facilita el manejo de grupos de <code>#define</code> y
declaraciones (entre otras cosas). Cualquier linea fuente de la
forma
</p>

<div class="org-src-container">
<pre class="src src-c"><span style="color: #b0c4de;">#include</span> <span style="color: #ffa07a;">"nombre"</span>
</pre>
</div>

<p>
o
</p>

<div class="org-src-container">
<pre class="src src-c"><span style="color: #b0c4de;">#include</span> <span style="color: #ffa07a;">&lt;nombre&gt;</span>
</pre>
</div>

<p>
se reemplaza por el contenido del fichero <code>nombre</code>. Si el <code>nombre</code>
se encierra entre comillas, la busqueda del archivo comienza
normalmente donde se encontro el programa fuente; si no se
encuentra alli, o si el nombre se delimita por <code>&lt;</code> y <code>&gt;</code> , la
busqueda sigue una ruta predefinida por la implantacion para
encontrar el archivo. Un archivo incluido puede contener lineas
<code>#include</code>.
</p>

<p>
Frecuentemente existen varias lineas <code>#include</code> al principio de un
archivo fuente, para incluir proposiciones <code>#define</code> y
declaraciones <code>extern</code> comunes, o para tener acceso a la
declaracion del prototipo de una funcion de biblioteca desde
<i>headers</i> como <code>&lt;stdio.h&gt;</code>. (Estrictamente hablando, no necesitan
ser archivos; los detalles de como se tiene acceso a los headers
dependen de la implantacion.)
</p>

<p>
<code>#include</code> es la mejor manera de enlazar las declaraciones para un
programa grande. Garantiza que todos los archivos fuente se
supliran con las mismas definiciones y declaraciones de variables,
y asi elimina un tipo de error particularmente desagradable. Por
supuesto, cuando se cambia un archivo include, se deben recompilar
todos los archivos que dependen de el.
</p>
</div>
</div>

<div id="outline-container-org08c78dd" class="outline-4">
<h4 id="org08c78dd">4.11.2 Substitucion de macros                                     <a id="orgefa8a9f"></a></h4>
<div class="outline-text-4" id="text-org08c78dd">
<p>
Una definicion tiene la forma
</p>

<div class="org-src-container">
<pre class="src src-c"><span style="color: #b0c4de;">#define</span> <span style="color: #eedd82;">nombre</span> texto de reemplazo
</pre>
</div>

<p>
Pide la substitucion de una macro del tipo mas sencillo – las
siguientes ocurrencias de <i>nombre</i> seran substituidas por el
<i>texto de reemplazo</i>. El nombre en un <code>#define</code> tiene la misma
forma que un nombre de variable; el texto de reemplazo es
arbitrario. Normalmente el texto de reemplazo es el resto de la
linea, pero una definicion extensa puede continuarse en varias
lineas, colocando una <code>\</code> al final de cada linea que va a
continuar. El alcance de un nombre definido con <code>#define</code> va desde
su punto de definicion hasta el fin del archivo fuente que se
compila. Una definicion puede emplear definiciones previas. Las
substituciones se realizan solo para elementos, y no sucede dentro
de cadenas delimitadas por comillas, por ejemplo, si <code>AFIRMA</code> es
un nombre definido, no habra substitucion en <code>printf ("AFIRMA")</code>
ni en <code>AFIRMATIVO</code>.
</p>

<p>
Cualquier nombre puede definirse con cualquier texto de
reemplazo. Por ejemplo.
</p>

<div class="org-src-container">
<pre class="src src-c"><span style="color: #b0c4de;">#define</span> <span style="color: #eedd82;">porsiempre</span> <span style="color: #00ffff;">for</span> (;;) <span style="color: #ff4500;">/* </span><span style="color: #ff4500;">ciclo infinito </span><span style="color: #ff4500;">*/</span>
</pre>
</div>

<p>
define una nueva palabra, <code>porsiempre</code>, para un ciclo infinito.
</p>

<p>
Tambien es posible definir macros con argumentos, para que el
texto de reemplazo pueda ser diferente para diferentes llamadas
de la macro. Como un ejemplo, defina una macro llamada <code>max</code>;
</p>

<div class="org-src-container">
<pre class="src src-c"><span style="color: #b0c4de;">#define</span> <span style="color: #87cefa;">max</span>(<span style="color: #eedd82;">A</span>, <span style="color: #eedd82;">B</span>) ((A) &gt; (B) ? (A) : (B))
</pre>
</div>

<p>
Aunque aparenta ser una llamada a funcion, el uso de max se
expande a codigo. Cada ocurrencia de un parametro formal (A o B)
sera reemplazada por el argumento real correspondiente. Asi, la
linea
</p>

<div class="org-src-container">
<pre class="src src-c">x = max(p + q, r + s);
</pre>
</div>

<p>
sera reemplazada por la linea
</p>

<div class="org-src-container">
<pre class="src src-c">x = ((p + q) &gt; (r + s) ? (p + q) : (r + s));
</pre>
</div>

<p>
En tanto que los argumentos se traten consistentemente, esta macro
servira para cualquier tipo de datos; no hay necesidad de
diferentes tipos de <code>max</code> para diferentes tipos de datos, como la
habria con las funciones.
</p>

<p>
Si examina la expansion de <code>max</code>, notara algunos riesgos. Las
expresiones se evaluan dos veces; esto es malo si involucra
efectos colaterales como operadores incrementales o de entrada y
salida. Por ejemplo,
</p>

<div class="org-src-container">
<pre class="src src-c"><span style="color: #87cefa;">max</span>(i++, j++) <span style="color: #ff4500;">/* </span><span style="color: #ff4500;">INCORRECTO </span><span style="color: #ff4500;">*/</span>
</pre>
</div>

<p>
incrementara el valor mas grande dos veces. Tambien debe tenerse
algun cuidado con los parentesis, para asegurar que se preserva el
orden de evaluacion; considere que pasa cuando la macro
</p>

<div class="org-src-container">
<pre class="src src-c"><span style="color: #b0c4de;">#define</span> <span style="color: #87cefa;">cuadrado</span>(<span style="color: #eedd82;">x</span>) x * x <span style="color: #ff4500;">/* </span><span style="color: #ff4500;">INCORRECTO </span><span style="color: #ff4500;">*/</span>
</pre>
</div>

<p>
se invoca como <code>cuadrado(z + 1)</code>.
</p>

<p>
Sin embargo, las macros son valiosas. Un ejemplo practico viene de
<code>&lt;stdio.h&gt;</code>, donde <a href="#org4d38061"><code>getchar</code></a> y <a href="#orgc7f0a8a"><code>putchar</code></a> se definen frecuentemente
como macros para evitar el exceso de tiempo de ejecucion de una
llamada a funcion por cada caracter procesado. Las funciones en
<code>&lt;ctype.h&gt;</code> tambien se realizan generalmente como macros.
</p>

<p>
Los nombres se pueden hacer indefinidos con <code>#undef</code>, para
asegurar que una rutina es realmente una funcion, no una macro:
</p>

<div class="org-src-container">
<pre class="src src-c"><span style="color: #b0c4de;">#undef</span> getchar
<span style="color: #98fb98;">int</span> <span style="color: #87cefa;">getchar</span> (<span style="color: #98fb98;">void</span>) { ... }
</pre>
</div>

<p>
Los parametros formales no se reemplazan dentro de cadenas entre
comillas. Sin embargo, si un nombre de parametro esta precedido
por un <code>#</code> en el texto de reemplazo, la combinacion se expandira
en una cadena entre comillas, con el parametro reemplazado por el
argumento real. Esto puede combinarse con concatenacion de cadenas
para hacer, por ejemplo, una macro de impresion para depuracion:
</p>

<div class="org-src-container">
<pre class="src src-c"><span style="color: #b0c4de;">#define</span> <span style="color: #87cefa;">dprint</span>(<span style="color: #eedd82;">expr</span>) printf(#expr <span style="color: #ffa07a;">" = %g\n"</span>, expr)
</pre>
</div>

<p>
Cuando se invoca, como en
</p>

<div class="org-src-container">
<pre class="src src-c"><span style="color: #87cefa;">dprint</span>(x/y);
</pre>
</div>

<p>
la macro se expande en
</p>

<div class="org-src-container">
<pre class="src src-c">printf(<span style="color: #ffa07a;">"x/y"</span> <span style="color: #ffa07a;">" = %g\n"</span>, x/y);
</pre>
</div>

<p>
y las cadenas se concatenan, asi el efecto es
</p>

<div class="org-src-container">
<pre class="src src-c">printf (<span style="color: #ffa07a;">"x/y = %g\n"</span>, x/y);
</pre>
</div>

<p>
Dentro del argumento real, cada <code>"</code> se reemplaza por <code>\"</code> y cada <code>\</code>
por <code>\\</code>, asi que el resultado es una constante de cadena
legitima.
</p>

<p>
El operador <code>##</code> del preprocesador proporciona una forma de
concatenar argumentos reales durante la expansion de una macro. Si
un parametro que esta en el texto de reemplazo es adyacente a un
<code>##</code>, es reemplazado por el argumento real, se eliminan el <code>##</code> y
los espacios en blanco que lo rodean, y el resultado se rastrea de
nuevo. Por ejemplo, la macro <code>paste</code> concatena sus dos argumentos:
</p>

<div class="org-src-container">
<pre class="src src-c"><span style="color: #b0c4de;">#define</span> <span style="color: #87cefa;">paste</span>(<span style="color: #eedd82;">front</span>, <span style="color: #eedd82;">back</span>) front ## back
</pre>
</div>

<p>
asi, <code>paste(nombre, 1)</code> crea el token <code>nombre1</code>.
</p>

<p>
Las reglas para el uso anidado de <code>##</code> son misteriosas; en el
<a href="#orgea26d39">apendice A</a> se pueden encontrar mayores detalles.
</p>

<p>
<b>Ejercicio 4-14</b>. Defina una macro <code>swap(t,x,y)</code> que intercambie
dos argumentos de tipo <code>t</code>. (La estructura de bloques ayudara.)
</p>
</div>
</div>

<div id="outline-container-org5e77945" class="outline-4">
<h4 id="org5e77945">4.11.3 Inclusion condicional                                      <a id="org8ef80bd"></a></h4>
<div class="outline-text-4" id="text-org5e77945">
<p>
Es posible controlar el preprocesamiento mismo con proposiciones
condicionales que se evaluan durante esa etapa. Esto proporciona
una forma de incluir codigo selectivamente, dependiendo del valor
de condiciones evaluadas durante la compilacion.
</p>

<p>
La linea <code>#if</code> evalua una expresion constante entera (que no puede
incluir <code>sizeof</code>, casts o constantes <code>enum</code>). Si la expresion es
diferente de cero, se incluyen las siguientes lineas hasta un
<code>#endif</code>, <code>#elif</code> o <code>#else</code>. (La proposicion de procesador <code>#elif</code>
es como <code>else-if</code>). La expresion <code>defined(nombre)</code> en un <code>#if</code> es
<code>1</code> si el <i>nombre</i> se ha definido, y <code>0</code> de otra manera.
</p>

<p>
Por ejemplo, para asegurarse de que el contenido de un archivo
<code>hdr.h</code> se incluya solo una vez, el contenido del archivo se
delimita con una condicional como esta:
</p>

<div class="org-src-container">
<pre class="src src-c"><span style="color: #b0c4de;">#if</span> !<span style="color: #b0c4de;">defined</span> (HDR)
<span style="color: #b0c4de;">#define</span> <span style="color: #eedd82;">HDR</span>

<span style="color: #ff4500;">/* </span><span style="color: #ff4500;">el contenido de hdr.h va aqui </span><span style="color: #ff4500;">*/</span>

<span style="color: #b0c4de;">#endif</span>
</pre>
</div>

<p>
La primera inclusion de <code>hdr.h</code> define el nombre <code>HDR</code>; las
siguientes inclusiones encontraran definido al nombre y pasaran
hacia el <code>#endif</code>. Un estilo semejante puede emplearse para evitar
incluir archivos varias veces. Si este estilo se utiliza en forma
consistente, entonces cada <i>header</i> puede en si mismo incluir
cualquier otro del que dependa, sin que el usuario tenga que
tratar con la interdependencia.
</p>

<p>
La siguiente secuencia prueba el nombre <a href="#org2bcae28"><code>SYSTEM</code></a> para decidir cual
version de un <i>header</i> incluir:
</p>

<div class="org-src-container">
<pre class="src src-c"><span style="color: #b0c4de;">#if</span> SYSTEM == SYSV
<span style="color: #b0c4de;">    #define</span> <span style="color: #eedd82;">HDR</span> <span style="color: #ffa07a;">"sysv.h"</span>
<span style="color: #b0c4de;">#elif</span> SYSTEM == BSD
<span style="color: #b0c4de;">    #define</span> <span style="color: #eedd82;">HDR</span> <span style="color: #ffa07a;">"bsd.h"</span>
<span style="color: #b0c4de;">#elif</span> SYSTEM == MSDOS
<span style="color: #b0c4de;">    #define</span> <span style="color: #eedd82;">HDR</span> <span style="color: #ffa07a;">"msdos.h"</span>
<span style="color: #b0c4de;">#else</span>
<span style="color: #b0c4de;">    #define</span> <span style="color: #eedd82;">HDR</span> <span style="color: #ffa07a;">"default.h"</span>
<span style="color: #b0c4de;">#endif</span>
<span style="color: #b0c4de;">#include</span> HDR
</pre>
</div>

<p>
Las lineas <code>#ifdef</code> e <code>#ifndef</code> son formas especializadas que
prueban si un nombre esta definido. El primer ejemplo de <code>#if</code> de
mas arriba pudo haberse escrito
</p>

<div class="org-src-container">
<pre class="src src-c"><span style="color: #b0c4de;">#if</span><span style="color: #b0c4de;">n</span><span style="color: #b0c4de;">def</span> HDR
<span style="color: #b0c4de;">#define</span> <span style="color: #eedd82;">HDR</span>

<span style="color: #ff4500;">/* </span><span style="color: #ff4500;">contenido de hdr.h va aqui </span><span style="color: #ff4500;">*/</span>

<span style="color: #b0c4de;">#endif</span>
</pre>
</div>
</div>
</div>
</div>
</div>

<div id="outline-container-orgf0a8297" class="outline-2">
<h2 id="orgf0a8297">capitulo 5: Apuntadores y arreglos                                  <a id="org69d49af"></a></h2>
<div class="outline-text-2" id="text-orgf0a8297">
<p>
Un apuntador es una variable que contiene la direccion de una
variable. Los apuntadores se utilizan mucho en C, en parte debido a
que ellos son en ocasiones la unica forma de expresar una operacion,
y en parte debido a que por lo general llevan un codigo mas compacto
y eficiente de lo que se puede obtener en otras formas. Los
apuntadores y los arreglos estan relacionados intimamente; este
capitulo tambien explora estas relaciones y muestra como
explotarlas.
</p>

<p>
Los apuntadores se han puesto junto a la proposicion <code>goto</code> como una
forma maravillosa de crear programas ininteligibles. Esto es
verdadero cuando se utilizan en forma descuidada, y es facil crear
apuntadores que señalen a algun lugar inesperado. Sin embargo, con
disciplina, los apuntadores pueden tambien emplearse para obtener
claridad y simplicidad. Este es el aspecto que trataremos de
ilustrar.
</p>

<p>
El principal cambio en ANSI C es hacer explicitas las reglas acerca
de como pueden manipularse los apuntadores, obligando a lo que los
buenos programadores ya practican y lo que los buenos compiladores
ya imponen. Ademas, el tipo <code>void *</code> (apuntador a <code>void</code>) reemplaza
a <code>char *</code> como el tipo apropiado para un apuntador generico.
</p>
</div>

<div id="outline-container-orgf7ed1c8" class="outline-3">
<h3 id="orgf7ed1c8">5.1  Apuntadores y direcciones                                     <a id="org5e663a1"></a></h3>
<div class="outline-text-3" id="text-orgf7ed1c8">
<p>
Empecemos con un dibujo simplificado de como se organiza la
memoria. Una maquina tipica tiene un arreglo de celdas de memoria
numeradas o direccionadas consecutivamente, que pueden manipularse
individualmente o en grupos contiguos. Una situacion comun es que
cualquier byte puede ser un <code>char</code>, un par de celdas de un byte
pueden tratarse como un entero <code>short</code>, y cuatro bytes adyacentes
forman un <code>long</code>. Un apuntador es un grupo de celdas (generalmente
dos o cuatro) que pueden mantener una direccion. Asi, si <code>c</code> es un
<code>char</code> y <code>p</code> es un apuntador que apunta a el, podria representarse
la situacion de esta manera:
</p>


<div class="figure">
<p><img src="img/img_05.01.png" alt="img_05.01.png" />
</p>
</div>

<p>
El operador unario <code>&amp;</code> da la direccion de un objeto, de modo que la
proposicion.
</p>

<div class="org-src-container">
<pre class="src src-c">p = &amp;c;
</pre>
</div>

<p>
asigna la direccion de <code>c</code> a la variable <code>p</code>, y se dice que <code>p</code>
"apunta a" <code>c</code>. El operador <code>&amp;</code> solo se aplica a objetos que estan
en memoria: variables y elementos de arreglos. No puede aplicarse a
expresiones, constantes o variables tipo registro.
</p>

<p>
El operador unario <code>*</code> es el operador de <i>indireccion</i> o
<i>desreferencia</i>; cuando se aplica a un apuntador, da acceso al
objeto al que señala el apuntador. Supongase que <code>x</code> y <code>y</code> son
enteros e <code>ip</code> es un apuntador a <code>int</code>. Esta secuencia artificial
muestra como declarar un apuntador y como emplear <code>&amp;</code> y <code>*</code>:
</p>

<div class="org-src-container">
<pre class="src src-c"><span style="color: #98fb98;">int</span> <span style="color: #eedd82;">x</span> = 1, <span style="color: #eedd82;">y</span> = 2, <span style="color: #eedd82;">z</span>[10];
<span style="color: #98fb98;">int</span> *<span style="color: #eedd82;">ip</span>;       <span style="color: #ff4500;">/* </span><span style="color: #ff4500;">ip es un apuntador a int </span><span style="color: #ff4500;">*/</span>

ip = &amp;x;       <span style="color: #ff4500;">/* </span><span style="color: #ff4500;">ip ahora apunta a x </span><span style="color: #ff4500;">*/</span>
y = *ip;       <span style="color: #ff4500;">/* </span><span style="color: #ff4500;">y es ahora 1 </span><span style="color: #ff4500;">*/</span>
*ip = 0;       <span style="color: #ff4500;">/* </span><span style="color: #ff4500;">x es ahora 0 </span><span style="color: #ff4500;">*/</span>
ip = &amp;z[0];    <span style="color: #ff4500;">/* </span><span style="color: #ff4500;">ip ahora apunta a z[0] </span><span style="color: #ff4500;">*/</span>
</pre>
</div>

<p>
Las declaraciones de <code>x</code>, <code>y</code> y <code>z</code> son lo que hemos visto todo el
tiempo. La declaracion del apuntador <code>ip</code>,
</p>

<div class="org-src-container">
<pre class="src src-c"><span style="color: #98fb98;">int</span> *<span style="color: #eedd82;">ip</span>;
</pre>
</div>

<p>
funciona como mnemonico; dice que la expresion <code>*ip</code> es un
<code>int</code>. La sintaxis de la declaracion para una variable imita la
sintaxis de expresiones en las que la variable puede aparecer. Este
razonamiento se aplica tambien a la declaracion de funciones. Por
ejemplo,
</p>

<div class="org-src-container">
<pre class="src src-c"><span style="color: #98fb98;">double</span> *<span style="color: #eedd82;">dp</span>, <span style="color: #87cefa;">atoi</span> (<span style="color: #98fb98;">char</span> *);
</pre>
</div>

<p>
indica que en una expresion <code>*dp</code> y <code>atof(s)</code> tienen valores de
tipo <code>double</code>, y que el argumento de <a href="#org9f52a73"><code>atof</code></a> es un apuntador a
<code>char</code>.
</p>

<p>
Tambien se debe notar la implicacion que tiene el hecho de que un
apuntador esta restringido a señalar a una clase particular de
objeto: cada apuntador señala a un tipo especifico de datos. (Hay
una excepcion: un "apuntador a void" se emplea para mantener
cualquier tipo de apuntador, pero en si mismo no puede ser
<i>desreferenciado</i>. Esto se volvera a tratar en la <a href="#org99adeeb">seccion 5.11</a>.)
</p>

<p>
Si <code>ip</code> apunta al entero <code>x</code>, entonces <code>*ip</code> puede presentarse en
cualquier contexto donde <code>x</code> pueda hacerlo, asi que
</p>

<div class="org-src-container">
<pre class="src src-c">*ip = *ip + 10;
</pre>
</div>

<p>
incrementa <code>*ip</code> en <code>10</code>.
</p>

<p>
Los operadores unarios <code>*</code> y <code>&amp;</code> se ligan mas estrechamente que los
operadores aritmeticos; asi, la asignacion
</p>

<div class="org-src-container">
<pre class="src src-c">y = *ip + 1
</pre>
</div>

<p>
toma aquello a lo que apunte <code>ip</code>, le agrega <code>1</code>, y asigna el
resultado a <code>y</code>, mientras que
</p>

<div class="org-src-container">
<pre class="src src-c">*ip += 1
</pre>
</div>

<p>
incrementa en uno aquello a que ip apunta, como lo hace
</p>

<div class="org-src-container">
<pre class="src src-c">++*ip
</pre>
</div>

<p>
y
</p>

<div class="org-src-container">
<pre class="src src-c">(*ip)++
</pre>
</div>

<p>
Los parentesis son necesarios en este ultimo ejemplo; sin ellos, la
expresion incrementaria <code>ip</code> en lugar de a lo que apunta, debido a
que los operadores unarios como <code>*</code> y <code>++</code> se asocian de derecha a
izquierda.
</p>

<p>
Por ultimo, puesto que los apuntadores son variables, se pueden
emplear sin <i>desreferenciamiento</i>. Por ejemplo, si <code>iq</code> es otro
apuntador a <code>int</code>,
</p>

<div class="org-src-container">
<pre class="src src-c">iq = ip
</pre>
</div>

<p>
copia el contenido de <code>ip</code> en <code>iq</code>; asi, hace que <code>iq</code> apunte a lo
que <code>ip</code> esta apuntando.
</p>
</div>
</div>

<div id="outline-container-orge524012" class="outline-3">
<h3 id="orge524012">5.2  Apuntadores y argumentos de funciones                         <a id="orgac66db9"></a></h3>
<div class="outline-text-3" id="text-orge524012">
<p>
Puesto que C pasa los argumentos de funciones por valor, no existe
una forma directa para que la funcion que se invoca altere una
variable de la funcion que la llama. Por ejemplo, una rutina de
ordenamiento podria intercambiar dos elementos desordenados con una
funcion llamada <code>swap</code>. No es suficiente escribir
</p>

<div class="org-src-container">
<pre class="src src-c"><span style="color: #87cefa;">swap</span>(a, b);
</pre>
</div>

<p>
donde la funcion <code>swap</code> esta definida como
</p>

<div class="org-src-container">
<pre class="src src-c"><span style="color: #98fb98;">void</span> <span style="color: #87cefa;">swap</span>(<span style="color: #98fb98;">int</span> <span style="color: #eedd82;">x</span>, <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">y</span>) <span style="color: #ff4500;">/* </span><span style="color: #ff4500;">INCORRECTO </span><span style="color: #ff4500;">*/</span>
{
  <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">temp</span>;

  temp = x;
  x = y;
  y = temp;
}
</pre>
</div>

<p>
Debido a la llamada por valor, <code>swap</code> no puede afectar los
argumentos <code>a</code> y <code>b</code> que estan en la rutina que la llamo. La
funcion anterior solo intercambia <i>copias</i> de <code>a</code> y de <code>b</code>.
</p>

<p>
La forma de obtener los resultados que se desean es que el programa
invocador pase <i>apuntadores</i> a los valores que se cambiaran:
</p>

<div class="org-src-container">
<pre class="src src-c">swap(&amp;a, &amp;b);
</pre>
</div>

<p>
Puesto que el operador <code>&amp;</code> produce la direccion de una variable,
<code>&amp;a</code> es un apuntador a <code>a</code>. Dentro de la misma funcion <code>swap</code>, los
parametros se declaran para ser apuntadores, y se tiene acceso a
los operandos indirectamente a traves de ellos.
</p>

<div class="org-src-container">
<pre class="src src-c"><span style="color: #98fb98;">void</span> <span style="color: #87cefa;">swap</span>(<span style="color: #98fb98;">int</span> *<span style="color: #eedd82;">px</span>, <span style="color: #98fb98;">int</span> *<span style="color: #eedd82;">py</span>) <span style="color: #ff4500;">/* </span><span style="color: #ff4500;">intercambia *px y *py </span><span style="color: #ff4500;">*/</span>
{
  <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">temp</span>;

  temp = *px;
  *px = *py;
  *py = temp;
}
</pre>
</div>

<p>
Graficamente:
</p>


<div class="figure">
<p><img src="img/img_05.02.png" alt="img_05.02.png" />
</p>
</div>

<p>
Los argumentos tipo apuntador permiten a una funcion tener acceso y
cambiar objetos que estan en la funcion que la llamo. Como ejemplo,
considere una funcion <code>getint</code> que realiza una conversion de
entrada en formato libre, desglosando un flujo de caracteres en
valores enteros, un entero por llamada. Asi, <code>getint</code> tiene que
regresar el valor encontrado y tambien una señal de fin de archivo
cuando ya no hay mas que tomar. Esos valores tienen que regresarse
por rutas separadas, para que sin importar que valor se emplea para
<code>EOF</code>, tambien pueda ser el valor de un entero de la entrada.
</p>

<p>
Una solucion es hacer que <code>getint</code> regrese el estado de fin de
archivo como su valor de funcion, usando un argumento apuntador
para almacenar el entero convertido y tenerlo en la funcion
invocadora. Este esquema tambien es utilizado por <a href="#orgb47aa6e"><code>scanf</code></a>, como se
vera en la <a href="#org58236a0">seccion 7.4</a>.
</p>

<p>
El siguiente ciclo llena un arreglo con enteros por medio de
llamadas a <code>getint</code>:
</p>

<div class="org-src-container">
<pre class="src src-c"><span style="color: #98fb98;">int</span> <span style="color: #eedd82;">n</span>, <span style="color: #eedd82;">array</span>[SIZE], <span style="color: #87cefa;">getint</span>(<span style="color: #98fb98;">int</span> *);

<span style="color: #00ffff;">for</span> (n = 0; n &lt; SIZE &amp;&amp; getint(&amp;array[n]) != EOF; n++ )
</pre>
</div>


<p>
Cada llamada pone en <code>array[n]</code> el siguiente entero que se
encuentra a la entrada e incrementa <code>n</code>. Observese que es esencial
pasar la direccion de <code>array[n]</code> a <code>getint</code>. De otra manera no hay
forma de que <code>getint</code> comunique el entero convertido hacia la
funcion invocadora.
</p>

<p>
Esta version de <code>getint</code> regresa <code>EOF</code> como fin de archivo, cero si
la siguiente entrada no es un numero, y un valor positivo si la
entrada contiene un numero valido.
</p>

<div class="org-src-container">
<pre class="src src-c"><span style="color: #b0c4de;">#include</span> <span style="color: #ffa07a;">&lt;ctype.h&gt;</span>

<span style="color: #98fb98;">int</span> <span style="color: #87cefa;">getch</span>(<span style="color: #98fb98;">void</span>);
<span style="color: #98fb98;">void</span> <span style="color: #87cefa;">ungetch</span>(<span style="color: #98fb98;">int</span>);

<span style="color: #ff4500;">/* </span><span style="color: #ff4500;">getint: obtiene el siguiente entero de la entrada y lo asigna a *pn </span><span style="color: #ff4500;">*/</span>
<span style="color: #98fb98;">int</span> <span style="color: #87cefa;">getint</span>(<span style="color: #98fb98;">int</span> *<span style="color: #eedd82;">pn</span>)
{
  <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">c</span>, <span style="color: #eedd82;">sign</span>;
  <span style="color: #00ffff;">while</span> (isspace(c = getch())) <span style="color: #ff4500;">/* </span><span style="color: #ff4500;">ignora espacios en blanco </span><span style="color: #ff4500;">*/</span>
    ;
  <span style="color: #00ffff;">if</span> (!isdigit(c) &amp;&amp; c != EOF &amp;&amp; c != <span style="color: #ffa07a;">'+'</span> &amp;&amp; c != <span style="color: #ffa07a;">'-'</span>) {
    ungetch(c);               <span style="color: #ff4500;">/* </span><span style="color: #ff4500;">no es un numero            </span><span style="color: #ff4500;">*/</span>
    <span style="color: #00ffff;">return</span> 0;
  }
  sign = (c == <span style="color: #ffa07a;">'-'</span>) ? -1 : 1;
  <span style="color: #00ffff;">if</span> (c == <span style="color: #ffa07a;">'+'</span> || c == <span style="color: #ffa07a;">'-'</span>)
    c = getch();
  <span style="color: #00ffff;">for</span> (*pn = 0; isdigit(c); c = getch())
    *pn = 10 * *pn + (c - <span style="color: #ffa07a;">'0'</span>);
  *pn *= sign;
  <span style="color: #00ffff;">if</span> (c != EOF)
    ungetch(c);
  <span style="color: #00ffff;">return</span> c;
}
</pre>
</div>

<p>
A lo largo de <code>getint</code>, <code>*pn</code> se emplea como una variable <code>int</code>
ordinaria. Tambien se utilizo <code>getch</code> y <code>ungetch</code> (descritas en la
<a href="#org043af2c">seccion 4.3</a>) para que el caracter extra que debe leerse puede
regresar a la entrada.
</p>

<p>
<b>Ejercicio 5-1</b>. Como se escribio, <code>getint</code> trata a un <code>+</code> o un <code>-</code>
no seguido por un digito como una representacion valida de
cero. Corrijala para que regrese tal caracter a la entrada.
</p>

<p>
<b>Ejercicio 5-2</b>. Escriba <code>getfloat</code>, la analogia de punto flotante de
<code>getint</code>. ¿Que tipo regresa <code>getfloat</code> como su valor de funcion?
</p>
</div>
</div>

<div id="outline-container-org52b8b5a" class="outline-3">
<h3 id="org52b8b5a">5.3  Apuntadores y arreglos                                        <a id="org7a1ce72"></a></h3>
<div class="outline-text-3" id="text-org52b8b5a">
<p>
En C existe una fuerte relacion entre apuntadores y arreglos, tan
fuerte que deben discutirse simultaneamente. Cualquier operacion
que pueda lograrse por indexacion de un arreglo tambien puede
realizarse con apuntadores. La version con apuntadores sera por lo
general mas rapida, pero, al menos para los no iniciados, algo mas
dificil de entender.
</p>

<p>
La declaracion
</p>

<div class="org-src-container">
<pre class="src src-c"><span style="color: #98fb98;">int</span> <span style="color: #eedd82;">a</span>[10];
</pre>
</div>

<p>
define un arreglo a de tamaño <code>10</code>, esto es, un bloque de 10 objetos
consecutivos llamados <code>a[0]</code>, <code>a[1]</code>, &#x2026;, <code>a[9]</code>.
</p>


<div class="figure">
<p><img src="img/img_05.03.01.png" alt="img_05.03.01.png" />
</p>
</div>

<p>
La notacion <code>a[i]</code> se refiere al i-esimo elemento del arreglo. Si <code>pa</code> es un apuntador
a un entero, declarado como
</p>

<div class="org-src-container">
<pre class="src src-c"><span style="color: #98fb98;">int</span> *<span style="color: #eedd82;">pa</span>;
</pre>
</div>

<p>
entonces la asignacion
</p>

<div class="org-src-container">
<pre class="src src-c">pa = &amp;a[0];
</pre>
</div>

<p>
hace que <code>pa</code> apunte al elemento cero de <code>a</code>; esto es, <code>pa</code>
contiene la direccion de <code>a[0]</code>.
</p>


<div class="figure">
<p><img src="img/img_05.03.02.png" alt="img_05.03.02.png" />
</p>
</div>

<p>
Ahora la asignacion
</p>

<div class="org-src-container">
<pre class="src src-c">x = *pa;
</pre>
</div>

<p>
copiara el contenido de <code>a[0]</code> en <code>x</code>.
</p>

<p>
Si <code>pa</code> apunta a un elemento en particular de un arreglo, entonces
por definicion <code>pa + 1</code> apunta al siguiente elemento, <code>pa + i</code>
apunta <code>i</code> elementos despues de <code>pa</code>, y <code>pa - i</code> apunta <code>i</code>
elementos antes. Asi, si <code>pa</code> apunta a <code>a[0]</code>,
</p>

<div class="org-src-container">
<pre class="src src-c">*(pa + 1)
</pre>
</div>

<p>
se refiere al contenido de <code>a[1]</code>, <code>pa + i</code> es la direccion de
<code>a[i]</code> y <code>*(pa + i)</code> es el contenido de <code>a[i]</code>.
</p>


<div class="figure">
<p><img src="img/img_05.03.03.png" alt="img_05.03.03.png" />
</p>
</div>

<p>
Lo anterior es verdadero sin importar el tipo o tamaño de las
variables del arreglo <code>a</code>. El significado de "agregar <code>1</code> a un
apuntador", y por extension, toda la aritmetica de apuntadores, es
que <code>pa + 1</code> apunta al siguiente objeto, y <code>pa + i</code> apunta al
i-esimo objeto adelante de <code>pa</code>.
</p>

<p>
La correspondencia entre indexacion y aritmetica de apuntadores es
muy estrecha. Por definicion, el valor de una variable o expresion
de tipo arreglo es la direccion del elemento cero del arreglo. Asi,
que despues de la asignacion
</p>

<div class="org-src-container">
<pre class="src src-c">pa = &amp;a[0];
</pre>
</div>

<p>
<code>pa</code> y <code>a</code> tienen valores identicos. Puesto que el nombre de un
arreglo es un sinonimo para la localidad del elemento inicial, la
asignacion <code>pa = &amp;a[0]</code> puede escribirse tambien como
</p>

<div class="org-src-container">
<pre class="src src-c">pa = a;
</pre>
</div>

<p>
Mas sorprendente, al menos a primera vista, es el hecho de que una
referencia a <code>a[i]</code> tambien puede escribirse como <code>*(a + i)</code>. Al
evaluar <code>a[i]</code>, C la convierte inmediatamente a <code>*(a + i)</code>; las dos
formas son equivalentes. Al aplicar el operador <code>&amp;</code> a ambas partes
de esta equivalencia, se deriva que <code>&amp;a[i]</code> y <code>a + i</code> tambien son
identicas: <code>a + i</code> es la direccion del i-esimo elemento delante de
<code>a</code>. Por otra parte, si <code>pa</code> es un apuntador, las expresiones
pueden usarlo con un subindice; <code>pa[i]</code> es identico a <code>*(pa + i)</code>.
En resumen, cualquier expresion de arreglo e indice es equivalente
a una opresion escrita como un apuntador y un desplazamiento.
</p>

<p>
Existe una diferencia entre un nombre de arreglo y un apuntador,
que debe tenerse en mente. Un apuntador es una variable, por esto
<code>pa = a</code> y <code>pa++</code> son legales. Pero un nombre de arreglo no es una
variable; construcciones como <code>a = pa</code> y <code>a++</code> son ilegales.
</p>

<p>
Cuando un nombre de arreglo se pasa a una funcion, lo que se pasa
es la localidad del elemento inicial. Dentro de la funcion que se
llama, este argumento es una variable local, y por lo tanto, un
parametro de nombre de arreglo es un apuntador, esto es, una
variable que contiene una direccion. Se puede utilizar este hecho
para escribir otra version de <code>strlen</code>, que calcula la longitud de
una cadena.
</p>

<div class="org-src-container">
<pre class="src src-c"><span style="color: #ff4500;">/* </span><span style="color: #ff4500;">strlen: regresa la longitud de la cadena s </span><span style="color: #ff4500;">*/</span>
<span style="color: #98fb98;">int</span> <span style="color: #87cefa;">strlen</span>(<span style="color: #98fb98;">char</span> *<span style="color: #eedd82;">s</span>)
{
  <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">n</span>;

  <span style="color: #00ffff;">for</span> (n = 0; *s != <span style="color: #ffa07a;">'\0'</span>; s++)
    n++;
  <span style="color: #00ffff;">return</span> n;
}
</pre>
</div>

<p>
Puesto que <code>s</code> es un apuntador, es perfectamente legal
incrementarlo; <code>s++</code> no tiene efecto alguno sobre la cadena de
caracteres de la funcion que llamo a <code>strlen</code>, sino que simplemente
incrementa la copia privada del apuntador de <code>strlen</code>. Eso
significa que llamadas como
</p>

<div class="org-src-container">
<pre class="src src-c">strlen(<span style="color: #ffa07a;">"hola, mundo"</span>);     <span style="color: #ff4500;">/* </span><span style="color: #ff4500;">constante de cadena </span><span style="color: #ff4500;">*/</span>
<span style="color: #87cefa;">strlen</span>(array);             <span style="color: #ff4500;">/* </span><span style="color: #ff4500;">char array[100];    </span><span style="color: #ff4500;">*/</span>
<span style="color: #87cefa;">strlen</span>(ptr);               <span style="color: #ff4500;">/* </span><span style="color: #ff4500;">char *ptr;          </span><span style="color: #ff4500;">*/</span>
</pre>
</div>

<p>
si funcionan.
</p>

<p>
Puesto que los parametros formales en una definicion de funcion,
</p>

<div class="org-src-container">
<pre class="src src-c"><span style="color: #98fb98;">char</span> <span style="color: #eedd82;">s</span>[];
</pre>
</div>

<p>
y
</p>

<div class="org-src-container">
<pre class="src src-c"><span style="color: #98fb98;">char</span> *<span style="color: #eedd82;">s</span>;
</pre>
</div>

<p>
son equivalentes, preferimos el ultimo, porque indica mas
explicitamente que el parametro es un apuntador. Cuando un nombre
de arreglo se pasa a una funcion, esta puede interpretar a su
conveniencia que se ha manejado un arreglo o un apuntador, y
manipularlo en consecuencia. Puede incluso emplear ambas notaciones
si ello lo hace apropiado y claro.
</p>

<p>
Es posible pasar parte de un arreglo a una funcion, pasando un
apuntador al inicio del subarreglo. Por ejemplo, si <code>a</code> es un
arreglo,
</p>

<div class="org-src-container">
<pre class="src src-c">f(&amp;a[2])
</pre>
</div>

<p>
y
</p>

<div class="org-src-container">
<pre class="src src-c"><span style="color: #87cefa;">f</span>(a + 2)
</pre>
</div>

<p>
ambas pasan a la funcion <code>f</code> la direccion del subarreglo que inicia
en <code>a[2]</code>. Dentro de <code>f</code>, la declaracion de parametros puede ser
</p>

<div class="org-src-container">
<pre class="src src-c"><span style="color: #87cefa;">f</span>(<span style="color: #98fb98;">int</span> <span style="color: #eedd82;">arr</span>[]) { ... }
</pre>
</div>

<p>
o
</p>

<div class="org-src-container">
<pre class="src src-c"><span style="color: #87cefa;">f</span>(<span style="color: #98fb98;">int</span> *<span style="color: #eedd82;">arr</span>) { ... }
</pre>
</div>

<p>
Asi, hasta donde a <code>f</code> le concierne, el hecho de que el parametro se
refiera a parte de un arreglo mas grande no es de consecuencia.
</p>

<p>
Si se esta seguro de que los elementos existen, tambien es posible
indexar hacia atras en un arreglo; <code>p[-1]</code>, <code>p[-2]</code>, etc., son
legitimos desde el punto de vista sintactico, y se refieren a
elementos que preceden inmediatamente a <code>p[0]</code>. Por supuesto, es
ilegal hacer referencia a objetos que no esten dentro de los
limites del arreglo.
</p>
</div>
</div>

<div id="outline-container-orgab7cd6c" class="outline-3">
<h3 id="orgab7cd6c">5.4  Aritmetica de direcciones                                     <a id="org290bc3b"></a></h3>
<div class="outline-text-3" id="text-orgab7cd6c">
<p>
Si <code>p</code> es un apuntador a algun elemento de un arreglo, entonces
<code>p++</code> incrementa <code>p</code> para apuntar al siguiente elemento, y <code>p += i</code>
la incrementa para apuntar <code>i</code> elementos adelante de donde
actualmente lo hace. Esas y otras construcciones semejantes son las
formas mas simples de aritmetica de apuntadores o de direcciones.
</p>

<p>
El lenguaje C es consistente y regular en su enfoque a la
aritmetica de direcciones; su integracion de apuntadores, arreglos
y aritmetica de direcciones es uno de los aspectos que le dan
fuerza. Lo ilustraremos al escribir un rudimentario asignador de
memoria. Hay dos rutinas: la primera, <code>alloc(n)</code>, regresa un
apuntador a <code>n</code> posiciones consecutivas, que pueden ser empleadas
por el invocador de <code>alloc</code> para almacenar caracteres. La segunda,
<code>afree(p)</code>, libera el almacenamiento adquirido en esta forma, de
modo que pueda ser reutilizado posteriormente. Las rutinas son
rudimentarias, puesto que las llamadas a <code>afree</code> deben realizarse
en el orden opuesto a las llamadas realizadas a <code>alloc</code>. Es decir,
el almacenamiento manejado por <code>alloc</code> y <code>afree</code> es una pila o
lista del tipo ultimo-que-entra, primero-que-sale. La biblioteca
estandar proporciona funciones analogas llamadas <a href="#org292ad05"><code>malloc</code></a> y <a href="#org0a5a9fe"><code>free</code></a>
que no tienen tales restricciones; en la <a href="#org2b166a5">seccion 8.7</a> se mostrara
como se Pueden realizar.
</p>

<p>
La implantacion mas sencilla es hacer que <code>alloc</code> maneje piezas de
un gran arreglo de caracteres al que llamaremos <code>allocbuf</code>. Este
arreglo esta reservado para <code>alloc</code> y para <code>afree</code>. Puesto que
estas hacen su trabajo con apuntadores, no con indices, ninguna
otra rutina necesita conocer el nombre del arreglo, el cual puede
ser declarado como <code>static</code> en el archivo fuente que contiene a
<code>alloc</code> y a <code>afree</code>, y asi ser invisible hacia afuera. En la
implantacion practica, el arreglo puede incluso no tener un nombre;
podria obtenerse llamando a <a href="#org292ad05"><code>malloc</code></a> o pidiendo al sistema
operaiivo un apuntador hacia algun bloque sin nombre de memoria.
</p>

<p>
La otra informacion necesaria es cuanto de <code>allocbuf</code> se ha
utilizado. Empleamos un apuntador, llamado <code>allocp</code>, que apunta
hacia el siguiente elemento libre. Cuando se requieren <code>n</code>
caracteres a <code>alloc</code>, primero revisa si hay suficiente espacio
libre en <code>allocbuf</code>. Si lo hay, <code>alloc</code> regresa el valor actual de
<code>allocp</code> (esto es, el principio del bloque libre), despues lo
incrementa en <code>n</code> para apuntar a la siguiente area libre. Si no hay
espacio, <code>alloc</code> regresa cero, en tanto que <code>afree(p)</code> simplemente
hace <code>allocp</code> igual a <code>p</code> si <code>p</code> esta dentro de <code>allocbuf</code>.
</p>


<div class="figure">
<p><img src="img/img_05.04.png" alt="img_05.04.png" />
</p>
</div>

<div class="org-src-container">
<pre class="src src-c"><span style="color: #b0c4de;">#define</span> <span style="color: #eedd82;">ALLOCSIZE</span> 10000            <span style="color: #ff4500;">/* </span><span style="color: #ff4500;">tama&#241;o del espacio disponible </span><span style="color: #ff4500;">*/</span>

<span style="color: #00ffff;">static</span> <span style="color: #98fb98;">char</span> <span style="color: #eedd82;">allocbuf</span> [ALLOCSIZE];  <span style="color: #ff4500;">/* </span><span style="color: #ff4500;">almacenamiento para alloc     </span><span style="color: #ff4500;">*/</span>
<span style="color: #00ffff;">static</span> <span style="color: #98fb98;">char</span> *<span style="color: #eedd82;">allocp</span> = allocbuf;    <span style="color: #ff4500;">/* </span><span style="color: #ff4500;">siguiente posicion libre      </span><span style="color: #ff4500;">*/</span>

<span style="color: #98fb98;">char</span> *<span style="color: #87cefa;">alloc</span>(<span style="color: #98fb98;">int</span> <span style="color: #eedd82;">n</span>)                 <span style="color: #ff4500;">/* </span><span style="color: #ff4500;">regresa un apuntador a n caracteres </span><span style="color: #ff4500;">*/</span>
{
  <span style="color: #00ffff;">if</span> (allocbuf + ALLOCSIZE - allocp &gt;= n) { <span style="color: #ff4500;">/* </span><span style="color: #ff4500;">si cabe   </span><span style="color: #ff4500;">*/</span>
    allocp += n;
    <span style="color: #00ffff;">return</span> allocp - n;                      <span style="color: #ff4500;">/* </span><span style="color: #ff4500;">antigua p </span><span style="color: #ff4500;">*/</span>
  } <span style="color: #00ffff;">else</span>                           <span style="color: #ff4500;">/* </span><span style="color: #ff4500;">no hay suficiente espacio </span><span style="color: #ff4500;">*/</span>
    <span style="color: #00ffff;">return</span> 0;
}

<span style="color: #98fb98;">void</span> <span style="color: #87cefa;">afree</span>(<span style="color: #98fb98;">char</span> *<span style="color: #eedd82;">p</span>)                <span style="color: #ff4500;">/* </span><span style="color: #ff4500;">almacenamiento libre apuntado por p </span><span style="color: #ff4500;">*/</span>
{
  <span style="color: #00ffff;">if</span> (p &gt;= allocbuf &amp;&amp; p &lt; allocbuf + ALLOCSIZE)
    allocp = p;
}
</pre>
</div>

<p>
En general, un apuntador puede ser inicializado tal como cualquier
otra variable, aunque normalmente los unicos valores significativos
son cero o una expresion que involucre la direccion de un dato
previamente definido y de un tipo apropiado. La declaracion
</p>

<div class="org-src-container">
<pre class="src src-c"><span style="color: #00ffff;">static</span> <span style="color: #98fb98;">char</span> * <span style="color: #eedd82;">allocp</span> = allocbuf;
</pre>
</div>

<p>
define a <code>allocp</code> como un apuntador a caracteres y lo inicializa para
apuntar al principio de <code>allocbuf</code>, que es la siguiente posicion
libre cuando el programa comienza. Esto tambien podria haberse
escrito
</p>

<div class="org-src-container">
<pre class="src src-c"><span style="color: #00ffff;">static</span> <span style="color: #98fb98;">char</span> * <span style="color: #eedd82;">allocp</span> = &amp;allocbuf[0];
</pre>
</div>

<p>
puesto que el nombre del arreglo <i>es</i> la direccion del elemento cero.
</p>

<p>
La prueba
</p>

<div class="org-src-container">
<pre class="src src-c"><span style="color: #00ffff;">if</span> (allocbuf + ALLOCSIZE - allocp &gt;= n) { <span style="color: #ff4500;">/* </span><span style="color: #ff4500;">si cabe   </span><span style="color: #ff4500;">*/</span>
</pre>
</div>

<p>
comprueba si existe suficiente espacio para satisfacer la peticion
de <code>n</code> caracteres. Si lo hay, el nuevo valor de <code>allocp</code> seria,
cuando mucho, uno adelante del fin de <code>allocbuf</code>. Si la peticion
puede satisfacerse, <code>alloc</code> regresa un apuntador al principio de un
bloque de caracteres (notese la declaracion de la funcion). De lo
contrario, <code>alloc</code> debe regresar alguna señal de que no queda
espacio. El lenguaje C garantiza que cero nunca es una direccion
valida para datos y por lo tanto puede usarse un valor de cero como
retorno para señalar un suceso anormal, en este caso, falta de
espacio.
</p>

<p>
Los apuntadores y los enteros no son intercambiables. Cero es la
unica excepcion: la constante cero puede ser asignada a un
apuntador, y este puede compararse contra la constante cero. La
constante simbolica <code>NULL</code> se emplea con frecuencia en lugar de
cero, como un mnemonico para indicar mas claramente que es un valor
especial para un apuntador. <code>NULL</code> esta definido en <code>&lt;stdio.h&gt;</code>. De
aqui en adelante se utilizara <code>NULL</code>.
</p>

<p>
Pruebas como
</p>

<div class="org-src-container">
<pre class="src src-c"><span style="color: #00ffff;">if</span> (allocbuf + ALLOCSIZE - allocp &gt;= n) { <span style="color: #ff4500;">/* </span><span style="color: #ff4500;">si cabe   </span><span style="color: #ff4500;">*/</span>
</pre>
</div>

<p>
y
</p>

<div class="org-src-container">
<pre class="src src-c"><span style="color: #00ffff;">if</span> (p &gt;= allocbuf &amp;&amp; p &lt; allocbuf + ALLOCSIZE)
</pre>
</div>

<p>
muestran varias facetas importantes de la aritmetica de
apuntadores. Primero, los apuntadores pueden compararse bajo
ciertas circunstancias. Si <code>p</code> y <code>q</code> apuntan a miembros del mismo
arreglo, entonces relaciones como <code>==</code>, <code>!=</code>, <code>&lt;</code>, <code>&gt;=</code>, etc.,
funcionan correctamente. Por ejemplo,
</p>

<div class="org-src-container">
<pre class="src src-c">p &lt; q
</pre>
</div>

<p>
es verdadero si <code>p</code> apunta a un elemento que esta antes en el
arreglo de lo que esta al que apunta <code>q</code>. Cualquier apuntador puede
ser comparado por su igualdad o desigualdad con cero. Pero esta
indefinido el comportamiento para la aritmetica o comparaciones con
apuntadores que no apuntan a miembros del mismo arreglo. (Existe
una excepcion: la direccion del primer elemento que esta despues
del fin de un arreglo puede emplearse en aritmetica de
apuntadores.)
</p>

<p>
Segundo, ya se ha observado que un apuntador y un entero pueden
sumarse o restarse. La construccion
</p>

<div class="org-src-container">
<pre class="src src-c">p + n
</pre>
</div>

<p>
significa la direccion del n-esimo objeto adelante del que apunta
actualmente <code>p</code>. Esto es verdadero sin importar la clase de objeto
al que apunta <code>p</code>; <code>n</code> es escalada de acuerdo con el tamaño de los
objetos a los que apunta <code>p</code>, lo cual esta determinado por la
declaracion de <code>p</code>. Si un <code>int</code> es de cuatro bytes, por ejemplo, la
escala para el <code>int</code> sera de cuatro.
</p>

<p>
La resta de apuntadores tambien es valida: si <code>p</code> y <code>q</code> apuntan a
elementos del mismo arreglo, y <code>p &lt; q</code>, entonces <code>q - p + 1</code> es el
numero de elementos desde <code>p</code> hasta <code>q</code>, inclusive. Este hecho
puede usarse para escribir todavia otra version de <code>strlen</code>:
</p>

<div class="org-src-container">
<pre class="src src-c"><span style="color: #ff4500;">/* </span><span style="color: #ff4500;">strlen: regresa la longitud de la cadena s </span><span style="color: #ff4500;">*/</span>
<span style="color: #98fb98;">int</span> <span style="color: #87cefa;">strlen</span>(<span style="color: #98fb98;">char</span> *<span style="color: #eedd82;">s</span>)
{
  <span style="color: #98fb98;">char</span> *<span style="color: #eedd82;">p</span> = s;

  <span style="color: #00ffff;">while</span> (*p != <span style="color: #ffa07a;">'\0'</span>)
    p++;
  <span style="color: #00ffff;">return</span> p - s;
}
</pre>
</div>

<p>
En su declaracion, <code>p</code> se inicializa en <code>s</code>, esto es, para apuntar
al primer caracter de la cadena. En el ciclo <code>while</code>, cada caracter
se examina en su turno hasta que al final se encuentra el
'\0'. Debido a que <code>p</code> apunta a caracteres, <code>p++</code> avanza <code>p</code> al
siguiente caracter cada vez, y <code>p - s</code> da el numero de caracteres
que se avanzaron, esto es, la longitud de la cadena. (El numero de
caracteres en la cadena puede ser demasiado grande como para
almacenarse en un <code>int</code>. El header <code>&lt;stddef.h&gt;</code> define un tipo
<code>ptrdiff_t</code>, que es suficientemente grande para almacenar la
diferencia signada de dos valores apuntadores. Sin embargo, si se
es muy cauteloso, se debe usar <code>size_t</code> para el tipo de retorno de
<code>strlen</code>, para coincidir con la version de la biblioteca estandar,
<code>size_t</code> es el tipo de entero sin signo que regresa el operador
<code>sizeof</code>.)
</p>

<p>
La aritmetica de apuntadores es consistente: si estuvieramos
tratando con <code>float</code>, que ocupan mas espacio de memoria que los
<code>char</code>, y si <code>p</code> fuera un apuntador a <code>float</code>, <code>p++</code> avanzaria al
siguiente <code>float</code>. Asi, podemos escribir otra version de <code>alloc</code>
que mantenga floats en lugar de chars, simplemente cambiando de
<code>char</code> a <code>float</code> en todo <code>alloc</code> y <code>afree</code>. Todas las
manipulaciones de apuntadores tomaran automaticamente en cuenta el
tamaño de los objetos apuntados.
</p>

<p>
Las operaciones validas de apuntadores son asignacion de
apuntadores del mismo tipo, suma y substraccion de un apuntador y
un entero, resta o comparacion de dos apuntadores a miembros del
mismo arreglo, y asignacion o comparacion con cero. Toda otra
aritmetica de apuntadores es ilegal. No es legal sumar dos
apuntadores, multiplicarlos o dividirlos, enmascararlos o
agregarles un <code>float</code> o un <code>double</code>, o aun, excepto para <code>void *</code>,
asignar un apuntador de un tipo a un apuntador de otro tipo sin una
conversion forzosa de tipo.
</p>
</div>
</div>

<div id="outline-container-org8d6bc13" class="outline-3">
<h3 id="org8d6bc13">5.5  Apuntadores a caracteres, y funciones                         <a id="orge956681"></a></h3>
<div class="outline-text-3" id="text-org8d6bc13">
<p>
Una <i>constante de cadena</i>, escrita como
</p>

<div class="org-src-container">
<pre class="src src-c"><span style="color: #ffa07a;">"Soy una cadena"</span>
</pre>
</div>

<p>
es un arreglo de caracteres. En la representacion interna, el
arreglo termina con el caracter nulo '\0' de tal manera que los
programas puedan encontrar el fin. La longitud de almacenamiento es
asi uno mas que el numero de caracteres entre las comillas.
</p>

<p>
Posiblemente la mas comun ocurrencia de cadenas constantes se
encuentra como argumentos a funciones, como en
</p>

<div class="org-src-container">
<pre class="src src-c">printf(<span style="color: #ffa07a;">"hola, mundo\n"</span>);
</pre>
</div>

<p>
Cuando una cadena de caracteres como esta aparece en un programa,
el acceso a ella es a traves de un apuntador a caracteres; <a href="#org0458a76"><code>printf</code></a>
recibe un apuntador al inicio del arreglo de caracteres. Esto es,
se tiene acceso a una cadena constante por un apuntador a su primer
elemento.
</p>

<p>
Las cadenas constantes no necesitan ser argumentos de funciones. Si
<code>pmessage</code> se declara como
</p>

<div class="org-src-container">
<pre class="src src-c"><span style="color: #98fb98;">char</span> * <span style="color: #eedd82;">pmessage</span>;
</pre>
</div>

<p>
entonces la proposicion
</p>

<div class="org-src-container">
<pre class="src src-c">pmessage = <span style="color: #ffa07a;">"now is the time"</span>;
</pre>
</div>

<p>
asigna a <code>pmessage</code> un apuntador al arreglo de caracteres. Esta
<i>no</i> es la copia de una cadena; solo concierne a apuntadores. El
lenguaje C no proporciona ningun operador para procesar como unidad
una cadena de caracteres.
</p>

<p>
Existe una importante diferencia entre estas definiciones:
</p>

<div class="org-src-container">
<pre class="src src-c"><span style="color: #98fb98;">char</span> <span style="color: #eedd82;">amessage</span>[] = <span style="color: #ffa07a;">"now is the time"</span>; <span style="color: #ff4500;">/* </span><span style="color: #ff4500;">arreglo   </span><span style="color: #ff4500;">*/</span>
<span style="color: #98fb98;">char</span> *<span style="color: #eedd82;">pmessage</span>  = <span style="color: #ffa07a;">"now is the time"</span>; <span style="color: #ff4500;">/* </span><span style="color: #ff4500;">apuntador </span><span style="color: #ff4500;">*/</span>
</pre>
</div>

<p>
<code>amessage</code> es un arreglo, suficientemente grande como para contener
la secuencia de caracteres y el '\0' que lo inicializa. Se pueden
modificar caracteres individuales dentro del arreglo, pero
<code>amessage</code> siempre se referira a la misma localidad de
almacenamiento. Por otro lado, <code>pmessage</code> es un apuntador,
inicializado para apuntar a una cadena constante; el apuntador
puede modificarse posteriormente para que apunte a algun otro lado,
pero el resultado es indefinido si trata de modificar el contenido
de la cadena.
</p>


<div class="figure">
<p><img src="img/img_05.05.png" alt="img_05.05.png" />
</p>
</div>

<p>
Ilustraremos mas aspectos de los apuntadores y los arreglos,
estudiando versiones de dos utiles funciones adaptadas de la
biblioteca estandar. La primera funcion es <code>strcpy(s,t)</code>, que copia
la cadena <code>t</code> a la cadena <code>s</code>. Seria agradable decir simplemente <code>s
   = t</code>, pero esto copia el apuntador, no los caracteres. Para copiar
los caracteres se requiere de un ciclo. Primero esta la version con
un arreglo:
</p>

<div class="org-src-container">
<pre class="src src-c"><span style="color: #ff4500;">/* </span><span style="color: #ff4500;">strcpy: copia t hacia s; version de subindices </span><span style="color: #ff4500;">*/</span>
<span style="color: #98fb98;">void</span> <span style="color: #87cefa;">strcpy</span>(<span style="color: #98fb98;">char</span> *<span style="color: #eedd82;">s</span>, <span style="color: #98fb98;">char</span> *<span style="color: #eedd82;">t</span>)
{
  <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">i</span>;
  i = 0;
  <span style="color: #00ffff;">while</span> ((s[i] = t[i]) != <span style="color: #ffa07a;">'\0'</span>)
    i++;
}
</pre>
</div>

<p>
En contraste, aqui esta una version de <code>strcpy</code> con apuntadores:
</p>

<div class="org-src-container">
<pre class="src src-c"><span style="color: #ff4500;">/* </span><span style="color: #ff4500;">strcpy: copia t hacia s; version uno con apuntadores </span><span style="color: #ff4500;">*/</span>
<span style="color: #98fb98;">void</span> <span style="color: #87cefa;">strcpy</span>(<span style="color: #98fb98;">char</span> *<span style="color: #eedd82;">s</span>, <span style="color: #98fb98;">char</span> *<span style="color: #eedd82;">t</span>)
{
  <span style="color: #00ffff;">while</span> ((*s = *t) != <span style="color: #ffa07a;">'\0'</span>) {
    s++;
    t++;
  }
}
</pre>
</div>

<p>
Puesto que los argumentos se pasan por valor, <code>strcpy</code> puede
utilizar los parametros <code>s</code> y <code>t</code> en la forma que le parezca
mejor. Aqui hay apuntadores convenientemente inicializados, que se
desplazan a lo largo del arreglo un caracter a la vez, hasta que el
'\0' con que termina <code>t</code> se ha copiado a <code>s</code>.
</p>

<p>
En la practica, <code>strcpy</code> no se escribiria como se mostro
anteriormente. Los programadores expertos de C preferirian
</p>

<div class="org-src-container">
<pre class="src src-c"><span style="color: #ff4500;">/* </span><span style="color: #ff4500;">strcpy: copia t hacia s; version dos con apuntadores </span><span style="color: #ff4500;">*/</span>
<span style="color: #98fb98;">void</span> <span style="color: #87cefa;">strcpy</span>(<span style="color: #98fb98;">char</span> *<span style="color: #eedd82;">s</span>, <span style="color: #98fb98;">char</span> *<span style="color: #eedd82;">t</span>)
{
  <span style="color: #00ffff;">while</span> ((*s++ = *t++) != <span style="color: #ffa07a;">'\0'</span>)
    ;
}
</pre>
</div>

<p>
Esto traslada el incremento de <code>s</code> y de <code>t</code> hacia dentro de la
parte de prueba del ciclo. El valor de <code>*t++</code> es el caracter al que
apunta <code>t</code> antes de incrementarse; el <code>++</code> postfijo no modifica <code>t</code>
sino hasta despues de que se ha tomado el caracter. En la misma
forma, el caracter se almacena en la posicion anterior de <code>s</code> antes
de que se incremente. Tambien este caracter es el valor contra el
cual se compara '\0' para controlar el ciclo. El efecto real es que
los caracteres se copian de <code>t</code> a <code>s</code>, hasta el '\0' final,
incluyendolo.
</p>

<p>
Como resumen final, observe que una comparacion contra '\0' es
redundante, puesto que la pregunta es simplemente si la expresion
es cero. Asi, la funcion podria escribirse correctamente como
</p>

<div class="org-src-container">
<pre class="src src-c"><span style="color: #ff4500;">/* </span><span style="color: #ff4500;">strcpy: copia t hacia s; version tres con apuntadores </span><span style="color: #ff4500;">*/</span>
<span style="color: #98fb98;">void</span> <span style="color: #87cefa;">strcpy</span>(<span style="color: #98fb98;">char</span> *<span style="color: #eedd82;">s</span>, <span style="color: #98fb98;">char</span> *<span style="color: #eedd82;">t</span>)
{
  <span style="color: #00ffff;">while</span> (*s++ = *t++)
    ;
}
</pre>
</div>

<p>
Aunque esto puede parecer misterioso a primera vista, la
conveniencia de esta notacion es considerable, y debe dominarse el
estilo, puesto que se encontrara frecuentemente en programas de C.
</p>

<p>
En la biblioteca estandar (<code>&lt;string.h&gt;</code>) <code>strcpy</code>, devuelve la
cadena objetivo como el valor de la funcion.
</p>

<p>
La segunda rutina que examinaremos es <code>strcmp(s,t)</code>, que compara
las cadenas de caracteres <code>s</code> y <code>t</code>, y regresa un valor negativo,
cero o positivo si <code>s</code> es lexicograficamente menor que, igual a, o
mayor que <code>t</code>. El valor se obtiene al restar los caracteres de la
primera posicion en que <code>s</code> y <code>t</code> no coinciden.
</p>

<div class="org-src-container">
<pre class="src src-c"><span style="color: #ff4500;">/* </span><span style="color: #ff4500;">strcmp: regresa &lt;0 si s&lt;t, 0 si s == t, &gt;0 si s&gt;t </span><span style="color: #ff4500;">*/</span>
<span style="color: #98fb98;">int</span> <span style="color: #87cefa;">strcmp</span>(<span style="color: #98fb98;">char</span> *<span style="color: #eedd82;">s</span>, <span style="color: #98fb98;">char</span> *<span style="color: #eedd82;">t</span>)
{
  <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">i</span>;

  <span style="color: #00ffff;">for</span> (i = 0; s[i] == t[i]; i++)
    <span style="color: #00ffff;">if</span> (s[i] == <span style="color: #ffa07a;">'\0'</span>)
      <span style="color: #00ffff;">return</span> 0;
  <span style="color: #00ffff;">return</span> s[i] - t[i];
}
</pre>
</div>

<p>
version con apuntadores de <code>strcmp</code>:
</p>

<div class="org-src-container">
<pre class="src src-c"><span style="color: #ff4500;">/* </span><span style="color: #ff4500;">strcmp: regresa &lt;0 si s&lt;t, 0 si s == t, &gt;0 si s&gt;t </span><span style="color: #ff4500;">*/</span>
<span style="color: #98fb98;">int</span> <span style="color: #87cefa;">strcmp</span>(<span style="color: #98fb98;">char</span> *<span style="color: #eedd82;">s</span>, <span style="color: #98fb98;">char</span> *<span style="color: #eedd82;">t</span>)
{
  <span style="color: #00ffff;">for</span> ( ; *s == *t; s++, t++)
    <span style="color: #00ffff;">if</span> (*s == <span style="color: #ffa07a;">'\0'</span>)
      <span style="color: #00ffff;">return</span> 0;
  <span style="color: #00ffff;">return</span> *s - *t;
}
</pre>
</div>

<p>
Puesto que <code>++</code> y <code>--</code> son operadores prefijos o postfijos, se
presentan otras combinaciones de <code>*</code>, <code>++</code> y <code>--</code>, aunque con menos
frecuencia. Por ejemplo,
</p>

<div class="org-src-container">
<pre class="src src-c">*--p
</pre>
</div>

<p>
disminuye <code>p</code> antes de traer el caracter al que apunta. En efecto,
la pareja de expresiones
</p>

<div class="org-src-container">
<pre class="src src-c">*p++ = val; <span style="color: #ff4500;">/* </span><span style="color: #ff4500;">mete val en la pila                      </span><span style="color: #ff4500;">*/</span>
val = *--p; <span style="color: #ff4500;">/* </span><span style="color: #ff4500;">saca el tope de la pila y lo pone en val </span><span style="color: #ff4500;">*/</span>
</pre>
</div>

<p>
son expresiones idiomaticas estandar para meter y sacar algo de una
pila; vease la <a href="#org043af2c">seccion 4.3</a>.
</p>

<p>
El header <code>&lt;string.h&gt;</code> contiene declaraciones para las funciones
que se mencionan en esta seccion, ademas de una variedad de otras
funciones para manipulacion de cadenas en la biblioteca estandar.
</p>

<p>
<b>Ejercicio 5-3</b>. Escriba una version con apuntadores de la funcion
<code>strcat</code> que se muestra en el <a href="#org29d5b55">capitulo 2</a>: <code>strcat(s,t)</code> copia la
cadena <code>t</code> al final de <code>s</code>.
</p>

<p>
<b>Ejercicio 5-4</b>. Escriba la funcion <code>strend(s,t)</code>, que regresa <code>1</code>
si la cadena <code>t</code> se presenta al final de la cadena <code>s</code>, y cero si
no es asi.
</p>

<p>
<b>Ejercicio 5-5</b>. Escriba versiones de las funciones <code>strncpy</code>,
<code>strncat</code> y <code>strncmp</code> de la biblioteca <code>&lt;string.h&gt;</code>, que operan con
hasta los <code>n</code> primeros caracteres de sus argumentos de cadena. Por
ejemplo, <code>strncpy(s,t,n)</code> copia hasta n caracteres de <code>t</code> hacia
<code>s</code>. En el <a href="#org89d4232">apendice B</a> se exponen descripciones mas completas.
</p>

<p>
<b>Ejercicio 5-6</b>. Reescriba apropiadamente los programas y
ejercicios de los capitulos anteriores, empleando apuntadores en
lugar de indices de arreglos. Buenos prospectos son <code>getline</code>
(capitulos <a href="#orgc16243d">1</a> y <a href="#org05a38fc">4</a>), <code>atoi</code>, <code>itoa</code>, y sus variantes (capitulos <a href="#org29d5b55">2</a>, <a href="#org35eee87">3</a>
y <a href="#org05a38fc">4</a>), <code>reverse</code> (<a href="#org35eee87">capitulo 3</a>) y <code>strindex</code> y <code>getop</code> (<a href="#org05a38fc">capitulo 4</a>).
</p>
</div>
</div>

<div id="outline-container-org7ac205b" class="outline-3">
<h3 id="org7ac205b">5.6  Arreglos de apuntadores; apuntadores a apuntadores            <a id="org702cfb7"></a></h3>
<div class="outline-text-3" id="text-org7ac205b">
<p>
Puesto que en si mismos los apuntadores son variables, pueden
almacenarse en arreglos tal como otras variables. Ilustraremos esto
al escribir un programa que ordena un conjunto de lineas de texto
en orden alfabetico, que es una version restringida del programa
<code>sort</code> de UNIX.
</p>

<p>
En el <a href="#org35eee87">capitulo 3</a> se presento una funcion de ordenamiento Shell que
podia ordenar un arreglo de enteros, y en el <a href="#org05a38fc">capitulo 4</a> se mejoro
con un quicksort. El mismo algoritmo funcionara, excepto que ahora
se debe tratar con lineas de texto de diferentes longitudes, y que,
a diferencia de los enteros, no se pueden comparar ni cambiar en
una simple operacion. Se necesita una representacion de datos que
maneje eficiente y convenientemente lineas de texto.
</p>

<p>
Aqui es donde entran los arreglos de apuntadores. Si las lineas que
se van a ordenar se almacenan juntas en un gran arreglo de
caracteres, entonces se puede tener acceso a cada linea por medio
de un apuntador a su primer caracter. Por su lado, los apuntadores
se pueden almacenar en un arreglo. Dos lineas se pueden comparar
pasando sus apuntadores a <code>strcmp</code>. Cuando dos lineas desordenadas
tienen que intercambiarse, se intercambian los apuntadores en el
arreglo de apuntadores, no las lineas de texto.
</p>


<div class="figure">
<p><img src="img/img_05.06.png" alt="img_05.06.png" />
</p>
</div>

<p>
Esto elimina el doble problema de un manejo complicado de
almacenamiento y exceso de procesamiento que se produciria al mover
las lineas.
</p>

<p>
El proceso de ordenamiento tiene tres pasos:
</p>

<pre class="example">
lee todas las lineas de entrada
ordenalas
imprimelas en orden
</pre>

<p>
Como es usual, es mejor dividir el programa en funciones que
coincidan con esta division natural, con la rutina principal
controlando a las otras funciones. Abandonemos por un momento el
paso de ordenamiento, y concentremonos en las estructuras de datos
y la entrada y salida.
</p>

<p>
La rutina de entrada tiene que reunir y guardar los caracteres de
cada linea, y construir un arreglo de apuntadores hacia las
lineas. Tambien debe contar el numero de lineas de entrada, puesto
que esa informacion se requiere para el ordenamiento y la
impresion. Debido a que la funcion de entrada solo puede tratar con
un numero finito de lineas, puede regresar alguna cuenta de lineas
ilegal, como <code>-1</code>, si se presenta demasiado texto a la entrada.
</p>

<p>
La rutina de salida solo tiene que imprimir las lineas en el orden
en que aparecen en el arreglo de apuntadores.
</p>

<div class="org-src-container">
<pre class="src src-c"><span style="color: #b0c4de;">#include</span> <span style="color: #ffa07a;">&lt;stdio.h&gt;</span>
<span style="color: #b0c4de;">#include</span> <span style="color: #ffa07a;">&lt;string.h&gt;</span>

<span style="color: #b0c4de;">#define</span> <span style="color: #eedd82;">MAXLINES</span> 5000    <span style="color: #ff4500;">/* </span><span style="color: #ff4500;">max # de lineas por ordenar   </span><span style="color: #ff4500;">*/</span>

<span style="color: #98fb98;">char</span> *<span style="color: #eedd82;">lineptr</span>[MAXLINES]; <span style="color: #ff4500;">/* </span><span style="color: #ff4500;">apuntadores a lineas de texto </span><span style="color: #ff4500;">*/</span>

<span style="color: #98fb98;">int</span> <span style="color: #87cefa;">readlines</span>(<span style="color: #98fb98;">char</span> *<span style="color: #eedd82;">lineptr</span>[], <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">nlines</span>);
<span style="color: #98fb98;">void</span> <span style="color: #87cefa;">writelines</span>(<span style="color: #98fb98;">char</span> *<span style="color: #eedd82;">lineptr</span>[], <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">nlines</span>);

<span style="color: #98fb98;">void</span> <span style="color: #87cefa;">qsort</span>(<span style="color: #98fb98;">char</span> *<span style="color: #eedd82;">lineptr</span>[], <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">left</span>, <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">right</span>);

<span style="color: #ff4500;">/* </span><span style="color: #ff4500;">ordena lineas de entrada </span><span style="color: #ff4500;">*/</span>
<span style="color: #87cefa;">main</span>()
{
  <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">nlines</span>;            <span style="color: #ff4500;">/* </span><span style="color: #ff4500;">numero de lineas de entrada leidas </span><span style="color: #ff4500;">*/</span>

  <span style="color: #00ffff;">if</span> ((nlines = readlines(lineptr, MAXLINES)) &gt;= 0) {
    qsort(lineptr, 0, nlines-1);
    writelines(lineptr, nlines);
    <span style="color: #00ffff;">return</span> 0;
  } <span style="color: #00ffff;">else</span> {
    printf(<span style="color: #ffa07a;">"error: entrada demasiado grande para ordenarla\n"</span>);
    <span style="color: #00ffff;">return</span> 1;
  }
}

<span style="color: #b0c4de;">#define</span> <span style="color: #eedd82;">MAXLEN</span> 1000      <span style="color: #ff4500;">/* </span><span style="color: #ff4500;">max longitud de cualquier linea de entrada </span><span style="color: #ff4500;">*/</span>
<span style="color: #98fb98;">int</span> <span style="color: #87cefa;">getline</span>(<span style="color: #98fb98;">char</span> *, <span style="color: #98fb98;">int</span>);
<span style="color: #98fb98;">char</span> *<span style="color: #87cefa;">alloc</span>(<span style="color: #98fb98;">int</span>);

<span style="color: #ff4500;">/* </span><span style="color: #ff4500;">readlines: lee lineas de entrada </span><span style="color: #ff4500;">*/</span>
<span style="color: #98fb98;">int</span> <span style="color: #87cefa;">readlines</span>(<span style="color: #98fb98;">char</span> *<span style="color: #eedd82;">lineptr</span>[], <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">maxlines</span>)
{
  <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">len</span>, <span style="color: #eedd82;">nlines</span>;
  <span style="color: #98fb98;">char</span> *<span style="color: #eedd82;">p</span>, <span style="color: #eedd82;">line</span>[MAXLEN];

  nlines = 0;
  <span style="color: #00ffff;">while</span> ((len = getline(line, MAXLEN)) &gt; 0)
    <span style="color: #00ffff;">if</span> (nlines &gt;= maxlines || (p = alloc(len)) == <span style="color: #7fffd4;">NULL</span>)
      <span style="color: #00ffff;">return</span> -1;
    <span style="color: #00ffff;">else</span> {
      line[len-1] = <span style="color: #ffa07a;">'\0'</span>; <span style="color: #ff4500;">/* </span><span style="color: #ff4500;">elimina caracter nueva linea </span><span style="color: #ff4500;">*/</span>
      strcpy(p, line);
      lineptr[nlines++] = p;
    }
  <span style="color: #00ffff;">return</span> nlines;
}

<span style="color: #ff4500;">/* </span><span style="color: #ff4500;">writelines: escribe lineas de salida </span><span style="color: #ff4500;">*/</span>
<span style="color: #98fb98;">void</span> <span style="color: #87cefa;">writelines</span>(<span style="color: #98fb98;">char</span> *<span style="color: #eedd82;">lineptr</span>[], <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">nlines</span>)
{
  <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">i</span>;
  <span style="color: #00ffff;">for</span> (i = 0; i &lt; nlines; i++)
    printf(<span style="color: #ffa07a;">"%s\n"</span>, lineptr[i]);
}
</pre>
</div>

<p>
La funcion <code>getline</code> se trato en la <a href="#org6357bb7">seccion 1.9</a>.
</p>

<p>
El principal elemento nuevo es la declaracion para <code>lineptr</code>:
</p>

<div class="org-src-container">
<pre class="src src-c"><span style="color: #98fb98;">char</span> *<span style="color: #eedd82;">lineptr</span>[MAXLINES]
</pre>
</div>

<p>
que indica que <code>lineptr</code> es un arreglo de <code>MAXLINES</code> elementos,
cada uno de los cuales es un apuntador a <code>char</code>. Esto es,
<code>lineptr[i]</code> es un apuntador a caracter, y <code>*lineptr[i]</code> es el
caracter al que apunta, el primer caracter de la i-esima linea de
texto almacenada.
</p>

<p>
Puesto que <code>lineptr</code> es por si mismo el nombre de un arreglo, puede
tratarse como un apuntador en la misma forma que en nuestros
ejemplos anteriores, y <code>writelines</code> puede escribirse en su lugar
como
</p>

<div class="org-src-container">
<pre class="src src-c"><span style="color: #ff4500;">/* </span><span style="color: #ff4500;">writelines: escribe lineas de salida </span><span style="color: #ff4500;">*/</span>
<span style="color: #98fb98;">void</span> <span style="color: #87cefa;">writelines</span>(<span style="color: #98fb98;">char</span> *<span style="color: #eedd82;">lineptr</span>[], <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">nlines</span>)
{
  <span style="color: #00ffff;">while</span> (nlines-- &gt; 0)
    printf(<span style="color: #ffa07a;">"%s\n"</span>, *lineptr++);
}
</pre>
</div>

<p>
Inicialmente <code>*lineptr</code> apunta a la primera linea; cada incremento
lo avanza al siguiente apuntador a linea mientras <code>nlines</code> se
disminuye.
</p>

<p>
Teniendo la entrada y la salida bajo control, podemos proceder a
ordenar. El quicksort del <a href="#org05a38fc">capitulo 4</a> necesita solo cambios de poca
importancia: las declaraciones deben modificarse, y la operacion de
comparacion debe hacerse llamando a <code>strcmp</code>. El algoritmo
permanece igual, lo que nos da cierta confianza de que aun
trabajara.
</p>



<div class="org-src-container">
<pre class="src src-c"><span style="color: #ff4500;">/* </span><span style="color: #ff4500;">qsort: ordena v[left]...v[right] en orden ascendente </span><span style="color: #ff4500;">*/</span>
<span style="color: #98fb98;">void</span> <span style="color: #87cefa;">qsort</span>(<span style="color: #98fb98;">char</span> *<span style="color: #eedd82;">v</span>[], <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">left</span>, <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">right</span>)
{
  <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">i</span>, <span style="color: #eedd82;">last</span>;
  <span style="color: #98fb98;">void</span> <span style="color: #87cefa;">swap</span>(<span style="color: #98fb98;">char</span> *<span style="color: #eedd82;">v</span>[], <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">i</span>, <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">j</span>);

  <span style="color: #00ffff;">if</span> (left &gt;= right) <span style="color: #ff4500;">/* </span><span style="color: #ff4500;">no hace nada si el arreglo contiene </span><span style="color: #ff4500;">*/</span>
    <span style="color: #00ffff;">return</span>;          <span style="color: #ff4500;">/* </span><span style="color: #ff4500;">menos de dos elementos              </span><span style="color: #ff4500;">*/</span>
  swap(v, left, (left + right)/2);
  last = left;

  <span style="color: #00ffff;">for</span> (i = left+1; i &lt;= right; i++)
    <span style="color: #00ffff;">if</span> (strcmp(v[i], v[left]) &lt; 0)
      swap(v, ++last, i);
  swap(v, left, last);
  qsort(v, left, last-1);
  qsort(v, last+1, right);
}
</pre>
</div>

<p>
De manera semejante, la rutina de intercambio solo requiere
modificaciones poco significativas:
</p>

<div class="org-src-container">
<pre class="src src-c"><span style="color: #ff4500;">/* </span><span style="color: #ff4500;">swap: intercambia v[i] y v[j] </span><span style="color: #ff4500;">*/</span>
<span style="color: #98fb98;">void</span> <span style="color: #87cefa;">swap</span>(<span style="color: #98fb98;">char</span> *<span style="color: #eedd82;">v</span>[], <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">i</span>, <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">j</span>)
{
  <span style="color: #98fb98;">char</span> *<span style="color: #eedd82;">temp</span>;

  temp = v[i];
  v[i] = v[j];
  v[j] = temp;
}
</pre>
</div>

<p>
Puesto que cualquier elemento individual de <code>v</code> (alias <code>lineptr</code>)
es un apuntador a caracter, <code>temp</code> tambien debe serlo, de modo que
uno pueda copiarse al otro.
</p>

<p>
<b>Ejercicio 5-7</b>. Reescriba <code>readlines</code> para almacenar lineas en un
arreglo proporcionado por <code>main</code>, en lugar de llamar a <code>alloc</code> para
obtener espacio de almacenamiento. ¿Cuanto mas rapido es el
programa?
</p>
</div>
</div>

<div id="outline-container-org8f7af81" class="outline-3">
<h3 id="org8f7af81">5.7  Arreglos multidimensionales                                   <a id="org6f9397d"></a></h3>
<div class="outline-text-3" id="text-org8f7af81">
<p>
El lenguaje C proporciona arreglos multidimensionales
rectangulares, aunque en la practica se usan menos que los arreglos
de apuntadores. En esta seccion mostraremos algunas de sus
propiedades.
</p>

<p>
Considerese el problema de la conversion de fechas, de dia del mes
a dia del año y viceversa. Por ejemplo, el 1 de marzo es el 60° dia
de un año que no es bisiesto, y el 61° dia de uno que si lo
es. Definamos dos funciones para hacer la conversion: <code>day_of_year</code>
convierte mes y dia en el dia del año, y <code>month_day</code> convierte el
dia del año en mes y dia. Puesto que esta ultima funcion calcula
dos valores, los argumentos de mes y dia deben ser apuntadores:
</p>

<div class="org-src-container">
<pre class="src src-c">month_day(1988, 60, &amp;m, &amp;d)
</pre>
</div>

<p>
hace <code>m</code> igual a <code>2</code> y <code>d</code> igual a <code>29</code> (29 de febrero).
</p>

<p>
Ambas funciones necesitan la misma informacion, una tabla de los
numeros de dias de cada mes ("treinta dias tiene septiembre
&#x2026;"). Puesto que el numero de dias por mes difiere para años
bisiestos y no bisiestos, es mas facil separarlos en dos renglones
de un arreglo bidimensional que siga la pista de lo que le pasa a
febrero durante los calculos. El arreglo y las funciones que
realizan las transformaciones son como se muestra a continuacion:
</p>

<div class="org-src-container">
<pre class="src src-c"><span style="color: #00ffff;">static</span> <span style="color: #98fb98;">char</span> <span style="color: #eedd82;">daytab</span>[2][13] = {
  {0, 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31},
  {0, 31, 29, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31},
};

<span style="color: #ff4500;">/* </span><span style="color: #ff4500;">day_of_year: obtiene dia del a&#241;o a partir de mes y dia </span><span style="color: #ff4500;">*/</span>
<span style="color: #98fb98;">int</span> <span style="color: #87cefa;">day_of_year</span>(<span style="color: #98fb98;">int</span> <span style="color: #eedd82;">year</span>, <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">month</span>, <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">day</span>)
{
  <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">i</span>, <span style="color: #eedd82;">leap</span>;
  leap = year%4 == 0 &amp;&amp; year%100 != 0 || year%400 == 0;
  <span style="color: #00ffff;">for</span> (i = 1; i &lt; month; i++)
    day += daytab[leap][i];
  <span style="color: #00ffff;">return</span> day;
}

<span style="color: #ff4500;">/* </span><span style="color: #ff4500;">month_day: obtiene mes, y dia a partir de dia del a&#241;o </span><span style="color: #ff4500;">*/</span>
<span style="color: #98fb98;">void</span> <span style="color: #87cefa;">month_day</span>(<span style="color: #98fb98;">int</span> <span style="color: #eedd82;">year</span>, <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">yearday</span>, <span style="color: #98fb98;">int</span> *<span style="color: #eedd82;">pmonth</span>, <span style="color: #98fb98;">int</span> *<span style="color: #eedd82;">pday</span>)
{
  <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">i</span>, <span style="color: #eedd82;">leap</span>;
  leap = year%4 == 0 &amp;&amp; year%100 != 0 || year%400 == 0;
  <span style="color: #00ffff;">for</span> (i = 1; yearday &gt; daytab[leap][i]; i++)
    yearday -= daytab[leap][i];
  *pmonth = i;
  *pday = yearday;
}
</pre>
</div>

<p>
Recuerdese que el valor aritmetico de una expresion logica, como la
de <code>leap</code>, es cero (falso) o uno (verdadero), asi que puede
emplearse como indice del arreglo <code>daytab</code>.
</p>

<p>
El arreglo <code>daytab</code> tiene que ser externo tanto a <code>day_of_year</code>
como a <code>month_day</code>, para que ambas puedan utilizarlo. Lo hicimos
<code>char</code> para ilustrar un uso legitimo de char para almacenar enteros
pequeños que no son caracteres.
</p>

<p>
<code>daytab</code> es el primer arreglo de caracteres de dos dimensiones con
el que hemos tratado. En C, un arreglo de dos dimensiones es en
realidad un arreglo unidimensional, cada uno de cuyos elementos es
un arreglo. Por ello, los subindices se escriben como
</p>

<div class="org-src-container">
<pre class="src src-c"><span style="color: #98fb98;">daytab</span>[i][j] <span style="color: #ff4500;">/* </span><span style="color: #ff4500;">[renglon] [columna] </span><span style="color: #ff4500;">*/</span>
</pre>
</div>

<p>
en lugar de
</p>

<div class="org-src-container">
<pre class="src src-c"><span style="color: #98fb98;">daytab</span> [i,j] <span style="color: #ff4500;">/* </span><span style="color: #ff4500;">INCORRECTO </span><span style="color: #ff4500;">*/</span>
</pre>
</div>

<p>
Aparte de esta diferencia de notacion, un arreglo de dos
dimensiones puede tratarse en forma muy semejante a la de los otros
lenguajes. Los elementos se almacenan por renglones, asi que el
indice de mas a la derecha, o columna, varia mas rapido cuando se
tiene acceso a los elementos en orden de almacenamiento.
</p>

<p>
Un arreglo se inicializa con una lista de inicializadores entre
llaves; cada renglon de un arreglo de dos dimensiones se inicializa
con una sublista. El arreglo <code>daytab</code> se inicia con una columna de
ceros, de modo que los numeros de mes puedan variar entre <code>1</code> y
<code>12</code> en lugar de <code>0</code> a <code>11</code>. Puesto que el espacio no es apremiante
aqui, esto es mas claro que ajustar los indices.
</p>

<p>
Si un arreglo de dos dimensiones se pasa a una funcion, la
declaracion de parametros en la funcion debe incluir el numero de
columnas; el numero de renglones es irrelevante, puesto que lo que
se pasa es, como antes, un apuntador a un arreglo de renglones,
donde cada renglon es un arreglo de 13 ints. Es este caso
particular, es un apuntador a objetos que son arreglos de 13
ints. Entonces, si el arreglo <code>daytab</code> se pasara a la funcion <code>f</code>,
la declaracion de <code>f</code> seria:
</p>

<div class="org-src-container">
<pre class="src src-c"><span style="color: #87cefa;">f</span>(<span style="color: #98fb98;">int</span> <span style="color: #eedd82;">daytab</span>[2][13]) { ... }
</pre>
</div>

<p>
Tambien podria ser
</p>

<div class="org-src-container">
<pre class="src src-c"><span style="color: #87cefa;">f</span>(<span style="color: #98fb98;">int</span> <span style="color: #eedd82;">daytab</span>[][13]) { ... }
</pre>
</div>

<p>
porque el numero de renglones es irrelevante, o podria ser
</p>

<div class="org-src-container">
<pre class="src src-c"><span style="color: #87cefa;">f</span>(<span style="color: #98fb98;">int</span> (*<span style="color: #eedd82;">daytab</span>)[13]){ ... }
</pre>
</div>

<p>
que indica que el parametro es un apuntador a un arreglo de 13
enteros. Los parentesis son necesarios, puesto que los corchetes
<code>[]</code> tienen mas alta precedencia que <code>*</code>. Sin parentesis, la
declaracion
</p>

<div class="org-src-container">
<pre class="src src-c"><span style="color: #98fb98;">int</span> *<span style="color: #eedd82;">daytab</span>[13]
</pre>
</div>

<p>
es un arreglo de 13 apuntadores a entero. De modo mas general, solo
la primera dimension (subindice) de un arreglo queda abierta; todas
las otras deben especificarse.
</p>

<p>
En la <a href="#orgbbd6ebe">seccion 5.12</a> se discute mas acerca de declaraciones
complicadas.
</p>

<p>
<b>Ejercicio 5-8</b>. No existe deteccion de errores en <code>day_of_year</code> ni
en <code>month_day</code>. Solucione ese defecto.
</p>
</div>
</div>

<div id="outline-container-org5346f97" class="outline-3">
<h3 id="org5346f97">5.8  Inicializacion de arreglos de apuntadores                     <a id="org70f206b"></a></h3>
<div class="outline-text-3" id="text-org5346f97">
<p>
Considerese el problema de escribir una funcion <code>month_name(n)</code>,
que regrese un apuntador a una cadena de caracteres que contengan
el nombre del n-esimo mes. Esta es una aplicacion ideal para un
arreglo <code>static</code> interno, <code>month_name</code> contiene un arreglo
reservado de cadenas de caracteres, y regresa un apuntador a la
cadena apropiada cuando se llama. Esta seccion muestra como se
inicializa ese arreglo de nombres.
</p>

<p>
La sintaxis es semejante a la de inicializaciones previas:
</p>

<div class="org-src-container">
<pre class="src src-c"><span style="color: #ff4500;">/* </span><span style="color: #ff4500;">month_name: regresa el nombre del n-esimo mes </span><span style="color: #ff4500;">*/</span>
<span style="color: #98fb98;">char</span> *<span style="color: #87cefa;">month_name</span>(<span style="color: #98fb98;">int</span> <span style="color: #eedd82;">n</span>)
{
  <span style="color: #00ffff;">static</span> <span style="color: #98fb98;">char</span> *<span style="color: #eedd82;">name</span>[] = {
    <span style="color: #ffa07a;">"Mes ilegal"</span>,
    <span style="color: #ffa07a;">"Enero"</span>, <span style="color: #ffa07a;">"Febrero"</span>, <span style="color: #ffa07a;">"Marzo"</span>,
    <span style="color: #ffa07a;">"Abril"</span>, <span style="color: #ffa07a;">"Mayo"</span>, <span style="color: #ffa07a;">"Junio"</span>,
    <span style="color: #ffa07a;">"Julio"</span>, <span style="color: #ffa07a;">"Agosto"</span>, <span style="color: #ffa07a;">"Septiembre"</span>,
    <span style="color: #ffa07a;">"Octubre"</span>, <span style="color: #ffa07a;">"Noviembre"</span>, <span style="color: #ffa07a;">"Diciembre"</span>
  };

  <span style="color: #00ffff;">return</span> (n &lt; 1 || n &gt; 12 ) ? name[0]; name[n];
}
</pre>
</div>

<p>
La declaracion de <code>name</code>, que es un arreglo de apuntadores a
caracteres, es la misma que la de <code>lineptr</code> en el ejemplo del
ordenamiento. El inicializador es una lista de cadenas de
caracteres; cada una se asigna a la posicion correspondiente dentro
del arreglo. Los caracteres de la i-esima cadena se colocan en
algun lugar, y en <code>name[i]</code> se almacena un apuntador a
ellos. Puesto que el tamaño del arreglo <code>name</code> no esta
especificado, el compilador cuenta los inicializadores y completa
el numero correcto.
</p>
</div>
</div>

<div id="outline-container-org31a281b" class="outline-3">
<h3 id="org31a281b">5.9  Apuntadores vs. arreglos multidimensionales                   <a id="org7d9670e"></a></h3>
<div class="outline-text-3" id="text-org31a281b">
<p>
Los nuevos usuarios de C algunas veces se confunden con la
diferencia entre un arreglo de dos dimensiones y uno de
apuntadores, como <code>name</code> en el ejemplo anterior. Dadas las
definiciones
</p>

<div class="org-src-container">
<pre class="src src-c"><span style="color: #98fb98;">int</span> <span style="color: #eedd82;">a</span>[10][20];
<span style="color: #98fb98;">int</span> *<span style="color: #eedd82;">b</span>[10];
</pre>
</div>

<p>
entonces tanto <code>a[3][4]</code> como <code>b[3][4]</code> son referencias
sintacticamente legitimas a un unico <code>int</code>. Pero <code>a</code> es
verdaderamente un arreglo de dos dimensiones: se le han asignado
<code>200</code> localidades de tamaño de un <code>int</code>, y se emplea el calculo
convencional de subindices rectangulares <code>20 * renglon + columna</code>
para encontrar elemento <code>a[renglon,columna]</code>. Para <code>b</code>, sin
embargo, la definicion solo asigna 10 apuntadores y no los
inicializa; la inicializacion debe realizarse en forma explicita,
ya sea estaticamente o con codigo. Suponiendo que cada elemento de
<code>b</code> apunta a un arreglo de veinte elementos, entonces existiran
<code>200</code> ints reservados, mas diez celdas para los apuntadores. La
ventaja importante del arreglo de apuntadores es que los renglones
del arreglo pueden ser de longitudes diferentes. Esto es, no es
necesario que cada elemento de <code>b</code> apunte a un vector de veinte
elementos; alguno puede apuntar a dos elementos, otro a cincuenta y
algun otro a ninguno.
</p>

<p>
Aunque hemos basado esta discusion en terminos de enteros, el uso
mas frecuente de arreglos de apuntadores es para almacenar cadenas
de caracteres de longitudes diversas, como en la funcion
<code>month_name</code>. Compare la declaracion y la grafica para un arreglo
de apuntadores:
</p>

<div class="org-src-container">
<pre class="src src-c"><span style="color: #98fb98;">char</span> *<span style="color: #eedd82;">name</span>[] = { <span style="color: #ffa07a;">"Mes ilegal"</span>, <span style="color: #ffa07a;">"Ene"</span>, <span style="color: #ffa07a;">"Feb"</span>, <span style="color: #ffa07a;">"Mar"</span> };
</pre>
</div>


<div class="figure">
<p><img src="img/img_05.09.01.png" alt="img_05.09.01.png" />
</p>
</div>

<p>
con la de un arreglo bidimensional:
</p>

<div class="org-src-container">
<pre class="src src-c"><span style="color: #98fb98;">char</span> <span style="color: #eedd82;">aname</span>[][15] = { <span style="color: #ffa07a;">"Mes ilegal"</span>, <span style="color: #ffa07a;">"Ene"</span>, <span style="color: #ffa07a;">"Feb"</span>, <span style="color: #ffa07a;">"Mar"</span> };
</pre>
</div>


<div class="figure">
<p><img src="img/img_05.09.02.png" alt="img_05.09.02.png" />
</p>
</div>

<p>
<b>Ejercicio 5-9</b>. Reescriba las rutinas <code>day_of_year</code> y <code>month_day</code>
empleando apuntadores en lugar de indices.
</p>
</div>
</div>

<div id="outline-container-org140c9c2" class="outline-3">
<h3 id="org140c9c2">5.10 Argumentos en la linea de ordenes                             <a id="orgc94d8d8"></a></h3>
<div class="outline-text-3" id="text-org140c9c2">
<p>
Dentro de un medio ambiente que maneje C hay una forma de pasar
argumentos o parametros en la linea de ordenes a un programa cuando
empieza su ejecucion. Cuando se llama a <code>main</code> se le invoca con dos
argumentos. El primero (llamado por convencion <code>argc</code>, por
<i>argument count</i>) es el numero de argumentos en la linea de ordenes
con los que se invoco el programa; el segundo (<code>argv</code>,por <i>argument
vector</i>) es un apuntador a un arreglo de cadenas de caracteres que
contiene los argumentos, uno por cadena. Se acostumbra utilizar
niveles multiples de apuntadores para manipular esas cadenas de
caracteres.
</p>

<p>
El ejemplo mas sencillo es el programa <code>echo</code>, que despliega sus
argumentos de la linea de ordenes en una linea, separados por
blancos. Esto es, la orden
</p>

<div class="org-src-container">
<pre class="src src-sh"><span style="color: #b0c4de;">echo</span> hola, mundo
</pre>
</div>

<p>
imprime
</p>

<div class="org-src-container">
<pre class="src src-sh">hola, mundo
</pre>
</div>

<p>
Por convencion, <code>argv[0]</code> es el nombre con el que se invoco el
programa, por lo que <code>argc</code> es por lo menos <code>1</code>. Si <code>argc</code> es <code>1</code>,
entonces no hay argumentos en la linea despues del nombre del
programa. En el ejemplo anterior, <code>argc</code> es <code>3</code>, y <code>argv[0]</code>,
<code>argv[1]</code> y <code>argv[2]</code> son "echo", "hola," y "mundo",
respectivamente. El primer argumento optativo es <code>argv[1]</code> y el
ultimo es <code>argv[argc - 1]</code>; ademas, el estandar requiere que
<code>argv[argc]</code> sea un apuntador nulo.
</p>


<div class="figure">
<p><img src="img/img_05.10.png" alt="img_05.10.png" />
</p>
</div>

<p>
La primera version de <code>echo</code> trata a <code>argv</code> como un arreglo de
apuntadores a caracteres:
</p>

<div class="org-src-container">
<pre class="src src-c"><span style="color: #b0c4de;">#include</span> <span style="color: #ffa07a;">&lt;stdio.h&gt;</span>

<span style="color: #ff4500;">/* </span><span style="color: #ff4500;">eco de los argumentos de la linea de ordenes; 1a. version </span><span style="color: #ff4500;">*/</span>
<span style="color: #87cefa;">main</span>(<span style="color: #98fb98;">int</span> <span style="color: #eedd82;">argc</span>, <span style="color: #98fb98;">char</span> *<span style="color: #eedd82;">argv</span>[])
{
  <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">i</span>;

  <span style="color: #00ffff;">for</span> (i = 1; i &lt; argc; i++)
    printf(<span style="color: #ffa07a;">"%s%s"</span>, argv[i], (i &lt; argc-1) ? <span style="color: #ffa07a;">" "</span> : <span style="color: #ffa07a;">""</span>);
  printf(<span style="color: #ffa07a;">"\n"</span>);
  <span style="color: #00ffff;">return</span> 0;
}
</pre>
</div>

<p>
Como <code>argv</code> es un apuntador a un arreglo de apuntadores, se pueden
manipular al apuntador en lugar de indexar al arreglo. Esta
siguiente variacion se basa en incrementar <code>argv</code>, que es un
apuntador a un apuntador a <code>char</code>, en tanto se disminuye <code>argc</code>:
</p>

<div class="org-src-container">
<pre class="src src-c"><span style="color: #b0c4de;">#include</span> <span style="color: #ffa07a;">&lt;stdio.h&gt;</span>

<span style="color: #ff4500;">/* </span><span style="color: #ff4500;">eco de los argumentos de la linea de ordenes; 2a. version </span><span style="color: #ff4500;">*/</span>
<span style="color: #87cefa;">main</span>(<span style="color: #98fb98;">int</span> <span style="color: #eedd82;">argc</span>, <span style="color: #98fb98;">char</span> *<span style="color: #eedd82;">argv</span>[])
{
  <span style="color: #00ffff;">while</span> (--argc &gt; 0)
    printf(<span style="color: #ffa07a;">"%s%s"</span>, *++argv, (argc &gt; 1) ? <span style="color: #ffa07a;">" "</span> : <span style="color: #ffa07a;">""</span>);
  printf(<span style="color: #ffa07a;">"\n"</span>);
  <span style="color: #00ffff;">return</span> 0;
}
</pre>
</div>

<p>
Puesto que <code>argv</code> es un apuntador al inicio del arreglo de cadenas
de argumentos, incrementarlo en 1 (<code>++argv</code>) lo hace apuntar hacia
<code>argv[1]</code> en lugar de apuntar a <code>argv[0]</code>. Cada incremento sucesivo
lo mueve al siguiente argumento; entonces <code>*argv</code> es el apuntador a
ese argumento. Al mismo tiempo, <code>argc</code> disminuye; cuando llega a
cero, no quedan argumentos por imprimir.
</p>

<p>
En forma alternativa, podemos escribir la proposicion <a href="#org0458a76"><code>printf</code></a> como
</p>

<div class="org-src-container">
<pre class="src src-c">printf((argc &gt; 1) ? <span style="color: #ffa07a;">"%s "</span> : <span style="color: #ffa07a;">"%s"</span>, *++argv);
</pre>
</div>

<p>
Esto demuestra que el argumento de formato del <a href="#org0458a76"><code>printf</code></a> tambien
puede ser ser una expresion.
</p>

<p>
Como un segundo ejemplo, hagamos algunas mejoras al programa de la
<a href="#org4bf01e4">seccion 4.1</a> que encuentra un patron. Si se recuerda, se fijo el
patron de busqueda en lo profundo del programa, un esquema que
obviamente no es satisfactorio. Siguiendo la guia del programa
<code>grep</code> de UNIX, cambiemos el programa de modo que el patron que se
debe encontrar se especifique por el primer argumento en la linea
de ordenes.
</p>

<div class="org-src-container">
<pre class="src src-c"><span style="color: #b0c4de;">#include</span> <span style="color: #ffa07a;">&lt;stdio.h&gt;</span>
<span style="color: #b0c4de;">#include</span> <span style="color: #ffa07a;">&lt;string.h&gt;</span>
<span style="color: #b0c4de;">#define</span> <span style="color: #eedd82;">MAXLINE</span> 1000

<span style="color: #98fb98;">int</span> <span style="color: #87cefa;">getline</span>(<span style="color: #98fb98;">char</span> *<span style="color: #eedd82;">line</span>, <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">max</span>);

<span style="color: #ff4500;">/* </span><span style="color: #ff4500;">find: imprime lineas que coinciden con el patron del 1er. argumento </span><span style="color: #ff4500;">*/</span>
<span style="color: #87cefa;">main</span>(<span style="color: #98fb98;">int</span> <span style="color: #eedd82;">argc</span>, <span style="color: #98fb98;">char</span> *<span style="color: #eedd82;">argv</span>[])
{
  <span style="color: #98fb98;">char</span> <span style="color: #eedd82;">line</span>[MAXLINE];
  <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">found</span> = 0;

  <span style="color: #00ffff;">if</span> (argc != 2)
    printf(<span style="color: #ffa07a;">"Usage: find pattern\n"</span>);
  <span style="color: #00ffff;">else</span>
    <span style="color: #00ffff;">while</span> (getline(line, MAXLINE) &gt; 0)
      <span style="color: #00ffff;">if</span> (strstr(line, argv[1]) != <span style="color: #7fffd4;">NULL</span>) {
        printf(<span style="color: #ffa07a;">"%s"</span>, line);
        found++;
      }
  <span style="color: #00ffff;">return</span> found;
}
</pre>
</div>

<p>
La funcion <code>strstr(s,t)</code> de la biblioteca estandar regresa un
apuntador a la primera ocurrencia de la cadena <code>t</code> dentro de la
cadena <code>s</code>, o <code>NULL</code> si no existe. La funcion esta declarada en
<code>&lt;string.h&gt;</code>.
</p>

<p>
Ahora se puede extender el modelo para ilustrar construcciones
adicionales de apuntadores. Suponga que deseamos permitir dos
argumentos optativos. Uno indica "imprime todas las lineas
<i>excepto</i> aquellas que coincidan con el patron"; el segundo dice
"precede cada linea impresa con su numero de linea".
</p>

<p>
Una convencion comun para programas en C en sistemas UNIX es que un
argumento que inicia con un signo de menos introduce una bandera o
parametro optativo. Si seleccionamos <code>-x</code> (por "excepto") para
indicar la inversion, y <code>-n</code> ("numero") para solicitar la
numeracion de lineas, entonces la orden
</p>

<div class="org-src-container">
<pre class="src src-sh">find -x -n patron
</pre>
</div>

<p>
imprimira cada linea que no coincida con el patron, precedida por
su numero de linea.
</p>

<p>
Los argumentos para opciones deben ser permitidos en cualquier
orden, y el resto del programa debe ser independiente del numero de
argumentos que estuvieran presentes. Ademas, es conveniente para
los usuarios que los argumentos de las opciones puedan combinarse,
como en
</p>

<div class="org-src-container">
<pre class="src src-sh">find -nx patron
</pre>
</div>

<p>
Aqui esta el programa:
</p>

<div class="org-src-container">
<pre class="src src-c"><span style="color: #b0c4de;">#include</span> <span style="color: #ffa07a;">&lt;stdio.h&gt;</span>
<span style="color: #b0c4de;">#include</span> <span style="color: #ffa07a;">&lt;string.h&gt;</span>
<span style="color: #b0c4de;">#define</span> <span style="color: #eedd82;">MAXLINE</span> 1000

<span style="color: #98fb98;">int</span> <span style="color: #87cefa;">getline</span>(<span style="color: #98fb98;">char</span> *<span style="color: #eedd82;">line</span>, <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">max</span>);

<span style="color: #ff4500;">/* </span><span style="color: #ff4500;">find: imprime lineas que coinciden con el patron del 1er. argumento </span><span style="color: #ff4500;">*/</span>
<span style="color: #87cefa;">main</span>(<span style="color: #98fb98;">int</span> <span style="color: #eedd82;">argc</span>, <span style="color: #98fb98;">char</span> *<span style="color: #eedd82;">argv</span>[])
{
  <span style="color: #98fb98;">char</span> <span style="color: #eedd82;">line</span>[MAXLINE];
  <span style="color: #98fb98;">long</span> <span style="color: #eedd82;">lineno</span> = 0;
  <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">c</span>, <span style="color: #eedd82;">except</span> = 0, <span style="color: #eedd82;">number</span> = 0, <span style="color: #eedd82;">found</span> = 0;

  <span style="color: #00ffff;">while</span> (--argc &gt; 0 &amp;&amp; (*++argv)[0] == <span style="color: #ffa07a;">'-'</span>)
    <span style="color: #00ffff;">while</span> (c = *++argv[0])
      <span style="color: #00ffff;">switch</span> (c) {
      <span style="color: #00ffff;">case</span> <span style="color: #ffa07a;">'x'</span>:
        except = 1;
        <span style="color: #00ffff;">break</span>;
      <span style="color: #00ffff;">case</span> <span style="color: #ffa07a;">'n'</span>:
        number = 1;
        <span style="color: #00ffff;">break</span>;
      <span style="color: #00ffff;">default</span>:
        printf(<span style="color: #ffa07a;">"find: illegal option %c\n"</span>, c);
        argc = 0;
        found = -1;
        <span style="color: #00ffff;">break</span>;
      }
  <span style="color: #00ffff;">if</span> (argc != 1)
    printf(<span style="color: #ffa07a;">"Usage: find -x -n pattern\n"</span>);
  <span style="color: #00ffff;">else</span>
    <span style="color: #00ffff;">while</span> (getline(line, MAXLINE) &gt; 0) {
      lineno++;
      <span style="color: #00ffff;">if</span> ((strstr(line, *argv) != <span style="color: #7fffd4;">NULL</span>) != except) {
        <span style="color: #00ffff;">if</span> (number)
          printf(<span style="color: #ffa07a;">"%ld:"</span>, lineno);
        printf(<span style="color: #ffa07a;">"%s"</span>, line);
        found++;
      }
    }
  <span style="color: #00ffff;">return</span> found;
}
</pre>
</div>

<p>
<code>argc</code> se disminuye y <code>argv</code> se incrementa antes de cada argumento
opcional. Al final del ciclo, si no hay errores, <code>argc</code> dice
cuantos argumentos permanecen sin procesar y <code>argv</code> apunta al
primero de estos. Asi, <code>argc</code> debe ser <code>1</code> y <code>*argv</code> debe apuntar
al patron. Notese que <code>*++argv</code> es un apuntador a un argumento tipo
cadena, asi que <code>(*++argv)[0]</code> es su primer caracter. (Una forma
alternativa valida seria <code>**++argv</code>.) Debido a que <code>[]</code> tiene mas
prioridad que <code>*</code> y que <code>++</code>, los parentesis son necesarios; sin
ellos, la expresion seria tomada como <code>*++(argv[0])</code>.  En efecto,
esto es lo que empleamos en el ciclo mas interno, donde la tarea es
proceder a lo largo de una cadena especifica de argumentos. En el
ciclo mas interno, la expresion <code>*++argv[0]</code> incrementa el
apuntador <code>argv[0]</code>
</p>

<p>
Es raro que se empleen expresiones con apuntadores mas complicadas
que estas; en tal caso, sera mas intuitivo separarlas en dos o tres
pasos.
</p>

<p>
<b>Ejercicio 5-10</b>. Escriba el programa <code>expr</code>, que evalua una
expresion polaca inversa de la linea de ordenes, donde cada
operador u operando es un argumento por separado. Por ejemplo,
</p>

<div class="org-src-container">
<pre class="src src-c">expr 2 3 4 + *
</pre>
</div>

<p>
se evalua como 2 x (3 + 4).
</p>

<p>
<b>Ejercicio 5-11</b>. Modifique el programa <code>entab</code> y <code>detab</code> (escritos
como ejercicios en el <a href="#orgc16243d">capitulo 1</a>) para que acepten una lista de
puntos de tabulacion como argumentos. Utilice los tabuladores
habituales si no hay argumentos.
</p>

<p>
<b>Ejercicio 5-12</b>. Extienda <code>entab</code> y <code>detab</code> de modo que acepten la
abreviatura
</p>

<div class="org-src-container">
<pre class="src src-c">entab -m +n
</pre>
</div>

<p>
que indica puntos de tabulacion cada <code>n</code> columnas, iniciando en la
columna <code>m</code>. Seleccione el comportamiento por omision mas
conveniente (para el usuario).
</p>

<p>
<b>Ejercicio 5-13</b>. Escriba el programa <code>tail</code>, que imprime las ultimas
<code>n</code> lineas de su entrada. Por omision, <code>n</code> es 10, digamos, pero puede
modificarse con un argumento optativo, de modo que
</p>

<div class="org-src-container">
<pre class="src src-sh">tail -n
</pre>
</div>

<p>
imprime las ultimas <code>n</code> lineas. El programa debe comportarse en
forma racional sin importar cuan poco razonable sea la entrada o el
valor de <code>n</code>. Escriba el programa de manera que haga el mejor uso
de la memoria disponible; las lineas deben almacenarse como en el
programa de ordenamiento de la <a href="#org702cfb7">seccion 5.6</a>, no en un arreglo de dos
dimensiones de tamaño fijo.
</p>
</div>
</div>

<div id="outline-container-orgd015a35" class="outline-3">
<h3 id="orgd015a35">5.11 Apuntadores a funciones                                       <a id="org99adeeb"></a></h3>
<div class="outline-text-3" id="text-orgd015a35">
<p>
En C, una funcion por si sola no es una variable, pero es posible
definir apuntadores a funciones, que pueden asignarse, ser
colocados en arreglos, pasados a funciones, regresados por
funciones y otras cosas mas. Ilustraremos esto modificando el
procedimiento de ordenamiento descrito anteriormente en este
capitulo, de modo que si se da el argumento opcional <code>-n</code>, ordenara
las lineas de entrada numericamente en lugar de lexicograficamente.
</p>

<p>
Frecuentemente un ordenamiento consiste de tres partes – una
comparacion que determina el orden de cualquier par de objetos, un
intercambio que invierte su orden, y un algoritmo de ordenamiento
que realiza comparaciones e intercambios hasta que los objetos
esten en orden. El algoritmo de ordenamiento es independiente de
las operaciones de comparacion e intercambio; asi, al pasarle
diferentes funciones de comparacion e intercambio, se pueden
obtener clasificaciones con diferentes criterios. Esta es la
tactica que se sigue en nuestro nuevo metodo.
</p>

<p>
La comparacion lexicografica de dos lineas es realizada por
<code>strcmp</code>, como antes; tambien requeriremos de una rutina <code>numcmp</code>
que compare el valor numerico de dos lineas y regrese la misma
clase de indicacion que hace <code>strcmp</code>. Estas funciones se declaran
antes de <code>main</code>, y a <a href="#org2fd9ddd"><code>qsort</code></a> se le pasa un apuntador a la funcion
apropiada. Se ha hecho un procesamiento deficiente de los errores
en los argumentos, con el fin de concentrarnos en los elementos
principales.
</p>

<div class="org-src-container">
<pre class="src src-c"><span style="color: #b0c4de;">#include</span> <span style="color: #ffa07a;">&lt;stdio.h&gt;</span>
<span style="color: #b0c4de;">#include</span> <span style="color: #ffa07a;">&lt;string.h&gt;</span>

<span style="color: #b0c4de;">#define</span> <span style="color: #eedd82;">MAXLINES</span> 5000       <span style="color: #ff4500;">/* </span><span style="color: #ff4500;">max # de lineas a ordenar     </span><span style="color: #ff4500;">*/</span>
<span style="color: #98fb98;">char</span> *<span style="color: #eedd82;">lineptr</span>[MAXLINES];    <span style="color: #ff4500;">/* </span><span style="color: #ff4500;">apuntadores a lineas de texto </span><span style="color: #ff4500;">*/</span>

<span style="color: #98fb98;">int</span> <span style="color: #87cefa;">readlines</span>(<span style="color: #98fb98;">char</span> *<span style="color: #eedd82;">lineptr</span>[], <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">nlines</span>);
<span style="color: #98fb98;">void</span> <span style="color: #87cefa;">writelines</span>(<span style="color: #98fb98;">char</span> *<span style="color: #eedd82;">lineptr</span>[], <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">nlines</span>);

<span style="color: #98fb98;">void</span> <span style="color: #87cefa;">qsort</span>(<span style="color: #98fb98;">void</span> *<span style="color: #eedd82;">lineptr</span>[], <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">left</span>, <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">right</span>,
           <span style="color: #98fb98;">int</span> (*<span style="color: #87cefa;">comp</span>)(<span style="color: #98fb98;">void</span> *, <span style="color: #98fb98;">void</span> *));
<span style="color: #98fb98;">int</span> <span style="color: #87cefa;">numcmp</span>(<span style="color: #98fb98;">char</span> *, <span style="color: #98fb98;">char</span> *);

<span style="color: #ff4500;">/* </span><span style="color: #ff4500;">ordena lineas de entrada </span><span style="color: #ff4500;">*/</span>
<span style="color: #87cefa;">main</span>(<span style="color: #98fb98;">int</span> <span style="color: #eedd82;">argc</span>, <span style="color: #98fb98;">char</span> *<span style="color: #eedd82;">argv</span>[])
{
  <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">nlines</span>;        <span style="color: #ff4500;">/* </span><span style="color: #ff4500;">numero de lineas de entrada leidas </span><span style="color: #ff4500;">*/</span>
  <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">numeric</span> = 0;   <span style="color: #ff4500;">/* </span><span style="color: #ff4500;">1 si es ordenamiento numerico      </span><span style="color: #ff4500;">*/</span>

  <span style="color: #00ffff;">if</span> (argc &gt; 1 &amp;&amp; strcmp(argv[1], <span style="color: #ffa07a;">"-n"</span>) == 0)
    numeric = 1;
  <span style="color: #00ffff;">if</span> ((nlines = readlines(lineptr, MAXLINES)) &gt;= 0) {
    qsort((<span style="color: #98fb98;">void</span>**) lineptr, 0, nlines-1,
          (<span style="color: #98fb98;">int</span> (*)(<span style="color: #98fb98;">void</span>*,<span style="color: #98fb98;">void</span>*))(numeric ? numcmp : strcmp));
    writelines(lineptr, nlines);
    <span style="color: #00ffff;">return</span> 0;
  } <span style="color: #00ffff;">else</span> {
    printf(<span style="color: #ffa07a;">"entrada demasiado grande para ser ordenada\n"</span>);
    <span style="color: #00ffff;">return</span> 1;
  }
}
</pre>
</div>

<p>
En la llamada a <code>qsort</code>, <code>strcmp</code> y <code>numcmp</code> son direcciones de
funciones. Como se sabe que son funciones, el operador <code>&amp;</code> no es
necesario, en la misma forma que no es necesario antes del nombre
de un arreglo.
</p>

<p>
Hemos escrito <code>qsort</code> de modo que pueda procesar cualquier tipo de
dato, no solo cadenas de caracteres. Como se indica por la funcion
prototipo, <code>qsort</code> espera un arreglo de apuntadores, dos enteros y
una funcion con dos argumentos de tipo apuntador. Para los
argumentos apuntadores se emplea el tipo de apuntador generico
<code>void *</code>. Cualquier apuntador puede ser forzado a ser <code>void *</code> y
regresado de nuevo sin perdida de informacion, de modo que podemos
llamar a <code>qsort</code> forzando los argumentos a <code>void *</code>. El elaborado
cast del argumento de la funcion fuerza los argumentos de la
funcion de comparacion. Esto generalmente no tendra efecto sobre la
representacion real, pero asegura al compilador que todo este bien.
</p>

<div class="org-src-container">
<pre class="src src-c"><span style="color: #ff4500;">/* </span><span style="color: #ff4500;">qsort: clasifica v[left]...v[right] en orden ascendente </span><span style="color: #ff4500;">*/</span>
<span style="color: #98fb98;">void</span> <span style="color: #87cefa;">qsort</span>(<span style="color: #98fb98;">void</span> *<span style="color: #eedd82;">v</span>[], <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">left</span>, <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">right</span>,
           <span style="color: #98fb98;">int</span> (*<span style="color: #87cefa;">comp</span>)(<span style="color: #98fb98;">void</span> *, <span style="color: #98fb98;">void</span> *))
{
  <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">i</span>, <span style="color: #eedd82;">last</span>;

  <span style="color: #98fb98;">void</span> <span style="color: #87cefa;">swap</span>(<span style="color: #98fb98;">void</span> *<span style="color: #eedd82;">v</span>[], <span style="color: #98fb98;">int</span>, <span style="color: #98fb98;">int</span>);

  <span style="color: #00ffff;">if</span> (left &gt;= right) <span style="color: #ff4500;">/* </span><span style="color: #ff4500;">no hace nada si el arreglo contiene </span><span style="color: #ff4500;">*/</span>
    <span style="color: #00ffff;">return</span>;          <span style="color: #ff4500;">/* </span><span style="color: #ff4500;">menos de dos elementos              </span><span style="color: #ff4500;">*/</span>
  swap(v, left, (left + right)/2);
  last = left;
  <span style="color: #00ffff;">for</span> (i = left+1; i &lt;= right; i++)
    <span style="color: #00ffff;">if</span> ((*comp)(v[i], v[left]) &lt; 0)
      swap(v, ++last, i);
  swap(v, left, last);
  qsort(v, left, last-1, comp);
  qsort(v, last+1, right, comp);
}
</pre>
</div>

<p>
Las declaraciones deben estudiarse con cuidado. El cuarto parametro
de <code>qsort</code> es
</p>

<div class="org-src-container">
<pre class="src src-c"><span style="color: #98fb98;">int</span> (*comp) (<span style="color: #98fb98;">void</span> *, <span style="color: #98fb98;">void</span> *)
</pre>
</div>

<p>
que indica que <code>comp</code> es un apuntador a una funcion que tiene dos
argumentos <code>void *</code> y regresa un <code>int</code>.
</p>

<p>
El uso de <code>comp</code> en la linea
</p>

<div class="org-src-container">
<pre class="src src-c"><span style="color: #00ffff;">if</span> ((*comp) (v[i], v[left] &lt; 0)
</pre>
</div>

<p>
es consistente con la declaracion: <code>comp</code> es un apuntador a una
funcion, <code>*comp</code> es la funcion, y
</p>

<div class="org-src-container">
<pre class="src src-c">(*comp) (v[i], v[left])
</pre>
</div>

<p>
es la llamada a ella. Los parentesis son necesarios para que los
componentes sean correctamente asociados; sin ellos,
</p>

<div class="org-src-container">
<pre class="src src-c"><span style="color: #98fb98;">int</span> *<span style="color: #87cefa;">comp</span>(<span style="color: #98fb98;">void</span> *, <span style="color: #98fb98;">void</span> *) <span style="color: #ff4500;">/* </span><span style="color: #ff4500;">INCORRECTO </span><span style="color: #ff4500;">*/</span>
</pre>
</div>

<p>
indica que <code>comp</code> es una funcion que regresa un apuntador a <code>int</code>,
lo cual es muy diferente.
</p>

<p>
Ya hemos mostrado <code>strcmp</code>, que compara dos cadenas. Aqui esta
<code>numcmp</code>, que compara dos cadenas numericamente, valor que se
calcula llamando a <a href="#org9f52a73"><code>atof</code></a>:
</p>

<div class="org-src-container">
<pre class="src src-c"><span style="color: #b0c4de;">#include</span> <span style="color: #ffa07a;">&lt;stdlib.h&gt;</span>

<span style="color: #ff4500;">/* </span><span style="color: #ff4500;">numcmp: compara s1 y s2 numericamente </span><span style="color: #ff4500;">*/</span>
<span style="color: #98fb98;">int</span> <span style="color: #87cefa;">numcmp</span>(<span style="color: #98fb98;">char</span> *<span style="color: #eedd82;">s1</span>, <span style="color: #98fb98;">char</span> *<span style="color: #eedd82;">s2</span>)
{
  <span style="color: #98fb98;">double</span> <span style="color: #eedd82;">v1</span>, <span style="color: #eedd82;">v2</span>;
  v1 = atof(s1);
  v2 = atof(s2);
  <span style="color: #00ffff;">if</span> (v1 &lt; v2)
    <span style="color: #00ffff;">return</span> -1;
  <span style="color: #00ffff;">else</span> <span style="color: #00ffff;">if</span> (v1 &gt; v2)
    <span style="color: #00ffff;">return</span> 1;
  <span style="color: #00ffff;">else</span>
    <span style="color: #00ffff;">return</span> 0;
}
</pre>
</div>

<p>
La funcion <code>swap</code>, que intercambia dos apuntadores, es identica a
la que presentamos anteriormente en este capitulo, excepto en que
las declaraciones se han cambiado a <code>void *</code>.
</p>

<div class="org-src-container">
<pre class="src src-c"><span style="color: #98fb98;">void</span> <span style="color: #87cefa;">swap</span>(<span style="color: #98fb98;">void</span> *<span style="color: #eedd82;">v</span>[], <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">i</span>, <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">j</span>)
{
  <span style="color: #98fb98;">void</span> *<span style="color: #eedd82;">temp</span>;

  temp = v[i];
  v[i] = v[j];
  v[j] = temp;
}
</pre>
</div>

<p>
Puede agregarse una variedad de otras opciones al programa de
ordenamiento; algunas se convierten en ejercicios interesantes.
</p>

<p>
<b>Ejercicio 5-14</b>. Modifique el programa de ordenamiento de modo que
maneje una bandera <code>-r</code>, que indica ordenar en orden inverso
(descendente). Asegurese de que <code>-r</code>, trabaja con <code>-n</code>.
</p>

<p>
<b>Ejercicio 5-15</b>. Agregue la opcion <code>-f</code> para igualar las letras
mayusculas y minusculas, de modo que no se haga distincion entre
ellas durante el ordenamiento; por ejemplo, al comparar, <code>a</code> y <code>A</code>
son iguales.
</p>

<p>
<b>Ejercicio 5-16</b>. Agregue la opcion <code>-d</code> ("orden de directorio"),
que compara solo letras, numeros y blancos. Asegurese de que
trabaja en conjuncion con <code>-f</code>.
</p>

<p>
<b>Ejercicio 5-17</b>. Agregue capacidad de manejo de campos, para que
el ordenamiento se haga sobre campos de las lineas, cada campo
ordenado de acuerdo con un conjunto independiente de opciones. (El
indice de este libro fue ordenado con <code>-df</code> para las entradas y
<code>-n</code> para los numeros de pagina.)
</p>
</div>
</div>

<div id="outline-container-org30c8d07" class="outline-3">
<h3 id="org30c8d07">5.12 Declaraciones complicadas                                     <a id="orgbbd6ebe"></a></h3>
<div class="outline-text-3" id="text-org30c8d07">
<p>
Al lenguaje C se le reprueba algunas veces por la sintaxis de sus
declaraciones, particularmente las que involucran apuntadores a
funciones. En la sintaxis hay un intento de hacer que coincidan las
declaraciones con su uso; trabaja bien para casos simples, pero
puede ser confusa para los dificiles, debido a que las
declaraciones no pueden leerse de izquierda a derecha, y debido al
exceso de uso de parentesis. La diferencia entre
</p>


<div class="org-src-container">
<pre class="src src-c"><span style="color: #98fb98;">int</span> *<span style="color: #87cefa;">f</span>();     <span style="color: #ff4500;">/* </span><span style="color: #ff4500;">f: funcion que regresa un apuntador a int </span><span style="color: #ff4500;">*/</span>
</pre>
</div>

<p>
y
</p>

<div class="org-src-container">
<pre class="src src-c"><span style="color: #98fb98;">int</span> (*pf)();  <span style="color: #ff4500;">/* </span><span style="color: #ff4500;">pf: apuntador a una funcion que regresa un int </span><span style="color: #ff4500;">*/</span>
</pre>
</div>

<p>
ilustra el problema: <code>*</code> es un operador prefijo y tiene menor
precedencia que <code>()</code>, de modo que los parentesis son necesarios
para obligar a una asociacion apropiada.
</p>

<p>
Aunque en la practica es extraño que aparezcan declaraciones
verdaderamente complicadas, es importante saber como entenderlas y,
si es necesario, como crearlas. Una buena forma de sintetizar
declaraciones es en pequeños pasos con <code>typedef</code>, que se discute en
la <a href="#org0080b17">seccion 6.7</a>. Como una alternativa, en esta seccion presentaremos
un par de programas que convierten de C valido a una descripcion
verbal y viceversa. La descripcion verbal se lee de izquierda a
derecha.
</p>

<p>
La primera, <code>dcl</code>, es la mas compleja. Convierte una declaracion de
C en una descripcion hecha con palabras, como en estos ejemplos:
</p>

<pre class="example">
char **argv
    argv: pointer to char
int (*daytab)[13]
    daytab: pointer to array[13] of int
int *daytab[13]
    daytab: array[13] of pointer to int
void *comp()
    comp: function returning pointer to void
void (*comp)()
    comp: pointer to function returning void
char (*(*x())[])()
    x: function returning pointer to array[] of
    pointer to function returning char
char (*(*x[3])())[5]
    x: array[3] of pointer to function returning
    pointer to array[5] of char
</pre>

<p>
<code>dcl</code> esta basada en la gramatica que especifica un declarador, que
se define en forma precisa en el <a href="#orgea26d39">apendice A</a>, <a href="#orge4244db">seccion 8.5</a>; esta es
una forma simplificada:
</p>

<pre class="example">
dcl:           optional *'s direct-dcl
direct-dcl:    name
               (dcl)
               direct-dcl()
               direct-dcl[optional size]
</pre>

<p>
Con palabras, una <i>dcl</i> es una <i>dcl-directa</i>, tal vez precedido por
<code>*s</code>. Una <i>dcl-directa</i> es un nombre, o una <i>dcl</i> entre parentesis,
o una <i>dcl-directa</i> seguida por parentesis, o una <i>dcl-directa</i>
seguida por corchetes con un tamaño optativo.
</p>

<p>
Esta gramatica puede emplearse para reconocer declaraciones. Por
ejemplo, considere este declarador:
</p>

<div class="org-src-container">
<pre class="src src-c">(*pfa[]) ()
</pre>
</div>

<p>
<code>pfa</code> se identificara como un <i>nombre</i> y por ende como una
<i>dcl-directa</i>. Entonces <code>pfa[]</code> es tambien una <i>dcl-directa</i>. Luego
<code>*pfa[]</code> se reconoce como una <i>dcl</i>, de modo que <code>(*pfa[])</code> es una
<i>dcl-directa</i>. Entonces <code>(*pfa[])()</code> es una <i>dcl-directa</i> y por
tanto una <i>dcl</i>. Tambien podemos ilustrar el analisis con un arbol
de estructura gramatical como este (en donde <i>dcl-directa</i> se ha
abreviado como <i>dcl-dir</i>):
</p>


<div class="figure">
<p><img src="img/img_05.12.png" alt="img_05.12.png" />
</p>
</div>

<p>
El corazon del programa del es un par de funciones, <code>dcl</code> y
<code>dirdcl</code>, que describen una declaracion de acuerdo con esta
gramatica. Debido a que la gramatica esta definida recursivamente,
las funciones se llaman recursivamente una a la otra, mientras
reconocen piezas de una declaracion; el programa se conoce como
analizador sintactico por descenso recursivo.
</p>

<div class="org-src-container">
<pre class="src src-c"><span style="color: #ff4500;">/* </span><span style="color: #ff4500;">dcl: reconoce una declaracion </span><span style="color: #ff4500;">*/</span>
<span style="color: #98fb98;">void</span> <span style="color: #87cefa;">dcl</span>(<span style="color: #98fb98;">void</span>)
{
  <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">ns</span>;

  <span style="color: #00ffff;">for</span> (ns = 0; gettoken() == <span style="color: #ffa07a;">'*'</span>; ) <span style="color: #ff4500;">/* </span><span style="color: #ff4500;">cuenta *'s </span><span style="color: #ff4500;">*/</span>
    ns++;
  dirdcl();
  <span style="color: #00ffff;">while</span> (ns-- &gt; 0)
    strcat(out, <span style="color: #ffa07a;">" apuntador a"</span>);
}

<span style="color: #ff4500;">/* </span><span style="color: #ff4500;">dirdcl: reconoce un declarador directo </span><span style="color: #ff4500;">*/</span>
<span style="color: #98fb98;">void</span> <span style="color: #87cefa;">dirdcl</span>(<span style="color: #98fb98;">void</span>)
{
  <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">type</span>;

  <span style="color: #00ffff;">if</span> (tokentype == <span style="color: #ffa07a;">'('</span>) {       <span style="color: #ff4500;">/* </span><span style="color: #ff4500;">( dcl )            </span><span style="color: #ff4500;">*/</span>
    dcl();
    <span style="color: #00ffff;">if</span> (tokentype != <span style="color: #ffa07a;">')'</span>)
      printf(<span style="color: #ffa07a;">"error: falta )\n"</span>);
  } <span style="color: #00ffff;">else</span> <span style="color: #00ffff;">if</span> (tokentype == NAME) <span style="color: #ff4500;">/* </span><span style="color: #ff4500;">nombre de variable </span><span style="color: #ff4500;">*/</span>
    strcpy(name, token);
  <span style="color: #00ffff;">else</span>
    printf(<span style="color: #ffa07a;">"error: nombre o (dcl) esperado\n"</span>);
  <span style="color: #00ffff;">while</span> ((type=gettoken()) == PARENS || type == BRACKETS)
    <span style="color: #00ffff;">if</span> (type == PARENS)
      strcat(out, <span style="color: #ffa07a;">" funcion que regresa"</span>);
    <span style="color: #00ffff;">else</span> {
      strcat(out, <span style="color: #ffa07a;">" arreglo"</span>);
      strcat(out, token);
      strcat(out, <span style="color: #ffa07a;">" de"</span>);
    }
}
</pre>
</div>

<p>
Puesto que se intenta que el programa sea ilustrativo, no a prueba
de balas, hay restricciones sobre <code>dcl</code>, que solo puede manejar un
tipo simple de datos como <code>char</code> o <code>int</code>. No maneja tipos de
argumentos dentro de funciones, o calificadores como <code>const</code>. Los
espacios en blanco inadecuados lo confunden. No se recupera mucho
ante los errores, de modo que las declaraciones invalidas tambien
lo confunden. Esas mejoras se dejan como ejercicios.
</p>

<p>
Aqui estan las variables globales y la rutina principal:
</p>

<div class="org-src-container">
<pre class="src src-c"><span style="color: #b0c4de;">#include</span> <span style="color: #ffa07a;">&lt;stdio.h&gt;</span>
<span style="color: #b0c4de;">#include</span> <span style="color: #ffa07a;">&lt;string.h&gt;</span>
<span style="color: #b0c4de;">#include</span> <span style="color: #ffa07a;">&lt;ctype.h&gt;</span>

<span style="color: #b0c4de;">#define</span> <span style="color: #eedd82;">MAXTOKEN</span> 100

<span style="color: #00ffff;">enum</span> { <span style="color: #eedd82;">NAME</span>, <span style="color: #eedd82;">PARENS</span>, <span style="color: #eedd82;">BRACKETS</span> };

<span style="color: #98fb98;">void</span> <span style="color: #87cefa;">dcl</span>(<span style="color: #98fb98;">void</span>);
<span style="color: #98fb98;">void</span> <span style="color: #87cefa;">dirdcl</span>(<span style="color: #98fb98;">void</span>);

<span style="color: #98fb98;">int</span> <span style="color: #87cefa;">gettoken</span>(<span style="color: #98fb98;">void</span>);
<span style="color: #98fb98;">int</span> <span style="color: #eedd82;">tokentype</span>;                 <span style="color: #ff4500;">/* </span><span style="color: #ff4500;">tipo del ultimo token          </span><span style="color: #ff4500;">*/</span>
<span style="color: #98fb98;">char</span> <span style="color: #eedd82;">token</span>[MAXTOKEN];          <span style="color: #ff4500;">/* </span><span style="color: #ff4500;">cadena del ultimo token        </span><span style="color: #ff4500;">*/</span>
<span style="color: #98fb98;">char</span> <span style="color: #eedd82;">name</span>[MAXTOKEN];           <span style="color: #ff4500;">/* </span><span style="color: #ff4500;">nombre del identificador       </span><span style="color: #ff4500;">*/</span>
<span style="color: #98fb98;">char</span> <span style="color: #eedd82;">datatype</span>[MAXTOKEN];       <span style="color: #ff4500;">/* </span><span style="color: #ff4500;">tipo de dato = char, int, etc. </span><span style="color: #ff4500;">*/</span>
<span style="color: #98fb98;">char</span> <span style="color: #eedd82;">out</span>[1000];                <span style="color: #ff4500;">/* </span><span style="color: #ff4500;">cadena de salida               </span><span style="color: #ff4500;">*/</span>

<span style="color: #87cefa;">main</span>() <span style="color: #ff4500;">/* </span><span style="color: #ff4500;">convierte una declaracion a palabras </span><span style="color: #ff4500;">*/</span>
{
  <span style="color: #00ffff;">while</span> (gettoken() != EOF) {  <span style="color: #ff4500;">/* </span><span style="color: #ff4500;">1er. token en la linea         </span><span style="color: #ff4500;">*/</span>
    strcpy(datatype, token);   <span style="color: #ff4500;">/* </span><span style="color: #ff4500;">es el tipo de dato             </span><span style="color: #ff4500;">*/</span>
    out[0] = <span style="color: #ffa07a;">'\0'</span>;
    dcl();                     <span style="color: #ff4500;">/* </span><span style="color: #ff4500;">reconoce el resto de la linea  </span><span style="color: #ff4500;">*/</span>
    <span style="color: #00ffff;">if</span> (tokentype != <span style="color: #ffa07a;">'\n'</span>)
      printf(<span style="color: #ffa07a;">"error de sintaxis\n"</span>);
    printf(<span style="color: #ffa07a;">"%s: %s %s\n"</span>, name, out, datatype);
  }
  <span style="color: #00ffff;">return</span> 0;
}
</pre>
</div>

<p>
La funcion <code>gettoken</code> ignora blancos y tabuladores, y encuentra el
siguiente token de la entrada; un "token" es un nombre, un par de
parentesis, un par de corchetes que tal vez incluyen un numero, o
cualquier otro caracter simple.
</p>

<div class="org-src-container">
<pre class="src src-c"><span style="color: #98fb98;">int</span> <span style="color: #87cefa;">gettoken</span>(<span style="color: #98fb98;">void</span>)   <span style="color: #ff4500;">/* </span><span style="color: #ff4500;">regresa el siguiente token </span><span style="color: #ff4500;">*/</span>
{
  <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">c</span>, <span style="color: #87cefa;">getch</span>(<span style="color: #98fb98;">void</span>);
  <span style="color: #98fb98;">void</span> <span style="color: #87cefa;">ungetch</span>(<span style="color: #98fb98;">int</span>);
  <span style="color: #98fb98;">char</span> *<span style="color: #eedd82;">p</span> = token;

  <span style="color: #00ffff;">while</span> ((c = getch()) == <span style="color: #ffa07a;">' '</span> || c == <span style="color: #ffa07a;">'\t'</span>)
    ;
  <span style="color: #00ffff;">if</span> (c == <span style="color: #ffa07a;">'('</span>) {
    <span style="color: #00ffff;">if</span> ((c = getch()) == <span style="color: #ffa07a;">')'</span>) {
      strcpy(token, <span style="color: #ffa07a;">"()"</span>);
      <span style="color: #00ffff;">return</span> tokentype = PARENS;
    } <span style="color: #00ffff;">else</span> {
      ungetch(c);
      <span style="color: #00ffff;">return</span> tokentype = <span style="color: #ffa07a;">'('</span>;
    }
  } <span style="color: #00ffff;">else</span> <span style="color: #00ffff;">if</span> (c == <span style="color: #ffa07a;">'['</span>) {
    <span style="color: #00ffff;">for</span> (*p++ = c; (*p++ = getch()) != <span style="color: #ffa07a;">']'</span>; )
      ;
    *p = <span style="color: #ffa07a;">'\0'</span>;
    <span style="color: #00ffff;">return</span> tokentype = BRACKETS;
  } <span style="color: #00ffff;">else</span> <span style="color: #00ffff;">if</span> (isalpha(c)) {
    <span style="color: #00ffff;">for</span> (*p++ = c; isalnum(c = getch()); )
      *p++ = c;
    *p = <span style="color: #ffa07a;">'\0'</span>;
    ungetch(c);
    <span style="color: #00ffff;">return</span> tokentype = NAME;
  } <span style="color: #00ffff;">else</span>
    <span style="color: #00ffff;">return</span> tokentype = c;
}
</pre>
</div>

<p>
<code>getch</code> y <code>ungetch</code> se discutieron en el <a href="#org05a38fc">capitulo 4</a>.
</p>

<p>
Es mas facil ir en la direccion inversa, especialmente si no nos
preocupamos por la generacion de parentesis redundantes. El
programa <code>undcl</code> convierte una descripcion verbal como "<code>x</code> es una
funcion que regresa un apuntador a un arreglo de apuntadores a
funciones que regresan <code>char</code>", que se expresara como
</p>

<div class="org-src-container">
<pre class="src src-c"><span style="color: #87cefa;">x</span> () * [] * () <span style="color: #98fb98;">char</span>
</pre>
</div>

<p>
y se convertira en
</p>

<div class="org-src-container">
<pre class="src src-c"><span style="color: #98fb98;">char</span> (*(*x())[])()
</pre>
</div>

<p>
La sintaxis abreviada de la entrada nos permite reutilizar a la
funcion <code>gettoken</code>. La funcion <code>undcl</code> tambien emplea las mismas
variables externas que <code>dcl</code>.
</p>

<div class="org-src-container">
<pre class="src src-c"><span style="color: #98fb98;">int</span> <span style="color: #87cefa;">main</span>(){
  <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">type</span>;
  <span style="color: #98fb98;">char</span> <span style="color: #eedd82;">temp</span>[ MAXTOKEN ];

  <span style="color: #00ffff;">while</span>( gettoken() != EOF ){
    out[ 0 ] = <span style="color: #ffa07a;">'\0'</span>;
    strcpy( out, token );

    <span style="color: #00ffff;">while</span>( (type = gettoken()) != <span style="color: #ffa07a;">'\n'</span> )
      <span style="color: #00ffff;">if</span>( type == PARENS || type == BRACKETS )
        strcat( out, token );
      <span style="color: #00ffff;">else</span> <span style="color: #00ffff;">if</span>( type == <span style="color: #ffa07a;">'*'</span> ){
        sprintf( temp, <span style="color: #ffa07a;">"(*%s)"</span>, out );
        strcpy( out, temp );
      } <span style="color: #00ffff;">else</span> <span style="color: #00ffff;">if</span>( type == NAME ){
        sprintf( temp, <span style="color: #ffa07a;">"%s %s"</span>, token, out );
        strcpy( out, temp );
      } <span style="color: #00ffff;">else</span>
        printf( <span style="color: #ffa07a;">"entrada invalida en %s\n"</span>, token );

    printf( <span style="color: #ffa07a;">"\n%s\n"</span>, out );
  }

  <span style="color: #00ffff;">return</span> 0;
}
</pre>
</div>

<p>
<b>Ejercicio 5-18</b>. Haga que dcl se recupere de errores en la
entrada.
</p>

<p>
<b>Ejercicio 5-19</b>. Modifique <code>undcl</code> de modo que no agregue
parentesis redundantes a las declaraciones.
</p>

<p>
<b>Ejercicio 5-20</b>. Extiende <code>dcl</code> para que maneje declaraciones con
tipos de argumentos de funciones, calificadores como <code>const</code>,
etcetera.
</p>
</div>
</div>
</div>

<div id="outline-container-orga7053eb" class="outline-2">
<h2 id="orga7053eb">capitulo 6: Estructura                                              <a id="org09ddcb4"></a></h2>
<div class="outline-text-2" id="text-orga7053eb">
<p>
Una estructura es una coleccion de una o mas variables, de tipos
posiblemente diferentes, agrupadas bajo un solo nombre para manejo
conveniente. (Las estructuras se conocen como "records" en algunos
otros lenguajes, principalmente Pascal.) Las estructuras ayudan a
organizar datos complicados, en particular dentro de programas
grandes, debido a que permiten que a un grupo de variables
relacionadas se les trate como una unidad en lugar de como entidades
separadas.
</p>

<p>
Un ejemplo tradicional de estructura es el registro de una nomina:
un empleado esta descrito por un conjunto de atributos, como nombre,
domicilio, numero del seguro social, salario, etc. Algunos de estos
atributos pueden, a su vez, ser estructuras: un nombre tiene varios
componentes, como los tiene un domicilio y aun un salario. Otro
ejemplo, mas tipico para C, procede de las graficas: un punto es un
par de coordenadas, un rectangulo es un par de puntos, y otros casos
semejantes.
</p>

<p>
El principal cambio realizado por el estandar ANSI es la definicion
de la asignacion de estructuras – las estructuras se pueden copiar y
asignar, pasar a funciones y ser regresadas por funciones. Esto ha
sido manejado por muchos compiladores durante varios años, pero las
propiedades estan ahora definidas en forma precisa.  Las estructuras
y los arreglos automaticos ahora tambien se pueden inicializar.
</p>
</div>

<div id="outline-container-orgbe208f6" class="outline-3">
<h3 id="orgbe208f6">6.1  Conceptos basicos sobre estructuras                           <a id="org0d68872"></a></h3>
<div class="outline-text-3" id="text-orgbe208f6">
<p>
Definamos algunas estructuras propias para graficacion. El objeto
basico es un punto, del cual supondremos que tiene una coordenada
<code>x</code> y una coordenada <code>y</code>, ambas enteras.
</p>


<div class="figure">
<p><img src="img/img_06.01.01.png" alt="img_06.01.01.png" />
</p>
</div>

<p>
Los dos componentes pueden ser colocados en una estructura
declarada asi:
</p>

<div class="org-src-container">
<pre class="src src-c"><span style="color: #00ffff;">struct</span> <span style="color: #98fb98;">point</span> {
  <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">x</span>;
  <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">y</span>;
};
</pre>
</div>

<p>
La palabra reservada <code>struct</code> presenta la declaracion de una
estructura, que es una lista de declaraciones entre llaves. Un
nombre optativo, llamado <i>etiqueta de estructura</i>, puede seguir a
la palabra <code>struct</code> (como aqui lo hace <code>point</code>). La etiqueta da
nombre a esta clase de estructura, y en adelante puede ser
utilizado como una abreviatura para la parte de declaraciones entre
llaves.
</p>

<p>
Las variables nombradas dentro de la estructura se llaman
<i>miembros</i>. Un miembro de estructura, y una variable ordinaria
(esto es, no miembro) pueden tener el mismo nombre sin conflicto,
puesto que siempre se pueden distinguir por el contexto. Ademas, en
diferentes estructuras pueden encontrarse los mismos nombres de
miembros, aunque por cuestiones de estilo se deberian de usar los
mismos nombres solo para objetos estrechamente relacionados.
</p>

<p>
Una declaracion <code>struct</code> define un tipo. La llave derecha que
termina la lista de miembros puede ser seguida por una lista de
variables, como se hace para cualquier tipo basico. Esto es,
</p>

<div class="org-src-container">
<pre class="src src-c"><span style="color: #00ffff;">struct</span> { ... } <span style="color: #eedd82;">x</span>, <span style="color: #eedd82;">y</span>, <span style="color: #eedd82;">z</span>;
</pre>
</div>

<p>
es sintacticamente analogo a
</p>

<div class="org-src-container">
<pre class="src src-c"><span style="color: #98fb98;">int</span> <span style="color: #eedd82;">x</span>, <span style="color: #eedd82;">y</span>, <span style="color: #eedd82;">z</span>;
</pre>
</div>

<p>
en el sentido de que cada proposicion declara a <code>x</code>, <code>y</code> y <code>z</code> como
variables del tipo nombrado y causa que se les reserve espacio
contiguo.
</p>

<p>
Una declaracion de estructura que no esta seguida por una lista de
variables no reserva espacio de almacenamiento sino que simplemente
describe una plantilla o la forma de una estructura. Sin embargo,
si la declaracion esta etiquetada, la etiqueta se puede emplear
posteriormente en definiciones de instancias de la estructura. Por
ejemplo, dada la declaracion anterior de <code>point</code>,
</p>

<div class="org-src-container">
<pre class="src src-c"><span style="color: #00ffff;">struct</span> <span style="color: #98fb98;">point</span> <span style="color: #eedd82;">pt</span>;
</pre>
</div>

<p>
define una variable <code>pt</code> que es una estructura de tipo <code>struct
   point</code>. Una estructura se puede inicializar al seguir su definicion
con una lista de inicializadores, cada uno una expresion constante,
para los miembros:
</p>

<div class="org-src-container">
<pre class="src src-c"><span style="color: #00ffff;">struct</span> <span style="color: #98fb98;">point</span> <span style="color: #eedd82;">maxpt</span> = { 320, 200 };
</pre>
</div>

<p>
Una estructura automatica tambien se puede inicializar por
asignacion o llamando a una funcion que regresa una estructura del
tipo adecuado.
</p>

<p>
Se hace referencia a un miembro de una estructura en particular en
una expresion con una construccion de la forma
</p>

<div class="org-src-container">
<pre class="src src-c">nombre-estructura.miembro
</pre>
</div>

<p>
El operador miembro de estructura "." conecta al nombre de la
estructura con el nombre del miembro. Por ejemplo, para imprimir
las coordenadas del punto <code>pt</code>,
</p>

<div class="org-src-container">
<pre class="src src-c">printf(<span style="color: #ffa07a;">"%d,%d"</span>, pt.x, pt.y);
</pre>
</div>

<p>
o para calcular la distancia del origen <code>(0,0)</code> a <code>pt</code>,
</p>

<div class="org-src-container">
<pre class="src src-c"><span style="color: #98fb98;">double</span> <span style="color: #eedd82;">dist</span>, <span style="color: #87cefa;">sqrt</span>(<span style="color: #98fb98;">double</span>);

dist = sqrt((<span style="color: #98fb98;">double</span>)pt.x * pt.x + (<span style="color: #98fb98;">double</span>)pt.y * pt.y);
</pre>
</div>

<p>
Las estructuras pueden anidarse. Una representacion de un
rectangulo es como un par de puntos que denotan las esquinas
diagonalmente opuestas:
</p>


<div class="figure">
<p><img src="img/img_06.01.02.png" alt="img_06.01.02.png" />
</p>
</div>

<div class="org-src-container">
<pre class="src src-c"><span style="color: #00ffff;">struct</span> <span style="color: #98fb98;">rect</span> {
  <span style="color: #00ffff;">struct</span> <span style="color: #98fb98;">point</span> <span style="color: #eedd82;">ptl</span>;
  <span style="color: #00ffff;">struct</span> <span style="color: #98fb98;">point</span> <span style="color: #eedd82;">pt2</span>;
};
</pre>
</div>

<p>
La estructura <code>rect</code> contiene dos estructuras <code>point</code>. Si
declaramos <code>screen</code> como
</p>

<div class="org-src-container">
<pre class="src src-c"><span style="color: #00ffff;">struct</span> <span style="color: #98fb98;">rect</span> <span style="color: #eedd82;">screen</span>;
</pre>
</div>

<p>
entonces
</p>

<div class="org-src-container">
<pre class="src src-c">screen.pt1.x
</pre>
</div>

<p>
se refiere a la coordenada <code>x</code> del miembro <code>pt1</code> de <code>screen</code>.
</p>
</div>
</div>

<div id="outline-container-org1c16408" class="outline-3">
<h3 id="org1c16408">6.2  Estructuras y funciones                                       <a id="org8624a28"></a></h3>
<div class="outline-text-3" id="text-org1c16408">
<p>
Las unicas operaciones legales sobre una estructura son copiarla o
asignarla como unidad, tomar su direccion con <code>&amp;</code>, y tener acceso a
sus miembros. La copia y la asignacion incluyen pasarlas como
argumentos a funciones y tambien regresar valores de funciones. Las
estructuras no se pueden comparar. Una estructura se puede
inicializar con una lista de valores constantes de miembros; una
estructura automatica tambien se puede inicializar con una
asignacion.
</p>

<p>
Investiguemos las estructuras escribiendo algunas funciones para
manipular puntos y rectangulos. Hay por lo menos tres acercamientos
posibles: pasar separadamente los componentes, pasar una estructura
completa o pasar un apuntador a ella. Cada uno tiene sus puntos
buenos y malos.
</p>

<p>
La primera funcion, <code>makepoint</code>, toma dos enteros y regresa una
estructura <code>point</code>:
</p>

<div class="org-src-container">
<pre class="src src-c"><span style="color: #ff4500;">/* </span><span style="color: #ff4500;">makepoint: crea un punto con las componentes x, y </span><span style="color: #ff4500;">*/</span>
<span style="color: #00ffff;">struct</span> <span style="color: #98fb98;">point</span> <span style="color: #87cefa;">makepoint</span>(<span style="color: #98fb98;">int</span> <span style="color: #eedd82;">x</span>, <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">y</span>)
{
  <span style="color: #00ffff;">struct</span> <span style="color: #98fb98;">point</span> <span style="color: #eedd82;">temp</span>;

  temp.x = x;
  temp.y = y;
  <span style="color: #00ffff;">return</span> temp;
}
</pre>
</div>

<p>
Notese que no hay conflicto entre el nombre del argumento y el
miembro con el mismo nombre; incluso la reutilizacion de los
nombres refuerza el vinculo.
</p>

<p>
<code>makepoint</code> ahora se puede usar para inicializar dinamicamente
cualquier estructura, o para proporcionar los argumentos de la
estructura a una funcion:
</p>

<div class="org-src-container">
<pre class="src src-c"><span style="color: #00ffff;">struct</span> <span style="color: #98fb98;">rect</span> <span style="color: #eedd82;">screen</span>;
<span style="color: #00ffff;">struct</span> <span style="color: #98fb98;">point</span> <span style="color: #eedd82;">middle</span>;
<span style="color: #00ffff;">struct</span> <span style="color: #98fb98;">point</span> <span style="color: #87cefa;">makepoint</span>(<span style="color: #98fb98;">int</span>, <span style="color: #98fb98;">int</span>);

screen.pt1 = makepoint(0, 0);
screen.pt2 = makepoint(XMAX, YMAX);
middle = makepoint((screen.pt1.x + screen.pt2.x)/2,
                   (screen.pt1.y + screen.pt2.y)/2);
</pre>
</div>

<p>
El siguiente paso es un conjunto de funciones para hacer
operaciones aritmeticas sobre los puntos. Por ejemplo,
</p>

<div class="org-src-container">
<pre class="src src-c"><span style="color: #ff4500;">/* </span><span style="color: #ff4500;">addpoint: suma dos puntos </span><span style="color: #ff4500;">*/</span>
<span style="color: #00ffff;">struct</span> <span style="color: #98fb98;">point</span> <span style="color: #87cefa;">addpoint</span>(<span style="color: #00ffff;">struct</span> <span style="color: #98fb98;">point</span> <span style="color: #eedd82;">p1</span>, <span style="color: #00ffff;">struct</span> <span style="color: #98fb98;">point</span> <span style="color: #eedd82;">p2</span>){
  p1.x += p2.x;
  p1.y += p2.y;
  <span style="color: #00ffff;">return</span> p1;
}
</pre>
</div>

<p>
Aqui, tanto los argumentos como el valor de retorno son
estructuras. Incrementamos los componentes en <code>p1</code> en lugar de
utilizar explicitamente una variable temporal para hacer enfasis en
que los parametros de la estructura son pasados por valor como
cualesquiera otros.
</p>

<p>
Como otro ejemplo, la funcion <code>ptinrect</code> prueba si un punto esta
dentro de un rectangulo, donde hemos adoptado la convencion de que
un rectangulo incluye sus lados izquierdo e inferior pero no sus
lados superior y derecho:
</p>

<div class="org-src-container">
<pre class="src src-c"><span style="color: #ff4500;">/* </span><span style="color: #ff4500;">ptinrect: regresa 1 si p esta en r, 0 si no lo esta </span><span style="color: #ff4500;">*/</span>
<span style="color: #98fb98;">int</span> <span style="color: #87cefa;">ptinrect</span>(<span style="color: #00ffff;">struct</span> <span style="color: #98fb98;">point</span> <span style="color: #eedd82;">p</span>, <span style="color: #00ffff;">struct</span> <span style="color: #98fb98;">rect</span> <span style="color: #eedd82;">r</span>)
{
  <span style="color: #00ffff;">return</span> p.x &gt;= r.pt1.x &amp;&amp; p.x &lt; r.pt2.x
         &amp;&amp; p.y &gt;= r.pt1.y &amp;&amp; p.y &lt; r.pt2.y;
}
</pre>
</div>

<p>
Esto supone que el rectangulo esta representado en una forma
estandar en donde las coordenadas <code>pt1</code> son menores que las
coordenadas <code>pt2</code>. La siguiente funcion regresa un rectangulo,
garantizando que esta en forma canonica:
</p>

<div class="org-src-container">
<pre class="src src-c"><span style="color: #b0c4de;">#define</span> <span style="color: #87cefa;">min</span>(<span style="color: #eedd82;">a</span>, <span style="color: #eedd82;">b</span>) ((a) &lt; (b) ? (a) : (b))
<span style="color: #b0c4de;">#define</span> <span style="color: #87cefa;">max</span>(<span style="color: #eedd82;">a</span>, <span style="color: #eedd82;">b</span>) ((a) &gt; (b) ? (a) : (b))

<span style="color: #ff4500;">/* </span><span style="color: #ff4500;">canonrect: pone en forma canonica las coordenadas de un rectangulo </span><span style="color: #ff4500;">*/</span>
<span style="color: #00ffff;">struct</span> <span style="color: #98fb98;">rect</span> <span style="color: #87cefa;">canonrect</span>(<span style="color: #00ffff;">struct</span> <span style="color: #98fb98;">rect</span> <span style="color: #eedd82;">r</span>)
{
  <span style="color: #00ffff;">struct</span> <span style="color: #98fb98;">rect</span> <span style="color: #eedd82;">temp</span>;

  temp.pt1.x = min(r.pt1.x, r.pt2.x);
  temp.pt1.y = min(r.pt1.y, r.pt2.y);
  temp.pt2.x = max(r.pt1.x; r.pt2.x);
  temp.pt2.y = max(r.pt1.y, r.pt2.y);
  <span style="color: #00ffff;">return</span> temp;
}
</pre>
</div>

<p>
Si una estructura grande va a ser pasada a una funcion,
generalmente es mas eficiente pasar un apuntador que copiar la
estructura completa. Los apuntadores a estructuras son como los
apuntadores a variables ordinarias. La declaracion
</p>

<div class="org-src-container">
<pre class="src src-c"><span style="color: #00ffff;">struct</span> <span style="color: #98fb98;">point</span> *<span style="color: #eedd82;">pp</span>;
</pre>
</div>

<p>
dice que <code>pp</code> es un apuntador a una estructura de tipo <code>struct
   point</code>. Si <code>pp</code> apunta a una estructura <code>point</code>, <code>*pp</code> es la
estructura, y <code>(*pp).x</code> y <code>(*pp).y</code> son los miembros. Para emplear
<code>pp</code>, se podria escribir, por ejemplo,
</p>

<div class="org-src-container">
<pre class="src src-c"><span style="color: #00ffff;">struct</span> <span style="color: #98fb98;">point</span> <span style="color: #eedd82;">origin</span>, *<span style="color: #eedd82;">pp</span>;

pp = &amp;origin;
printf(<span style="color: #ffa07a;">"origin is (%d,%d)\n"</span>, (*pp).x, (*pp).y);
</pre>
</div>

<p>
Los parentesis son necesarios en <code>(*pp).x</code> debido a que la
precedencia del operador miembro de estructura <code>.</code> es mayor que la
de <code>*</code>. La expresion <code>*pp.x</code> significa <code>*(pp.x)</code>, lo cual es ilegal
debido a que <code>x</code> no es un apuntador.
</p>

<p>
Los apuntadores a estructuras se usan con tanta frecuencia que se
ha proporcionado una notacion alternativa como abreviacion. Si <code>p</code>
es un apuntador a estructura, entonces
</p>

<div class="org-src-container">
<pre class="src src-c">p-&gt;miembro-de-estructura
</pre>
</div>

<p>
se refiere al miembro en particular. (El operador <code>-&gt;</code> es un signo
<code>-</code> (menos) seguido inmediatamente por <code>&gt;</code>.) De esta manera
podriamos haber escrito
</p>

<div class="org-src-container">
<pre class="src src-c">printf(<span style="color: #ffa07a;">"el origen es (%d,%d)\n"</span>, pp-&gt;x, pp-&gt;y);
</pre>
</div>

<p>
Tanto <code>.</code> como <code>-&gt;</code> se asocian de izquierda a derecha, de modo que
si tenemos
</p>

<div class="org-src-container">
<pre class="src src-c"><span style="color: #00ffff;">struct</span> <span style="color: #98fb98;">rect</span> <span style="color: #eedd82;">r</span>, *<span style="color: #eedd82;">rp</span> = &amp;r;
</pre>
</div>

<p>
entonces estas cuatro expresiones son equivalentes:
</p>

<div class="org-src-container">
<pre class="src src-c">r.pt1.x
rp-&gt;pt1.x
(r.pt1).x
(rp-&gt;pt1).x
</pre>
</div>

<p>
Los operadores de estructuras <code>.</code> y <code>-&gt;</code>, junto con <code>()</code> para
llamadas a funciones y <code>[]</code> para subindices, estan hasta arriba de
la jerarquia de precedencias y se asocian estrechamente. Por
ejemplo, dada la declaracion
</p>

<div class="org-src-container">
<pre class="src src-c"><span style="color: #00ffff;">struct</span> {
  <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">len</span>;
  <span style="color: #98fb98;">char</span> *<span style="color: #eedd82;">str</span>;
} *<span style="color: #eedd82;">p</span>;
</pre>
</div>

<p>
entonces
</p>

<div class="org-src-container">
<pre class="src src-c">++p-&gt;len
</pre>
</div>

<p>
incrementa a <code>len</code>, no a <code>p</code>, puesto que los parentesis implicitos
son <code>++(p-&gt;len)</code>. Los parentesis se pueden emplear para alterar la
asociacion: <code>(++p)-&gt;len</code> incrementa a <code>p</code> antes de tener acceso a
<code>len</code>, y <code>(p++)-&gt;len</code> incrementa a <code>p</code> despues del acceso. (Este
ultimo conjunto de parentesis es innecesario.)
</p>

<p>
De la misma manera, <code>*p-&gt;str</code> obtiene cualquier cosa a la que <code>str</code>
apunte; <code>*p-&gt;str++</code> incrementa a <code>str</code> despues de hacer el acceso a
lo que apunta (exactamente como <code>*s++</code>); <code>(*p-&gt;str)++</code> incrementa
cualquier cosa a la que <code>str</code> apunte; y <code>*p++-&gt;str</code> incrementa a p
despues de hacer el acceso a lo que <code>str</code> apunta.
</p>
</div>
</div>

<div id="outline-container-orgc12116e" class="outline-3">
<h3 id="orgc12116e">6.3  Arreglos de estructuras                                       <a id="org4309e7d"></a></h3>
<div class="outline-text-3" id="text-orgc12116e">
<p>
Considerese escribir un programa para contar las ocurrencias de
cada palabra reservada de C. Se requiere de un arreglo de cadenas
de caracteres para mantener los nombres, y un arreglo de enteros
para las cuentas. Una posibilidad es usar dos arreglos paralelos,
keyword y keyconunt, como en
</p>

<div class="org-src-container">
<pre class="src src-c"><span style="color: #98fb98;">char</span> *<span style="color: #eedd82;">keyword</span>[NKEYS];
<span style="color: #98fb98;">int</span> <span style="color: #eedd82;">keycount</span>[NKEYS];
</pre>
</div>

<p>
pero el hecho de que los arreglos sean paralelos sugiere una
organizacion diferente, un arreglo de estructuras. Cada entrada
de una palabra es una pareja:
</p>

<div class="org-src-container">
<pre class="src src-c"><span style="color: #98fb98;">char</span> *<span style="color: #eedd82;">word</span>;
<span style="color: #98fb98;">int</span> <span style="color: #eedd82;">count</span>;
</pre>
</div>

<p>
y hay un arreglo de parejas. La declaracion de estructura
</p>

<div class="org-src-container">
<pre class="src src-c"><span style="color: #00ffff;">struct</span> <span style="color: #98fb98;">key</span> {
  <span style="color: #98fb98;">char</span> *<span style="color: #eedd82;">word</span>;
  <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">count</span>;
} <span style="color: #eedd82;">keytab</span>[NKEYS];
</pre>
</div>

<p>
declara un tipo de estructura <code>key</code>, define un arreglo <code>keytab</code> de
estructuras de ese tipo, y reserva espacio de almacenamiento para
ellas. Cada elemento del arreglo es una estructura. Esto tambien se
podria escribir como
</p>

<div class="org-src-container">
<pre class="src src-c"><span style="color: #00ffff;">struct</span> <span style="color: #98fb98;">key</span> {
  <span style="color: #98fb98;">char</span> *<span style="color: #eedd82;">word</span>;
  <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">count</span>;
};

<span style="color: #00ffff;">struct</span> <span style="color: #98fb98;">key</span> <span style="color: #eedd82;">keytab</span>[NKEYS];
</pre>
</div>

<p>
Como la estructura <code>keytab</code> contiene un conjunto constante de
nombres, es mas facil convertirla en una variable externa e
inicializarla de una vez cuando se define. La inicializacion de la
estructura es analoga a otras anteriores – la definicion es seguida
por una lista de inicializadores entre llaves:
</p>

<div class="org-src-container">
<pre class="src src-c"><span style="color: #00ffff;">struct</span> <span style="color: #98fb98;">key</span> {
  <span style="color: #98fb98;">char</span> *<span style="color: #eedd82;">word</span>;
  <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">count</span>;
} <span style="color: #eedd82;">keytab</span>[] = {
  <span style="color: #ffa07a;">"auto"</span>, 0,
  <span style="color: #ffa07a;">"break"</span>, 0,
  <span style="color: #ffa07a;">"case"</span>, 0,
  <span style="color: #ffa07a;">"char"</span>, 0,
  <span style="color: #ffa07a;">"const"</span>, 0,
  <span style="color: #ffa07a;">"continue"</span>, 0,
  <span style="color: #ffa07a;">"default"</span>, 0,
  <span style="color: #ff4500;">/* </span><span style="color: #ff4500;">... </span><span style="color: #ff4500;">*/</span>
  <span style="color: #ffa07a;">"unsigned"</span>, 0,
  <span style="color: #ffa07a;">"void"</span>, 0,
  <span style="color: #ffa07a;">"volatile"</span>, 0,
  <span style="color: #ffa07a;">"while"</span>, 0
};
</pre>
</div>

<p>
Los inicializadores se listan en parejas correspondientes a los
miembros de las estructuras. Podria ser mas preciso encerrar los
inicializadores para cada "renglon" o estructura entre llaves, como
en
</p>

<div class="org-src-container">
<pre class="src src-c">{ <span style="color: #ffa07a;">"auto"</span>, 0 },
{ <span style="color: #ffa07a;">"break"</span>, 0 },
{ <span style="color: #ffa07a;">"case"</span>, 0 },
...
</pre>
</div>

<p>
pero las llaves internas no son necesarias cuando los
inicializadores son variables simples o cadenas de caracteres, y
cuando todos estan presentes. Como es usual, el numero de entradas
en el arreglo <code>keytab</code> se calculara si los inicializadores estan
presentes y el <code>[]</code> se deja vacio.
</p>

<p>
El programa que cuenta palabras reservadas inicia con la definicion
de <code>keytab</code>. La rutina principal lee de la entrada con llamadas
repetidas a la funcion <code>getword</code>, que trae una palabra a la
vez. Cada palabra se consulta en <code>keytab</code> con una version de la
funcion de busqueda binaria que se escribio en el <a href="#org35eee87">capitulo 3</a>. La
lista de palabras reservadas debe estar ordenada en forma
ascendente en la tabla.
</p>

<div class="org-src-container">
<pre class="src src-c"><span style="color: #b0c4de;">#include</span> <span style="color: #ffa07a;">&lt;stdio.h&gt;</span>
<span style="color: #b0c4de;">#include</span> <span style="color: #ffa07a;">&lt;ctype.h&gt;</span>
<span style="color: #b0c4de;">#include</span> <span style="color: #ffa07a;">&lt;string.h&gt;</span>

<span style="color: #b0c4de;">#define</span> <span style="color: #eedd82;">MAXWORD</span> 100

<span style="color: #98fb98;">int</span> <span style="color: #87cefa;">getword</span>(<span style="color: #98fb98;">char</span> *, <span style="color: #98fb98;">int</span>);
<span style="color: #98fb98;">int</span> <span style="color: #87cefa;">binsearch</span>(<span style="color: #98fb98;">char</span> *, <span style="color: #00ffff;">struct</span> <span style="color: #98fb98;">key</span> *, <span style="color: #98fb98;">int</span>);

<span style="color: #ff4500;">/* </span><span style="color: #ff4500;">cuenta palabras reservadas de C </span><span style="color: #ff4500;">*/</span>
<span style="color: #87cefa;">main</span>()
{
  <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">n</span>;
  <span style="color: #98fb98;">char</span> <span style="color: #eedd82;">word</span>[MAXWORD];

  <span style="color: #00ffff;">while</span> (getword(word, MAXWORD) != EOF)
    <span style="color: #00ffff;">if</span> (isalpha(word[0]))
      <span style="color: #00ffff;">if</span> ((n = binsearch(word, keytab, NKEYS)) &gt;= 0)
        keytab[n].count++;
  <span style="color: #00ffff;">for</span> (n = 0; n &lt; NKEYS; n++)
    <span style="color: #00ffff;">if</span> (keytab[n].count &gt; 0)
      printf(<span style="color: #ffa07a;">"%4d %s\n"</span>, keytab[n].count, keytab[n].word);
  <span style="color: #00ffff;">return</span> 0;
}

<span style="color: #ff4500;">/* </span><span style="color: #ff4500;">binsearch: encuentra una palabra en tab[ 0 ]. . .tab[ n-1 ] </span><span style="color: #ff4500;">*/</span>
<span style="color: #98fb98;">int</span> <span style="color: #87cefa;">binsearch</span>(<span style="color: #98fb98;">char</span> *<span style="color: #eedd82;">word</span>, <span style="color: #00ffff;">struct</span> <span style="color: #98fb98;">key</span> <span style="color: #eedd82;">tab</span>[], <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">n</span>)
{
  <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">cond</span>;
  <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">low</span>, <span style="color: #eedd82;">high</span>, <span style="color: #eedd82;">mid</span>;

  low = 0;
  high = n - 1;
  <span style="color: #00ffff;">while</span> (low &lt;= high) {
    mid = (low+high) / 2;
    <span style="color: #00ffff;">if</span> ((cond = strcmp(word, tab[mid].word)) &lt; 0)
      high = mid - 1;
    <span style="color: #00ffff;">else</span> <span style="color: #00ffff;">if</span> (cond &gt; 0)
      low = mid + 1;
    <span style="color: #00ffff;">else</span>
      <span style="color: #00ffff;">return</span> mid;
  }
  <span style="color: #00ffff;">return</span> -1;
}
</pre>
</div>

<p>
Mostraremos la funcion <code>getword</code> en un momento; por ahora es
suficiente decir que cada llamada a <code>getword</code> encuentra una
palabra, que se copia dentro del arreglo referido como su primer
argumento.
</p>

<p>
La cantidad <code>NKEYS</code> es el numero de palabras en <code>keytab</code>. Aunque
las podriamos contar manualmente, es mucho mas facil y seguro que
lo haga la maquina, especialmente si la lista esta sujeta a
cambios. Una posibilidad seria terminar la lista de inicializadores
con un apuntador nulo y luego hacer un ciclo a lo largo de <code>keytab</code>
hasta que se encuentra el fin.
</p>

<p>
Pero esto es mas de lo que se requiere, puesto que el tamaño del
arreglo esta determinado completamente al tiempo de compilacion. El
tamaño del arreglo es el tamaño de una entrada multiplicado por el
numero de entradas, asi que el numero de entradas es
</p>

<div class="org-src-container">
<pre class="src src-c">size <span style="color: #98fb98;">of</span> <span style="color: #eedd82;">keytab</span> / size of <span style="color: #00ffff;">struct</span> key
</pre>
</div>

<p>
C proporciona un operador unario a tiempo de compilacion llamado
<code>sizeof</code> que se puede emplear para calcular el tamaño de cualquier
objeto. Las expresiones
</p>

<div class="org-src-container">
<pre class="src src-c"><span style="color: #00ffff;">sizeof</span> objeto
</pre>
</div>

<p>
y
</p>

<div class="org-src-container">
<pre class="src src-c"><span style="color: #00ffff;">sizeof</span> (nombre <span style="color: #98fb98;">de</span> <span style="color: #eedd82;">tipo</span>)
</pre>
</div>

<p>
dan un entero igual al tamaño en bytes del tipo u objeto
especificado. (Estrictamente, <code>sizeof</code> produce un valor entero sin
signo cuyo tipo, <code>size_t</code>, esta definido en el header
<code>&lt;stddef.h&gt;</code>.) Un objeto puede ser una variable, arreglo o
estructura. Un nombre de tipo puede ser el nombre de un tipo basico
como <code>int</code> o <code>double</code> o un tipo derivado como una estructura o un
apuntador.
</p>

<p>
En nuestro caso, el numero de palabras es el tamaño del arreglo
dividido entre el tamaño de un elemento. Este calculo se utiliza en
una proposicion <code>#define</code> para fijar el valor de <code>NKEYS</code>:
</p>

<div class="org-src-container">
<pre class="src src-c"><span style="color: #b0c4de;">#define</span> <span style="color: #eedd82;">NKEYS</span> (<span style="color: #00ffff;">sizeof</span> keytab / <span style="color: #00ffff;">sizeof</span>(<span style="color: #00ffff;">struct</span> <span style="color: #98fb98;">key</span>))
</pre>
</div>

<p>
Otra forma de escribir esto es dividir el tamaño del arreglo entre
el tamaño de un elemento especifico:
</p>

<div class="org-src-container">
<pre class="src src-c"><span style="color: #b0c4de;">#define</span> <span style="color: #eedd82;">NKEYS</span> (<span style="color: #00ffff;">sizeof</span> keytab / <span style="color: #00ffff;">sizeof</span> keytab[0])
</pre>
</div>

<p>
Esto tiene la ventaja de que no necesita ser modificado si el tipo
cambia.
</p>

<p>
Un <code>sizeof</code> no se puede utilizar en una linea <code>#if</code>, debido a que
el preprocesador no analiza nombres de tipos. Pero la expresion del
<code>#define</code> no es evaluada por el preprocesador, y aqui el codigo es
legal.
</p>

<p>
Ahora la funcion <code>getword</code>. Hemos escrito una funcion <code>getword</code> mas
general de lo que se requiere para este programa, pero no es
complicada, <code>getword</code> obtiene la siguiente "palabra" de la entrada,
donde una palabra es cualquier cadena de letras y digitos que
principia con una letra, o un solo caracter que no sea espacio en
blanco. El valor de la funcion es el primer caracter de la palabra,
o <code>EOF</code> para fin de archivo, o el caracter en si mismo cuando no es
alfabetico.
</p>

<div class="org-src-container">
<pre class="src src-c"><span style="color: #ff4500;">/* </span><span style="color: #ff4500;">getword: obtiene la siguiente palabra o caracter de la entrada </span><span style="color: #ff4500;">*/</span>
<span style="color: #98fb98;">int</span> <span style="color: #87cefa;">getword</span>(<span style="color: #98fb98;">char</span> *<span style="color: #eedd82;">word</span>, <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">lim</span>)
{
  <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">c</span>, <span style="color: #87cefa;">getch</span>(<span style="color: #98fb98;">void</span>);
  <span style="color: #98fb98;">void</span> <span style="color: #87cefa;">ungetch</span>(<span style="color: #98fb98;">int</span>);
  <span style="color: #98fb98;">char</span> *<span style="color: #eedd82;">w</span> = word;

  <span style="color: #00ffff;">while</span> (isspace(c = getch()))
    ;
  <span style="color: #00ffff;">if</span> (c != EOF)
    *w++ = c;
  <span style="color: #00ffff;">if</span> (!isalpha(c)) {
    *w = <span style="color: #ffa07a;">'\0'</span>;
    <span style="color: #00ffff;">return</span> c;
  }
  <span style="color: #00ffff;">for</span> ( ; --lim &gt; 0; w++)
    <span style="color: #00ffff;">if</span> (!isalnum(*w = getch())) {
      ungetch(*w);
      <span style="color: #00ffff;">break</span>;
    }
  *w = <span style="color: #ffa07a;">'\0'</span>;
  <span style="color: #00ffff;">return</span> word[0];
}
</pre>
</div>

<p>
<code>getword</code> utiliza <code>getch</code> y <code>ungetch</code>, que se escribieron en el
<a href="#org05a38fc">capitulo 4</a>. Cuando la recoleccion de un simbolo alfanumerico se
detiene, <code>getword</code> se ha colocado un caracter adelante. La llamada
a <code>ungetch</code> regresa el caracter a la entrada para la siguiente
llamada, <code>getword</code> tambien usa <code>isspace</code> para ignorar espacios en
blanco, <code>isalpha</code> para identificar letras, e <code>isalnum</code> para
identificar letras y digitos; todas provienen del header estandar
<code>&lt;ctype.h&gt;</code>.
</p>

<p>
<b>Ejercicio 6-1</b>. Nuestra version de <code>getword</code> no maneja adecuadamente
las subrayas, cadenas constantes, comentarios o lineas de control
para el preprocesador.  Escriba una version mejorada.
</p>
</div>
</div>

<div id="outline-container-org7220a24" class="outline-3">
<h3 id="org7220a24">6.4  Apuntadores a estructuras                                     <a id="org9a8f9e2"></a></h3>
<div class="outline-text-3" id="text-org7220a24">
<p>
Para ilustrar algunas de las consideraciones involucradas con
apuntadores y arreglos de estructuras, escribamos de nuevo el
programa de conteo de palabras reservadas, esta vez utilizando
apuntadores en lugar de subindices.
</p>

<p>
La declaracion externa de <code>keytab</code> no requiere de cambios, pero
<code>main</code> y <code>binsearch</code> si necesitan modificaciones.
</p>

<div class="org-src-container">
<pre class="src src-c"><span style="color: #b0c4de;">#include</span> <span style="color: #ffa07a;">&lt;stdio.h&gt;</span>
<span style="color: #b0c4de;">#include</span> <span style="color: #ffa07a;">&lt;ctype.h&gt;</span>
<span style="color: #b0c4de;">#include</span> <span style="color: #ffa07a;">&lt;string.h&gt;</span>

<span style="color: #b0c4de;">#define</span> <span style="color: #eedd82;">MAXWORD</span> 100

<span style="color: #98fb98;">int</span> <span style="color: #87cefa;">getword</span>(<span style="color: #98fb98;">char</span> *, <span style="color: #98fb98;">int</span>);
<span style="color: #00ffff;">struct</span> <span style="color: #98fb98;">key</span> *<span style="color: #87cefa;">binsearch</span>(<span style="color: #98fb98;">char</span> *, <span style="color: #00ffff;">struct</span> <span style="color: #98fb98;">key</span> *, <span style="color: #98fb98;">int</span>);

<span style="color: #ff4500;">/* </span><span style="color: #ff4500;">cuenta palabras reservadas de C; version con apuntadores </span><span style="color: #ff4500;">*/</span>
<span style="color: #87cefa;">main</span>()
{
  <span style="color: #98fb98;">char</span> <span style="color: #eedd82;">word</span>[MAXWORD];
  <span style="color: #00ffff;">struct</span> <span style="color: #98fb98;">key</span> *<span style="color: #eedd82;">p</span>;

  <span style="color: #00ffff;">while</span> (getword(word, MAXWORD) != EOF)
    <span style="color: #00ffff;">if</span> (isalpha(word[0]))
      <span style="color: #00ffff;">if</span> ((p=binsearch(word, keytab, NKEYS)) != <span style="color: #7fffd4;">NULL</span>)
        p-&gt;count++;
  <span style="color: #00ffff;">for</span> (p = keytab; p &lt; keytab + NKEYS; p++)
    <span style="color: #00ffff;">if</span> (p-&gt;count &gt; 0)
      printf(<span style="color: #ffa07a;">"%4d %s\n"</span>, p-&gt;count, p-&gt;word);
  <span style="color: #00ffff;">return</span> 0;
}

<span style="color: #ff4500;">/* </span><span style="color: #ff4500;">binsearch: encuentra una palabra en tab[0]...tab[n-1] </span><span style="color: #ff4500;">*/</span>
<span style="color: #00ffff;">struct</span> <span style="color: #98fb98;">key</span> *<span style="color: #87cefa;">binsearch</span>(<span style="color: #98fb98;">char</span> *<span style="color: #eedd82;">word</span>, struck <span style="color: #98fb98;">key</span> *<span style="color: #eedd82;">tab</span>, <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">n</span>)
{
  <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">cond</span>;
  <span style="color: #00ffff;">struct</span> <span style="color: #98fb98;">key</span> *<span style="color: #eedd82;">low</span> = &amp;tab[0];
  <span style="color: #00ffff;">struct</span> <span style="color: #98fb98;">key</span> *<span style="color: #eedd82;">high</span> = &amp;tab[n];
  <span style="color: #00ffff;">struct</span> <span style="color: #98fb98;">key</span> *<span style="color: #eedd82;">mid</span>;

  <span style="color: #00ffff;">while</span> (low &lt; high) {
    mid = low + (high-low) / 2;
    <span style="color: #00ffff;">if</span> ((cond = strcmp(word, mid-&gt;word)) &lt; 0)
      high = mid;
    <span style="color: #00ffff;">else</span> <span style="color: #00ffff;">if</span> (cond &gt; 0)
      low = mid + 1;
    <span style="color: #00ffff;">else</span>
      <span style="color: #00ffff;">return</span> mid;
  }
  <span style="color: #00ffff;">return</span> <span style="color: #7fffd4;">NULL</span>;
}
</pre>
</div>

<p>
Aqui hay varias cosas que ameritan nota. Primero, la declaracion de
<code>binsearch</code> debe indicar que regresa un apuntador a <code>struct key</code> en
lugar de un entero; esto se declara tanto en el prototipo de la
funcion como en <code>binsearch</code>. Si <code>binsearch</code> encuentra la palabra,
regresa un apuntador a ella; si no, regresa <code>NULL</code>.
</p>

<p>
Segundo, ahora se tiene acceso a los elementos de <code>keytab</code> por
medio de apuntadores. Esto requiere de cambios significativos en
<code>binsearch</code>.
</p>

<p>
Los inicializadores para <code>low</code> y <code>high</code> son ahora apuntadores al
inicio y justo despues del final de la tabla.
</p>

<p>
El calculo del elemento intermedio ya no puede ser simplemente
</p>

<div class="org-src-container">
<pre class="src src-c">mid = (low + high) / 2 <span style="color: #ff4500;">/* </span><span style="color: #ff4500;">INCORRECTO </span><span style="color: #ff4500;">*/</span>
</pre>
</div>

<p>
puesto que la suma de dos apuntadores es ilegal. Sin embargo, la
resta es legitima, por lo que <code>high - low</code> es el numero de
elementos, y asi
</p>

<div class="org-src-container">
<pre class="src src-c">mid = low + (high - low) / 2
</pre>
</div>

<p>
hace que <code>mid</code> apunte al elemento que esta a la mitad entre <code>low</code> y
<code>high</code>.
</p>

<p>
El cambio mas importante es ajustar el algoritmo para estar seguros
de que no genera un apuntador ilegal o intenta hacer acceso a un
elemento fuera del arreglo. El problema es que <code>&amp;tab[-1]</code> y
<code>&amp;tab[n]</code> estan ambas fuera de los limites del arreglo <code>tab</code>. La
primera es estrictamente ilegal, y es ilegal desreferenciar la
segunda. Sin embargo, la definicion del lenguaje garantiza que la
aritmetica de apuntadores que involucra el primer elemento despues
del fin de un arreglo (esto es, <code>&amp;tab[n]</code> trabajara correctamente.
</p>

<p>
En <code>main</code> escribimos
</p>

<div class="org-src-container">
<pre class="src src-c"><span style="color: #00ffff;">for</span>( p = keytab; p &lt; keytab + NKEYS; p++ )
</pre>
</div>

<p>
Si <code>p</code> es un apuntador a una estructura, la aritmetica con <code>p</code> toma
en cuenta el tamaño de la estructura, asi que <code>p++</code> incrementa <code>p</code>
con la cantidad correcta para obtener el siguiente elemento del
arreglo de estructuras, y la prueba detiene el ciclo en el momento
correcto.
</p>

<p>
Sin embargo, no hay que suponer que el tamaño de una estructura es
la suma de los tamaños de sus miembros. Debido a requisitos de
alineacion para diferentes objetos, podria haber "huecos" no
identificados dentro de una estructura. Asi por ejemplo, si un
<code>char</code> es de un byte y un <code>int</code> de cuatro bytes, la estructura
</p>

<div class="org-src-container">
<pre class="src src-c"><span style="color: #00ffff;">struct</span> {
  <span style="color: #98fb98;">char</span> <span style="color: #eedd82;">c</span>;
  <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">i</span>;
};
</pre>
</div>

<p>
bien podria requerir ocho bytes, no cinco. El operador <code>sizeof</code>
regresa el valor apropiado.
</p>

<p>
Finalmente, un comentario acerca del formato del programa: cuando
una funcion regresa un tipo complicado como un apuntador a
estructura, como en
</p>

<div class="org-src-container">
<pre class="src src-c"><span style="color: #00ffff;">struct</span> <span style="color: #98fb98;">key</span> *<span style="color: #87cefa;">binsearch</span>(<span style="color: #98fb98;">char</span> *<span style="color: #eedd82;">word</span>, <span style="color: #00ffff;">struct</span> <span style="color: #98fb98;">key</span> *<span style="color: #eedd82;">tab</span>, <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">n</span>)
</pre>
</div>

<p>
el nombre de la funcion puede ser dificil de leer y de encontrar
con un editor de texto. Por eso, algunas veces se emplea un estilo
alternativo:
</p>

<div class="org-src-container">
<pre class="src src-c"><span style="color: #00ffff;">struct</span> <span style="color: #98fb98;">key</span> *
<span style="color: #87cefa;">binsearch</span>(<span style="color: #98fb98;">char</span> *<span style="color: #eedd82;">word</span>, <span style="color: #00ffff;">struct</span> <span style="color: #98fb98;">key</span> *<span style="color: #eedd82;">tab</span>, <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">n</span>)
</pre>
</div>

<p>
Esto es algo de gusto personal; seleccione la forma que prefiera y
mantengala.
</p>
</div>
</div>

<div id="outline-container-org053695b" class="outline-3">
<h3 id="org053695b">6.5  Estructuras autorreferenciadas                                <a id="org2b6b892"></a></h3>
<div class="outline-text-3" id="text-org053695b">
<p>
Supongase que deseamos manejar el problema mas general de contar
las ocurrencias de <i>todas</i> las palabras en alguna entrada. Como la
lista de palabras no se conoce por anticipado, no podemos
ordenarlas convenientemente y utilizar una busqueda binaria. No
podemos hacer una busqueda lineal para cada palabra que para ver si
ya se ha visto, puesto que el programa tomaria demasiado tiempo.
(En forma mas precisa, su tiempo de ejecucion tiende a crecer en
proporcion cuadratica con el numero de palabras de entrada.) ¿Como
podemos organizar los datos para tratar eficientemente una lista de
palabras arbitrarias?
</p>

<p>
Una solucion es mantener siempre ordenado el conjunto de palabras
que ya se han visto, colocando cada una en su posicion correcta
cuando llega. Esto, de cualquier manera, no se podria realizar
recorriendo las palabras en un arreglo lineal – tambien tomado
demasiado tiempo. En lugar de ello utilizaremos una estructura de
datos llamada <i>arbol binario</i>.
</p>

<p>
El arbol contiene un "nodo" por cada palabra distinta; cada nodo
contiene
</p>

<ul class="org-ul">
<li>un apuntador al texto de la palabra</li>

<li>una cuenta del numero de ocurrencias</li>

<li>un apuntador al nodo hijo de la izquierda</li>

<li>un apuntador al nodo hijo de la derecha</li>
</ul>


<p>
Los nodos se mantienen de tal manera que en cualquier nodo el
subarbol izquierdo contiene solo palabras que son
lexicograficamente menores que la palabra que esta en el nodo, y el
subarbol de la derecha solo contiene palabras que son mayores. Este
es el arbol para la oracion "Es tiempo de que todos los hombres
buenos vengan al auxilio de su partido", como se construyo al
insertar cada palabra tal como fue encontrada.
</p>

<p>
Ningun nodo puede tener mas de dos hijos; solo puede tener cero o
uno.
</p>


<div class="figure">
<p><img src="img/img_06.05.png" alt="img_06.05.png" />
</p>
</div>

<p>
Para descubrir si una nueva palabra ya esta en el arbol, inicie en
la raiz y comparela con la que esta almacenada en ese nodo. Si
coincide, la pregunta se responde afirmativamente. Si la nueva
palabra es menor que la palabra del arbol, continue buscando en el
nodo hijo de la izquierda o, de otra manera, en el nodo hijo de la
derecha. Si ya no hay un hijo en la direccion requerida, la palabra
nueva no esta en el arbol, y de hecho la entrada vacia es el lugar
apropiado para agregar la palabra nueva. Este proceso es recursivo,
ya que la busqueda desde cualquier nodo emplea una busqueda desde
uno de sus hijos. Por ello, unas rutinas recursivas para insercion
e impresion seran lo mas natural.
</p>

<p>
Regresando a la descripcion de un nodo, se representa
convenientemente como una estructura con cuatro componentes:
</p>

<div class="org-src-container">
<pre class="src src-c"><span style="color: #00ffff;">struct</span> <span style="color: #98fb98;">tnode</span> {                   <span style="color: #ff4500;">/* </span><span style="color: #ff4500;">el nodo del arbol:    </span><span style="color: #ff4500;">*/</span>
  <span style="color: #98fb98;">char</span> *<span style="color: #eedd82;">word</span>;                    <span style="color: #ff4500;">/* </span><span style="color: #ff4500;">apunta hacia el texto </span><span style="color: #ff4500;">*/</span>
  <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">count</span>;                     <span style="color: #ff4500;">/* </span><span style="color: #ff4500;">numero de ocurrencias </span><span style="color: #ff4500;">*/</span>
  <span style="color: #00ffff;">struct</span> <span style="color: #98fb98;">tnode</span> *<span style="color: #eedd82;">left</span>;            <span style="color: #ff4500;">/* </span><span style="color: #ff4500;">hijo a la izquierda   </span><span style="color: #ff4500;">*/</span>
  <span style="color: #00ffff;">struct</span> <span style="color: #98fb98;">tnode</span> *<span style="color: #eedd82;">right</span>;           <span style="color: #ff4500;">/* </span><span style="color: #ff4500;">hijo a la derecha     </span><span style="color: #ff4500;">*/</span>
};
</pre>
</div>

<p>
Esta declaracion recursiva de un nodo podria parecer riesgosa, pero
es correcta. Es ilegal que una estructura contenga una instancia de
si misma, pero
</p>

<div class="org-src-container">
<pre class="src src-c"><span style="color: #00ffff;">struct</span> <span style="color: #98fb98;">tnode</span> *<span style="color: #eedd82;">left</span>;
</pre>
</div>

<p>
declara a <code>left</code> como un apuntador a <code>tnode</code>, no como un <code>tnode</code> en
si.
</p>

<p>
Ocasionalmente, se requiere de una variacion de estructuras
autorreferenciadas: dos estructuras que hagan referencia una a la
otra. La forma de manejar esto es:
</p>

<div class="org-src-container">
<pre class="src src-c"><span style="color: #00ffff;">struct</span> <span style="color: #98fb98;">t</span> {
  ...
  <span style="color: #00ffff;">struct</span> s *p; <span style="color: #ff4500;">/* </span><span style="color: #ff4500;">p apunta a una s </span><span style="color: #ff4500;">*/</span>
};
<span style="color: #00ffff;">struct</span> <span style="color: #98fb98;">s</span> {
  ...
  <span style="color: #00ffff;">struct</span> t *q; <span style="color: #ff4500;">/* </span><span style="color: #ff4500;">q apunta a una t </span><span style="color: #ff4500;">*/</span>
};
</pre>
</div>

<p>
El codigo de todo el programa es sorprendentemente pequeño, dado un
numero de rutinas de soporte, como <code>getword</code>, que ya hemos
descrito. La rutina principal lee palabras con <code>getword</code> y las
instala en el arbol con <code>addtree</code>
</p>

<div class="org-src-container">
<pre class="src src-c"><span style="color: #b0c4de;">#include</span> <span style="color: #ffa07a;">&lt;stdio.h&gt;</span>
<span style="color: #b0c4de;">#include</span> <span style="color: #ffa07a;">&lt;ctype.h&gt;</span>
<span style="color: #b0c4de;">#include</span> <span style="color: #ffa07a;">&lt;string.h&gt;</span>

<span style="color: #b0c4de;">#define</span> <span style="color: #eedd82;">MAXWORD</span> 100
<span style="color: #00ffff;">struct</span> <span style="color: #98fb98;">tnode</span> *<span style="color: #87cefa;">addtree</span>(<span style="color: #00ffff;">struct</span> <span style="color: #98fb98;">tnode</span> *, <span style="color: #98fb98;">char</span> *);
<span style="color: #98fb98;">void</span> <span style="color: #87cefa;">treeprint</span>(<span style="color: #00ffff;">struct</span> <span style="color: #98fb98;">tnode</span> *);
<span style="color: #98fb98;">int</span> <span style="color: #87cefa;">getword</span>(<span style="color: #98fb98;">char</span> *, <span style="color: #98fb98;">int</span>);

<span style="color: #ff4500;">/* </span><span style="color: #ff4500;">conteo de frecuencia de palabras </span><span style="color: #ff4500;">*/</span>
<span style="color: #87cefa;">main</span>()
{
  <span style="color: #00ffff;">struct</span> <span style="color: #98fb98;">tnode</span> *<span style="color: #eedd82;">root</span>;
  <span style="color: #98fb98;">char</span> <span style="color: #eedd82;">word</span>[MAXWORD];

  root = <span style="color: #7fffd4;">NULL</span>;
  <span style="color: #00ffff;">while</span> (getword(word, MAXWORD) != EOF)
    <span style="color: #00ffff;">if</span> (isalpha(word[0]))
      root = addtree(root, word);
  treeprint(root);
  <span style="color: #00ffff;">return</span> 0;
}
</pre>
</div>

<p>
La funcion <code>addtree</code> es recursiva, <code>main</code> presenta una palabra al
nivel superior del arbol (la raiz). En cada etapa, la palabra se
compara con la que ya esta almacenada en el nodo, y se filtra
bajando hacia el subarbol izquierdo o derecho con una llamada
recursiva a <code>addtree</code>. Finalmente la palabra coincidira con algo
que ya esta en el arbol (en cuyo caso la cuenta se incrementa), o
se encuentra un apuntador nulo, indicando que se debe crear un nodo
y agregarlo al arbol. Si se crea un nuevo nodo, <code>addtree</code> regresa
un apuntador a el, y lo instala en el nodo padre.
</p>

<div class="org-src-container">
<pre class="src src-c"><span style="color: #00ffff;">struct</span> <span style="color: #98fb98;">tnode</span> *<span style="color: #87cefa;">talloc</span>(<span style="color: #98fb98;">void</span>);
<span style="color: #98fb98;">char</span> *<span style="color: #87cefa;">strdup</span>(<span style="color: #98fb98;">char</span> *);

<span style="color: #ff4500;">/* </span><span style="color: #ff4500;">addtree: agrega un nodo con w, en o bajo p </span><span style="color: #ff4500;">*/</span>
<span style="color: #00ffff;">struct</span> <span style="color: #98fb98;">tnode</span> *<span style="color: #87cefa;">addtree</span>(<span style="color: #00ffff;">struct</span> <span style="color: #98fb98;">tnode</span> *<span style="color: #eedd82;">p</span>, <span style="color: #98fb98;">char</span> *<span style="color: #eedd82;">w</span>)
{
  <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">cond</span>;
  <span style="color: #00ffff;">if</span> (p == <span style="color: #7fffd4;">NULL</span>) {          <span style="color: #ff4500;">/* </span><span style="color: #ff4500;">llego una nueva palabra </span><span style="color: #ff4500;">*/</span>
    p = talloc();           <span style="color: #ff4500;">/* </span><span style="color: #ff4500;">crea un nuevo nodo      </span><span style="color: #ff4500;">*/</span>
    p-&gt;word = strdup(w);
    p-&gt;count = 1;
    p-&gt;left = p-&gt;right = <span style="color: #7fffd4;">NULL</span>;
  } <span style="color: #00ffff;">else</span> <span style="color: #00ffff;">if</span> ((cond = strcmp(w, p-&gt;word)) == 0)
    p-&gt;count++;             <span style="color: #ff4500;">/* </span><span style="color: #ff4500;">palabra repetida        </span><span style="color: #ff4500;">*/</span>
  <span style="color: #00ffff;">else</span> <span style="color: #00ffff;">if</span> (cond &lt; 0)        <span style="color: #ff4500;">/* </span><span style="color: #ff4500;">menor que el contenido del subarbol izquierdo </span><span style="color: #ff4500;">*/</span>
    p-&gt;left =  addtree(p-&gt;left,  w);
  <span style="color: #00ffff;">else</span>                      <span style="color: #ff4500;">/* </span><span style="color: #ff4500;">mayor que el contenido del subarbol derecho   </span><span style="color: #ff4500;">*/</span>
    p-&gt;right = addtree(p-&gt;right, w);
  <span style="color: #00ffff;">return</span> p;
}
</pre>
</div>

<p>
El espacio de almacenamiento para el nuevo nodo se obtiene con la
rutina <code>talloc</code>, la cual regresa un apuntador a un espacio libre
adecuado para mantener un nodo del arbol, y la nueva palabra se
copia a un lugar oculto con <code>strdup</code>. (Hablaremos de esas rutinas
en un momento.) La cuenta se inicializa y los dos hijos se hacen
nulos. Esta parte del codigo se ejecuta solo para las hojas del
arbol, cuando esta siendo agregado un nuevo nodo. Hemos omitido
(imprudencialmente) la revision de errores en los valores
regresados por <code>strdup</code> y <code>talloc</code>.
</p>

<p>
<code>treeprint</code> imprime el arbol en forma ordenada; para cada nodo
escribe el subarbol izquierdo (todas las palabras menores que
esta), despues la palabra en si, y posteriormente el subarbol
derecho (todas las palabras mayores). Si se siente inseguro sobre
la forma en que trabaja la recursion, simule la operacion de
<code>treeprint</code> sobre el arbol mostrado anteriormente.
</p>

<div class="org-src-container">
<pre class="src src-c"><span style="color: #ff4500;">/* </span><span style="color: #ff4500;">treeprint: impresion del arbol p en orden </span><span style="color: #ff4500;">*/</span>
<span style="color: #98fb98;">void</span> <span style="color: #87cefa;">treeprint</span>(<span style="color: #00ffff;">struct</span> <span style="color: #98fb98;">tnode</span> *<span style="color: #eedd82;">p</span>)
{
  <span style="color: #00ffff;">if</span> (p != <span style="color: #7fffd4;">NULL</span>) {
    treeprint(p-&gt;left);
    printf(<span style="color: #ffa07a;">"%4d %s\n"</span>, p-&gt;count, p-&gt;word);
    treeprint(p-&gt;right);
  }
}
</pre>
</div>

<p>
Una nota practica: si el arbol se "desbalancea" debido a que las
palabras no llegan en orden aleatorio, el tiempo de ejecucion puede
aumentar demasiado. En el peor de los casos, si las palabras ya
estan en orden, este programa realiza una costosa simulacion de
busqueda lineal. Existen generalizaciones del arbol binario que no
padecen de este comportamiento del peor caso, pero no las
describiremos aqui.
</p>

<p>
Antes de dejar este ejemplo, tambien es deseable una breve
exposicion sobre un problema relacionado con los asignadores de
memoria. Es claramente deseable que solo exista un asignador de
almacenamiento en un programa, aun cuando asigne diferentes clases
de objetos. Pero si un asignador va a procesar peticiones de,
digamos, apuntadores a <code>char</code> y apuntadores a <code>struct tnode</code>,
surgen dos preguntas. Primera, ¿como cumple los requisitos de la
mayor parte de las maquinas reales, de que los objetos de ciertos
tipos deben satisfacer restricciones de alineacion (por ejemplo,
generalmente los enteros deben ser situados en localidades pares)?
Segunda, ¿cuales declaraciones pueden tratar con el hecho de que un
asignador de memoria necesariamente debe regresar diferentes clases
de apuntadores?
</p>

<p>
Los requisitos de alineacion por lo general se pueden satisfacer
facilmente, al costo de algun espacio desperdiciado, asegurando que
el asignador siempre regrese un apuntador que cumpla con todas las
restricciones de alineacion. El <code>alloc</code> del <a href="#org69d49af">capitulo 5</a> no garantiza
ninguna alineacion en particular, de modo que emplearemos la
funcion <a href="#org292ad05"><code>malloc</code></a> de la biblioteca estandar, que si lo hace. En el
<a href="#orgb0747de">capitulo 8</a> se mostrara una forma de realizar <a href="#org292ad05"><code>malloc</code></a>.
</p>

<p>
La pregunta acerca del tipo de declaracion para una funcion como
<a href="#org292ad05"><code>malloc</code></a> es dificil para cualquier lenguaje que tome con seriedad
la revision de tipos. En C, el metodo apropiado es declarar que
<a href="#org292ad05"><code>malloc</code></a> regresa un apuntador a <code>void</code>, despues forzar
explicitamente con un cast al apuntador para hacerlo del tipo
deseado, <a href="#org292ad05"><code>malloc</code></a> y las rutinas relativas estan declaradas en el
header estandar <code>&lt;stdlib.h&gt;</code>. Asi, <code>talloc</code> se puede escribir como
</p>

<div class="org-src-container">
<pre class="src src-c"><span style="color: #b0c4de;">#include</span> <span style="color: #ffa07a;">&lt;stdlib.h&gt;</span>

<span style="color: #ff4500;">/* </span><span style="color: #ff4500;">talloc: crea un tnode </span><span style="color: #ff4500;">*/</span>
<span style="color: #00ffff;">struct</span> <span style="color: #98fb98;">tnode</span> *<span style="color: #87cefa;">talloc</span>(<span style="color: #98fb98;">void</span>)
{
  <span style="color: #00ffff;">return</span> (<span style="color: #00ffff;">struct</span> <span style="color: #98fb98;">tnode</span> *) malloc(<span style="color: #00ffff;">sizeof</span>(<span style="color: #00ffff;">struct</span> <span style="color: #98fb98;">tnode</span>));
}
</pre>
</div>

<p>
<code>strdup</code> simplemente copia la cadena dada por su argumento a un
lugar seguro, obtenido por una llamada a <a href="#org292ad05"><code>malloc</code></a>:
</p>

<div class="org-src-container">
<pre class="src src-c"><span style="color: #98fb98;">char</span> *<span style="color: #87cefa;">strdup</span>(<span style="color: #98fb98;">char</span> *<span style="color: #eedd82;">s</span>)      <span style="color: #ff4500;">/* </span><span style="color: #ff4500;">crea un duplicado de s </span><span style="color: #ff4500;">*/</span>
{
  <span style="color: #98fb98;">char</span> *<span style="color: #eedd82;">p</span>;
  p = (<span style="color: #98fb98;">char</span> *) malloc(strlen(s)+1); <span style="color: #ff4500;">/* </span><span style="color: #ff4500;">+1 para '\0' </span><span style="color: #ff4500;">*/</span>
  <span style="color: #00ffff;">if</span> (p != <span style="color: #7fffd4;">NULL</span>)
    strcpy(p, s);
  <span style="color: #00ffff;">return</span> p;
}
</pre>
</div>

<p>
<a href="#org292ad05"><code>malloc</code></a> regresa <code>NULL</code> si no hay espacio disponible; <code>strdup</code> pasa
ese valor, dejando el manejo de error a su invocador.
</p>

<p>
El espacio obtenido al llamar a <a href="#org292ad05"><code>malloc</code></a> puede liberarse para su
reutilizacion llamando a <a href="#org0a5a9fe"><code>free</code></a>; veanse los capitulos <a href="#orgf1abb1c">7</a> y <a href="#orgb0747de">8</a>.
</p>

<p>
<b>Ejercicio 6-2</b>. Escriba un programa que lea un programa en C e
imprima en orden alfabetico cada grupo de nombres de variable que
sean identicas en sus primeros 6 caracteres, pero diferentes en el
resto. No cuente palabras dentro de cadenas ni comentarios. Haga
que 6 sea un parametro que pueda fijarse desde la linea de ordenes.
</p>

<p>
<b>Ejercicio 6-3</b>. Escriba un programa de referencias cruzadas que
imprima una lista de todas las palabras de un documento, y para
cada palabra, una lista de los numeros de linea en los que
aparece. Elimine palabras como "el", "y", etcetera.
</p>

<p>
<b>Ejercicio 6-4</b>. Escriba un programa que imprima las distintas
palabras de su entrada, ordenadas en forma descendente de acuerdo
con su frecuencia de ocurrencia. Precede a cada palabra por su
conteo.
</p>
</div>
</div>

<div id="outline-container-orgd34cf1d" class="outline-3">
<h3 id="orgd34cf1d">6.6  Busqueda en tablas                                            <a id="orgffb18c3"></a></h3>
<div class="outline-text-3" id="text-orgd34cf1d">
<p>
En esta seccion escribiremos los componentes de un paquete de
busqueda en tablas, para ilustrar mas aspectos acerca de
estructuras. Este codigo es tipico de lo que podria encontrarse en
las rutinas de manejo de tablas de simbolos de un macroprocesador o
compilador. Por ejemplo, considere la proposicion <code>#define</code>. Cuando
se encuentra una linea como
</p>

<div class="org-src-container">
<pre class="src src-c"><span style="color: #b0c4de;">#define</span> <span style="color: #eedd82;">IN</span> 1
</pre>
</div>

<p>
el nombre <code>IN</code> y el texto de reemplazo <code>1</code> se almacenan en una
tabla. Despues, cuando el nombre <code>IN</code> aparece en una proposicion
como
</p>

<div class="org-src-container">
<pre class="src src-c">state = IN;
</pre>
</div>

<p>
se debe reemplazar por <code>1</code>.
</p>

<p>
Existen dos rutinas que manipulan los nombres y textos de
reemplazo. <code>install(s,t)</code> registra el nombre <code>s</code> y el texto de
reemplazo <code>t</code> en una tabla; <code>s</code> y <code>t</code> son solo cadenas de
caracteres, <code>lookup(s)</code> busca <code>s</code> en la tabla y regresa un
apuntador al lugar en donde fue encontrado, o <code>NULL</code> si no esta.
</p>

<p>
El algoritmo es una busqueda hash – el nombre que llega se
convierte a un pequeño entero no negativo, que despues se usa para
indexar un arreglo de apuntadores. Un elemento del arreglo apunta
al principio de una lista ligada de bloques que describen nombres
que tienen ese valor de hash. El elemento es <code>NULL</code> si ningun
nombre ha obtenido ese valor.
</p>


<div class="figure">
<p><img src="img/img_06.06.png" alt="img_06.06.png" />
</p>
</div>

<p>
Un bloque de la lista es una estructura que contiene apuntadores al
nombre, al texto de reemplazo y al siguiente bloque de la lista. Un
siguiente apuntador nulo marca el final de la lista.
</p>

<div class="org-src-container">
<pre class="src src-c"><span style="color: #00ffff;">struct</span> <span style="color: #98fb98;">nlist</span> {          <span style="color: #ff4500;">/* </span><span style="color: #ff4500;">entrada de la tabla:           </span><span style="color: #ff4500;">*/</span>
  <span style="color: #00ffff;">struct</span> <span style="color: #98fb98;">nlist</span> *<span style="color: #eedd82;">next</span>;   <span style="color: #ff4500;">/* </span><span style="color: #ff4500;">siguiente entrada en la cadena </span><span style="color: #ff4500;">*/</span>
  <span style="color: #98fb98;">char</span> *<span style="color: #eedd82;">name</span>;           <span style="color: #ff4500;">/* </span><span style="color: #ff4500;">nombre definido                </span><span style="color: #ff4500;">*/</span>
  <span style="color: #98fb98;">char</span> *<span style="color: #eedd82;">defn</span>;           <span style="color: #ff4500;">/* </span><span style="color: #ff4500;">texto de reemplazo             </span><span style="color: #ff4500;">*/</span>
};
</pre>
</div>

<p>
El arreglo de apuntadores es solo
</p>

<div class="org-src-container">
<pre class="src src-c"><span style="color: #b0c4de;">#define</span> <span style="color: #eedd82;">HASHSIZE</span> 101

<span style="color: #00ffff;">static</span> <span style="color: #00ffff;">struct</span> <span style="color: #98fb98;">nlist</span> *<span style="color: #eedd82;">hashtab</span>[HASHSIZE];  <span style="color: #ff4500;">/* </span><span style="color: #ff4500;">tabla de apuntadores </span><span style="color: #ff4500;">*/</span>
</pre>
</div>

<p>
La funcion de hash, que se utiliza tanto en <code>lookup</code> como en
<code>install</code>, agrega cada valor de caracter de la cadena a una
combinacion mezclada de los anteriores y regresa el modulo del
residuo entre el tamaño del arreglo. Esta no es la mejor funcion de
hash posible, pero es pequeña y efectiva.
</p>

<div class="org-src-container">
<pre class="src src-c"><span style="color: #ff4500;">/* </span><span style="color: #ff4500;">hash: forma un valor hash para la cadena s </span><span style="color: #ff4500;">*/</span>
<span style="color: #98fb98;">unsigned</span> <span style="color: #87cefa;">hash</span>(<span style="color: #98fb98;">char</span> *<span style="color: #eedd82;">s</span>)
{
  <span style="color: #98fb98;">unsigned</span> <span style="color: #eedd82;">hashval</span>;

  <span style="color: #00ffff;">for</span> (hashval = 0; *s != <span style="color: #ffa07a;">'\0'</span>; s++)
    hashval = *s + 31 * hashval;
  <span style="color: #00ffff;">return</span> hashval % HASHSIZE;
}
</pre>
</div>

<p>
La aritmetica sin signo asegura que el valor de hash no es
negativo.
</p>

<p>
El proceso de hash produce un indice inicial en el arreglo
<code>hashtab</code>; si la cadena se encontrara en algun lugar, sera en la
lista de bloques que empieza alli. La busqueda se realiza por
<code>lookup</code>. Si <code>lookup</code> encuentra que la entrada ya esta presente,
regresa un apuntador a ella; de otra manera, regresa <code>NULL</code>.
</p>

<div class="org-src-container">
<pre class="src src-c"><span style="color: #ff4500;">/* </span><span style="color: #ff4500;">lookup: busca s en hashtab </span><span style="color: #ff4500;">*/</span>
<span style="color: #00ffff;">struct</span> <span style="color: #98fb98;">nlist</span> *<span style="color: #87cefa;">lookup</span>(<span style="color: #98fb98;">char</span> *<span style="color: #eedd82;">s</span>)
{
  <span style="color: #00ffff;">struct</span> <span style="color: #98fb98;">nlist</span> *<span style="color: #eedd82;">np</span>;

  <span style="color: #00ffff;">for</span> (np = hashtab[hash(s)]; np != <span style="color: #7fffd4;">NULL</span>; np = np-&gt;next)
    <span style="color: #00ffff;">if</span> (strcmp(s, np-&gt;name) == 0)
      <span style="color: #00ffff;">return</span> np;    <span style="color: #ff4500;">/* </span><span style="color: #ff4500;">se encontro    </span><span style="color: #ff4500;">*/</span>
  <span style="color: #00ffff;">return</span> <span style="color: #7fffd4;">NULL</span>;      <span style="color: #ff4500;">/* </span><span style="color: #ff4500;">no se encontro </span><span style="color: #ff4500;">*/</span>
}
</pre>
</div>

<p>
El ciclo <code>for</code> que esta en <code>lookup</code> es la expresion idiomatica
estandar para moverse sobre una lista ligada;
</p>

<div class="org-src-container">
<pre class="src src-c"><span style="color: #00ffff;">for</span> (ptr = head; ptr != <span style="color: #7fffd4;">NULL</span>; ptr = ptr-&gt;next)
...
</pre>
</div>

<p>
<code>install</code> usa a <code>lookup</code> para determinar si el nombre que se va a
instalar ya esta presente; de ser asi, la nueva definicion toma el
lugar de la anterior. De otra manera, se crea una nueva entrada,
<code>install</code> regresa <code>NULL</code> si por cualquier razon no hay espacio para
una nueva entrada.
</p>

<div class="org-src-container">
<pre class="src src-c"><span style="color: #00ffff;">struct</span> <span style="color: #98fb98;">nlist</span> *<span style="color: #87cefa;">lookup</span>(<span style="color: #98fb98;">char</span> *);
<span style="color: #98fb98;">char</span> *<span style="color: #87cefa;">strdup</span>(<span style="color: #98fb98;">char</span> *);

<span style="color: #ff4500;">/* </span><span style="color: #ff4500;">install: coloca (name, defn) dentro de hashtab </span><span style="color: #ff4500;">*/</span>
<span style="color: #00ffff;">struct</span> <span style="color: #98fb98;">nlist</span> *<span style="color: #87cefa;">install</span>(<span style="color: #98fb98;">char</span> *<span style="color: #eedd82;">name</span>, <span style="color: #98fb98;">char</span> *<span style="color: #eedd82;">defn</span>)
{
  <span style="color: #00ffff;">struct</span> <span style="color: #98fb98;">nlist</span> *<span style="color: #eedd82;">np</span>;
  <span style="color: #98fb98;">unsigned</span> <span style="color: #eedd82;">hashval</span>;

  <span style="color: #00ffff;">if</span> ((np = lookup(name)) == <span style="color: #7fffd4;">NULL</span>) {    <span style="color: #ff4500;">/* </span><span style="color: #ff4500;">no fue encontrado       </span><span style="color: #ff4500;">*/</span>
    np = (<span style="color: #00ffff;">struct</span> <span style="color: #98fb98;">nlist</span> *) malloc(<span style="color: #00ffff;">sizeof</span>(*np));
    <span style="color: #00ffff;">if</span> (np == <span style="color: #7fffd4;">NULL</span> || (np-&gt;name = strdup(name)) == <span style="color: #7fffd4;">NULL</span>)
      <span style="color: #00ffff;">return</span> <span style="color: #7fffd4;">NULL</span>;
    hashval = hash(name);
    np-&gt;next = hashtab[hashval];
    hashtab[hashval] = np;
  } <span style="color: #00ffff;">else</span>                                <span style="color: #ff4500;">/* </span><span style="color: #ff4500;">ya esta alli            </span><span style="color: #ff4500;">*/</span>
    free((<span style="color: #98fb98;">void</span> *) np-&gt;defn);            <span style="color: #ff4500;">/* </span><span style="color: #ff4500;">libera la anterior defn </span><span style="color: #ff4500;">*/</span>
  <span style="color: #00ffff;">if</span> ((np-&gt;defn = strdup(defn)) == <span style="color: #7fffd4;">NULL</span>)
    <span style="color: #00ffff;">return</span> <span style="color: #7fffd4;">NULL</span>;
  <span style="color: #00ffff;">return</span> np;
}
</pre>
</div>

<p>
<b>Ejercicio 6-5</b>. Escriba una funcion <code>undef</code> que borre un nombre y
una definicion de la tabla mantenida por <code>lookup</code> e <code>install</code>.
</p>

<p>
<b>Ejercicio 6-6</b>. Haga una version simple del procesador <code>#define</code>
(esto es, sin argumentos) adecuada para usarse con programas en C,
basada en las rutinas de esta seccion. Tambien podra encontrar
utiles <code>getch</code> y <code>ungetch</code>.
</p>
</div>
</div>

<div id="outline-container-org30db592" class="outline-3">
<h3 id="org30db592">6.7  Typedef                                                       <a id="org0080b17"></a></h3>
<div class="outline-text-3" id="text-org30db592">
<p>
C proporciona una facilidad llamada <code>typedef</code> para crear nuevos
tipos de datos. Por ejemplo, la declaracion
</p>

<div class="org-src-container">
<pre class="src src-c"><span style="color: #00ffff;">typedef</span> <span style="color: #98fb98;">int</span> <span style="color: #98fb98;">Longitud</span>;
</pre>
</div>

<p>
hace del nombre <code>Longitud</code> un sinonimo de <code>int</code>. El tipo <code>Longitud</code>
puede emplearse en declaraciones, casts, etc., exactamente de la
misma manera en que lo podria ser <code>int</code>.
</p>

<div class="org-src-container">
<pre class="src src-c"><span style="color: #98fb98;">Longitud</span> <span style="color: #eedd82;">len</span>, <span style="color: #eedd82;">maxlen</span>;
<span style="color: #98fb98;">Longitud</span> *<span style="color: #eedd82;">lengths</span>[];
</pre>
</div>

<p>
De modo semejante, la declaracion
</p>

<div class="org-src-container">
<pre class="src src-c"><span style="color: #00ffff;">typedef</span> <span style="color: #98fb98;">char</span> * <span style="color: #98fb98;">Cadena</span>;
</pre>
</div>

<p>
hace a <code>Cadena</code> un sinonimo para <code>char *</code> o apuntador a caracter,
que despues puede usarse en declaraciones y casts:
</p>

<div class="org-src-container">
<pre class="src src-c"><span style="color: #98fb98;">Cadena</span> <span style="color: #eedd82;">p</span>, <span style="color: #eedd82;">lineptr</span>[MAXLINES], <span style="color: #87cefa;">alloc</span>(<span style="color: #98fb98;">int</span>);
<span style="color: #98fb98;">int</span> <span style="color: #87cefa;">strcmp</span>(<span style="color: #98fb98;">Cadena</span>, <span style="color: #98fb98;">Cadena</span>);
p = (<span style="color: #98fb98;">Cadena</span>) <span style="color: #87cefa;">malloc</span>(lOO);
</pre>
</div>

<p>
Notese que el tipo que se declara en un <code>typedef</code> aparece en la
posicion de un nombre de variable, no justo despues de la palabra
<code>typedef</code>. Sintacticamente, <code>typedef</code> es como las clases de
almacenamiento <code>extern</code>, <code>static</code>, etc. Hemos empleado nombres con
mayuscula para los <code>typedef</code>, para destacarlos.
</p>

<p>
Como un ejemplo mas complicado, podriamos declarar mediante
<code>typedef</code> los nodos del arbol mostrados anteriormente en este
capitulo:
</p>

<div class="org-src-container">
<pre class="src src-c"><span style="color: #00ffff;">typedef</span> <span style="color: #00ffff;">struct</span> <span style="color: #98fb98;">tnode</span> *<span style="color: #98fb98;">Treeptr</span>;

<span style="color: #00ffff;">typedef</span> <span style="color: #00ffff;">struct</span> <span style="color: #98fb98;">tnode</span> {        <span style="color: #ff4500;">/* </span><span style="color: #ff4500;">el nodo del arbol:    </span><span style="color: #ff4500;">*/</span>
  <span style="color: #98fb98;">char</span> *<span style="color: #eedd82;">word</span>;                 <span style="color: #ff4500;">/* </span><span style="color: #ff4500;">apunta hacia el texto </span><span style="color: #ff4500;">*/</span>
  <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">count</span>;                  <span style="color: #ff4500;">/* </span><span style="color: #ff4500;">numero de ocurrencias </span><span style="color: #ff4500;">*/</span>
  <span style="color: #00ffff;">struct</span> <span style="color: #98fb98;">tnode</span> *<span style="color: #eedd82;">left</span>;         <span style="color: #ff4500;">/* </span><span style="color: #ff4500;">hijo izquierdo        </span><span style="color: #ff4500;">*/</span>
  <span style="color: #00ffff;">struct</span> <span style="color: #98fb98;">tnode</span> *<span style="color: #eedd82;">right</span>;        <span style="color: #ff4500;">/* </span><span style="color: #ff4500;">hijo derecho          </span><span style="color: #ff4500;">*/</span>
} <span style="color: #98fb98;">Treenode</span>;
</pre>
</div>

<p>
Esto crea dos nuevas palabras reservadas para tipos, llamados
<code>Treenode</code> (una estructura) y <code>Treeptr</code> (un apuntador a la
estructura). Entonces, la rutina <code>talloc</code> podria ser
</p>

<div class="org-src-container">
<pre class="src src-c"><span style="color: #98fb98;">Treeptr</span> <span style="color: #87cefa;">talloc</span>(<span style="color: #98fb98;">void</span>)
{
  <span style="color: #00ffff;">return</span> (<span style="color: #98fb98;">Treeptr</span>) malloc(<span style="color: #00ffff;">sizeof</span>(Treenode));
}
</pre>
</div>

<p>
Se debe destacar que una declaracion <code>typedef</code> no crea un nuevo
tipo en ningun sentido; simplemente agrega un nuevo nombre para
algun tipo ya existente. Tampoco es alguna nueva semantica: las
variables declaradas de esta manera tienen exactamente las mismas
propiedades que las variables cuyas declaraciones se escriben
explicitamente. En efecto, <code>typedef</code> es como <code>#define</code>, excepto que
al ser interpretado por el compilador puede realizar substituciones
textuales que estan mas alla de las capacidades del
preprocesador. Por ejemplo,
</p>

<div class="org-src-container">
<pre class="src src-c"><span style="color: #00ffff;">typedef</span> <span style="color: #98fb98;">int</span> (*<span style="color: #98fb98;">AAF</span>)(<span style="color: #98fb98;">char</span> *, <span style="color: #98fb98;">char</span> *);
</pre>
</div>

<p>
crea el tipo <code>AAF</code>, de "apuntador a funcion (de dos argumentos
<code>char *</code>) que regresa <code>int</code> ", el cual se puede usar en contextos
como
</p>

<div class="org-src-container">
<pre class="src src-c"><span style="color: #98fb98;">AAF</span> <span style="color: #eedd82;">strcmp</span>, <span style="color: #eedd82;">numcmp</span>;
</pre>
</div>

<p>
dentro del breve programa del <a href="#org69d49af">capitulo 5</a>.
</p>

<p>
Ademas de las razones puramente esteticas, hay dos razones
principales para emplear <code>typedef</code>. La primera es parametrizar un
programa contra los problemas de transportabilidad. Si se emplea
<code>typedef</code> para tipos de datos que pueden ser dependientes de la
maquina, cuando un programa se traslada, solo los <code>typedef</code>
requieren de cambios. Una situacion comun es usar nombres de
<code>typedef</code> para varias cantidades enteras, y entonces hacer un
conjunto apropiado de selecciones de <code>short</code>, <code>int</code> y <code>long</code> para
cada maquina. Tipos como <code>size_t</code> y <code>ptrdifl_t</code> de la biblioteca
estandar son ejemplos.
</p>

<p>
El segundo proposito de los <code>typedef</code> es proporcionar mejor
documentacion para un programa – un tipo llamado <code>Treeptr</code> puede
ser mas facil de entender que uno declarado solo como un apuntador
a una estructura complicada.
</p>
</div>
</div>

<div id="outline-container-org566d372" class="outline-3">
<h3 id="org566d372">6.8  Uniones                                                       <a id="org6bf7a9e"></a></h3>
<div class="outline-text-3" id="text-org566d372">
<p>
Una <i>union</i> es una variable que puede contener (en momentos
diferentes) objetos de diferentes tipos y tamaños, y el compilador
hace el seguimiento del tamaño y requisitos de alineacion. Las
uniones proporcionan una forma de manipular diferentes clases de
datos dentro de una sola area de almacenamiento, sin incluir en el
programa ninguna informacion dependiente de la maquina. Son
analogas a los <i>variant records</i> de Pascal.
</p>

<p>
Como un ejemplo, que podria ser encontrado en el manejador de la
tabla de simbolos de un compilador, supongase que una constante
podria ser un <code>Iñt</code>, un <code>float</code>, o un apuntador a caracter. El
valor de una constante en particular debe ser guardado en una
variable del tipo adecuado. No obstante, es conveniente para el
manejador de tablas si el valor ocupa la misma cantidad de memoria
y es guardado en el mismo lugar sin importar su tipo. Este es el
proposito de una "union" – una sola variable que puede
legitimamente guardar uno de varios tipos. La sintaxis se basa en
las estructuras:
</p>

<div class="org-src-container">
<pre class="src src-c"><span style="color: #00ffff;">union</span> <span style="color: #98fb98;">u_tag</span> {
  <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">ival</span>;
  <span style="color: #98fb98;">float</span> <span style="color: #eedd82;">fval</span>;
  <span style="color: #98fb98;">char</span> *<span style="color: #eedd82;">sval</span>;
} <span style="color: #eedd82;">u</span>;
</pre>
</div>

<p>
La variable <code>u</code> sera suficientemente grande como para mantener al
mayor de los tres tipos: el tamaño especifico depende de la
implantacion. Cualquiera de estos tipos puede ser asignado a <code>u</code> y
despues empleado en expresiones, mientras que el uso sea
consistente: el tipo recuperado debe ser el tipo que se almaceno
mas recientemente. Es responsabilidad del programador llevar el
registro del tipo que esta almacenado actualmente en una union; si
algo se almacena como un tipo y se recupera como otro, el resultado
depende de la implantacion.
</p>

<p>
Sintacticamente, se tiene acceso a los miembros de una union con
</p>

<div class="org-src-container">
<pre class="src src-c">nombre-<span style="color: #00ffff;">union</span>.miembro
</pre>
</div>

<p>
o
</p>

<div class="org-src-container">
<pre class="src src-c">apuntador-<span style="color: #00ffff;">union</span>-&gt;miembro
</pre>
</div>

<p>
precisamente como a las estructuras. Si la variable <code>utype</code> se
emplea para llevar el registro del tipo actualmente almacenado en
<code>u</code>, entonces se podria ver el codigo como
</p>

<div class="org-src-container">
<pre class="src src-c"><span style="color: #00ffff;">if</span> (utype == INT)
  printf(<span style="color: #ffa07a;">"%d\n"</span>, u.ival);
<span style="color: #00ffff;">if</span> (utype == FLOAT)
  printf(<span style="color: #ffa07a;">"%f\n"</span>, u.fval);
<span style="color: #00ffff;">if</span> (utype == STRING)
  printf(<span style="color: #ffa07a;">"%s\n"</span>, u.sval);
<span style="color: #00ffff;">else</span>
  printf(<span style="color: #ffa07a;">"bad type %d in utype\n"</span>, utype);
</pre>
</div>

<p>
Las uniones pueden presentarse dentro de estructuras y arreglos, y
viceversa. La notacion para tener acceso a un miembro de una union
en una estructura (o viceversa) es identica a la de las estructuras
anidadas. Por ejemplo, en el arreglo de estructuras definido por
</p>

<div class="org-src-container">
<pre class="src src-c"><span style="color: #00ffff;">struct</span> {
  <span style="color: #98fb98;">char</span> *<span style="color: #eedd82;">name</span>;
  <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">flags</span>;
  <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">utype</span>;
  <span style="color: #00ffff;">union</span> {
    <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">ival</span>;
    <span style="color: #98fb98;">float</span> <span style="color: #eedd82;">fval</span>;
    <span style="color: #98fb98;">char</span> *<span style="color: #eedd82;">sval</span>;
  } <span style="color: #eedd82;">u</span>;
} <span style="color: #eedd82;">symtab</span>[NSYM];
</pre>
</div>

<p>
al miembro <code>ival</code> se le refiere como
</p>

<div class="org-src-container">
<pre class="src src-c"><span style="color: #98fb98;">symtab</span>[i].u.ival
</pre>
</div>

<p>
y al primer caracter de la cadena <code>sval</code> por cualquiera de
</p>

<div class="org-src-container">
<pre class="src src-c">*symtab[i].u.sval
</pre>
</div>

<div class="org-src-container">
<pre class="src src-c"><span style="color: #98fb98;">symtab</span>[i].u.sval[0]
</pre>
</div>

<p>
En efecto, una union es una estructura en la cual todos los
miembros tienen un desplazamiento de cero a partir de la base, la
estructura es suficientemente grande para mantener al miembro "mas
ancho", y la alineacion es la apropiada para todos los tipos de la
union. Estan permitidas las mismas operaciones sobre las uniones
como sobre las estructuras: asignacion o copia como unidad, tomar
la direccion, y hacer el acceso a un miembro.
</p>

<p>
Una union solo se puede inicializar con un valor del tipo de su
pirimer miembro, asi que la union <code>u</code> descrita anteriormente solo
se puede inicializar con un valor entero.
</p>

<p>
El asignador de almacenamiento del <a href="#orgb0747de">capitulo 8</a> muestra como se puede
usar una union para obligar a que una variable sea alineada para
una clase particular de limites de almacenamiento.
</p>
</div>
</div>

<div id="outline-container-orgd03c1a3" class="outline-3">
<h3 id="orgd03c1a3">6.9  Campos de bits                                                <a id="orga0627df"></a></h3>
<div class="outline-text-3" id="text-orgd03c1a3">
<p>
Cuando el espacio de almacenamiento es escaso, puede ser necesario
empaquetar varios objetos dentro de una sola palabra de maquina; un
uso comun es un conjunto de banderas de un bit en aplicaciones como
tablas de simbolos para compiladores. Los formatos de datos
impuestos externamente, como interfaces hacia dispostivos de
hardware, frecuentemente requieren la capacidad de tomar partes de
una palabra.
</p>

<p>
Imaginese un fragmento de un compilador que manipula una tabla de
simbolos. Cada identificador dentro de un programa tiene cierta
informacion asociada a el, por ejemplo, si es o no una palabra
reservada, si es o no externa y/o estatica y otros aspectos. La
forma mas compacta de codificar tal informacion es con un conjunto
de banderas de un bit dentro de un <code>char</code> o <code>int</code>.
</p>

<p>
La forma usual en que esto se realiza es definiendo un conjunto de
"mascaras" correspondientes a las posiciones relevantes de bits,
como en
</p>

<div class="org-src-container">
<pre class="src src-c"><span style="color: #b0c4de;">#define</span> <span style="color: #eedd82;">KEYWORD</span>  01
<span style="color: #b0c4de;">#define</span> <span style="color: #eedd82;">EXTERNAL</span> 02
<span style="color: #b0c4de;">#define</span> <span style="color: #eedd82;">STATIC</span>   04
</pre>
</div>

<p>
O
</p>

<div class="org-src-container">
<pre class="src src-c"><span style="color: #00ffff;">enum</span> { <span style="color: #eedd82;">KEYWORD</span> = 01, <span style="color: #eedd82;">EXTERNAL</span> = 02, <span style="color: #eedd82;">STATIC</span> = 04 };
</pre>
</div>

<p>
Los numeros deben ser potencias de dos. El acceso a los bits viene
a ser cosa de "jugar" con los operadores de corrimiento,
enmascaramiento y complemento, que se describieron en el
<a href="#org29d5b55">capitulo 2</a>.
</p>

<p>
Ciertas expresiones aparecen frecuentemente:
</p>

<div class="org-src-container">
<pre class="src src-c">flags |= EXTERNAL | STATIC;
</pre>
</div>

<p>
enciende los bits <code>EXTERNAL</code> y <code>STATIC</code> en <code>flags</code>, en tanto que
</p>

<div class="org-src-container">
<pre class="src src-c">flags &amp;= ~(EXTERNAL | STATIC);
</pre>
</div>

<p>
los apaga, y
</p>

<div class="org-src-container">
<pre class="src src-c"><span style="color: #00ffff;">if</span> ((flags &amp; (EXTERNAL | STATIC)) == 0) ...
</pre>
</div>

<p>
es verdadero si ambos bits estan apagados.
</p>

<p>
Aunque estas expresiones se dominan facilmente, como alternativa C
ofrece la capacidad de definir y tener acceso a campos de una
palabra mas directamente que por medio de operadores logicos de
bits. Un <i>campo de bits</i>, o simplemente <i>campo</i>, es un conjunto de
bits adyacentes dentro de una unidad de almacenamiento definida por
la implantacion, al que llamaremos "palabra". La sintaxis para la
definicion y acceso a campos esta basada en estructuras. Por
ejemplo, la anterior tabla de simbolos <code>#define</code> podria haber sido
reemplazada por la definicion de tres campos:
</p>

<div class="org-src-container">
<pre class="src src-c"><span style="color: #00ffff;">struct</span> {
  <span style="color: #98fb98;">unsigned</span> <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">is_keyword</span> : 1;
  <span style="color: #98fb98;">unsigned</span> <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">is_extern</span>  : 1;
  <span style="color: #98fb98;">unsigned</span> <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">is_static</span>  : 1;
} <span style="color: #eedd82;">flags</span>;
</pre>
</div>

<p>
Esto define una variable llamada <code>flags</code>, que contiene tres campos
de un bit. El numero que sigue al caracter dos puntos representa el
ancho del campo en bits.  Los campos son declarados <code>unsigned int</code>
para asegurar que sean cantidades sin signo.
</p>

<p>
Los campos individuales son referidos en la misma forma que para
otros miembros de estructuras: <code>flags.is_keyword</code>,
<code>flags.is_extern</code>, etc. Los campos Se comportan como pequeños
enteros y pueden participar en expresiones aritmeticas, como lo
hacen otros enteros. Asi, el ejemplo previo pudo escribirse mas
naturalmente como
</p>

<div class="org-src-container">
<pre class="src src-c">flags.is_extern = flags.is_static = 1;
</pre>
</div>

<p>
para encender los bits;
</p>

<div class="org-src-container">
<pre class="src src-c">flags.is_extern = flags.is_static = 0;
</pre>
</div>

<p>
para apagarlos; y
</p>

<div class="org-src-container">
<pre class="src src-c"><span style="color: #00ffff;">if</span> (flag.is_extern == 0 &amp;&amp; flags.is_static == 0)
  ...
</pre>
</div>

<p>
para probarlos.
</p>

<p>
Casi todo acerca de los campos es dependiente de la
implantacion. El que un campo pueda traslapar al limite de una
palabra se define por la implantacion. Los campos no necesitan
tener nombre; los campos sin nombre (dos puntos y su amplitud
solamente) se emplean para llenar espacios. El ancho especial <code>0</code>
puede emplearse para obligar a la alineacion al siguiente limite de
palabra.
</p>

<p>
Los campos se asignan de izquierda a derecha en algunas maquinas y
de derecha a izquierda en otras. Esto significa que aunque los
campos son utiles para el mantenimiento de estructuras de datos
definidas internamente, la pregunta de que punta viene primero
tiene que considerarse cuidadosamente cuando se seleccionan datos
definidos externamente; los programas que dependen de tales cosas
no son transportables. Los campos solo se pueden declarar como
enteros; por transportabilidad, se debe especificar explicitamente
<code>signed</code> o <code>unsigned</code>. No son arreglos y no tienen direcciones, de
modo que el operador <code>&amp;</code> no puede aplicarse a ellos.
</p>
</div>
</div>
</div>

<div id="outline-container-org6982d3e" class="outline-2">
<h2 id="org6982d3e">capitulo 7: Entrada y salida                                        <a id="orgf1abb1c"></a></h2>
<div class="outline-text-2" id="text-org6982d3e">
<p>
Las operaciones de entrada y salida no son en si parte del lenguaje
C, por lo que hasta ahora no las hemos destacado. Sin embargo, los
programas interactuan con su medio ambiente en formas mucho mas
complicadas de las que hemos mostrado antes. En este capitulo
describiremos la biblioteca estandar, un conjunto de funciones que
proporcionan entrada y salida, manipulacion de cadenas, manejo de
memoria, rutinas matematicas y una variedad de otros servicios para
programas en C, aunque haremos hincapie en la entrada y salida.
</p>

<p>
El estandar ANSI define de manera precisa estas funciones de
biblioteca, de modo que pueden existir en forma compatible en
cualquier sistema en donde exista C. Los programas que restringen su
interaccion con el sistema a las facilidades provistas por la
biblioteca estandar pueden ser llevados de un sistema a otro sin
cambios.
</p>

<p>
Las propiedades de las funciones de biblioteca estan especificadas
en mas de una docena de <i>headers</i>; ya hemos visto algunos,
incluyendo <code>&lt;stdio.h&gt;</code>, <code>&lt;string.h&gt;</code> y <code>&lt;ctype.h&gt;</code> . No
presentaremos aqui la totalidad de la biblioteca, puesto que estamos
mas interesados en escribir programas en C que los usan. La
biblioteca se describe en detalle en el <a href="#org89d4232">apendice B</a>.
</p>
</div>

<div id="outline-container-org15288e7" class="outline-3">
<h3 id="org15288e7">7.1  Entrada y salida estandar                                     <a id="org009b376"></a></h3>
<div class="outline-text-3" id="text-org15288e7">
<p>
Como señalamos en el <a href="#orgc16243d">capitulo 1</a>, la biblioteca consiste en un
modelo simple de entrada y salida de texto. Un flujo de texto
consiste en una secuencia de lineas, cada una de las cuales termina
con un caracter nueva linea. Si el sistema no opera de ese modo, la
biblioteca hace lo que sea necesario para simular que asi
funciona. Por ejemplo, la biblioteca podria convertir el regreso de
carro y avance de linea a una nueva linea en la entrada y de nuevo
en la salida.
</p>

<p>
El mecanismo de entrada mas simple es leer un caracter a la vez de
la <i>entrada estandar</i>, normalmente el teclado, con <a href="#org4d38061"><code>getchar</code></a>:
</p>

<div class="org-src-container">
<pre class="src src-c"><span style="color: #98fb98;">int</span> <span style="color: #87cefa;">getchar</span>(<span style="color: #98fb98;">void</span>)
</pre>
</div>

<p>
<a href="#org4d38061"><code>getchar</code></a> regresa el siguiente caracter de la entrada cada vez que
se invoca, o <code>EOF</code> cuando encuentra fin de archivo. La constante
simbolica <code>EOF</code> esta definida en <code>&lt;stdio.h&gt;</code>. El valor es
tipicamente <code>-1</code>, pero las pruebas se deben escribir en funcion de
<code>EOF</code>, de modo que sean independientes del valor especifico.
</p>

<p>
En muchos medios ambientes, un archivo puede tomar el lugar del
teclado empleando la convencion <code>&lt;</code> para redireccionamiento de
entrada: si un programa <code>prog</code> usa <a href="#org4d38061"><code>getchar</code></a>, entonces la linea de
ordenes
</p>

<div class="org-src-container">
<pre class="src src-sh">prog &lt; infile
</pre>
</div>

<p>
provoca que <code>prog</code> lea caracteres de <code>infile</code>. El cambio de la
entrada se realiza de tal manera que <code>prog</code> mismo es ajeno al
cambio; en particular, la cadena "&lt; infile" no esta incluida entre
los argumentos de la linea de ordenes en <code>argv</code>. El cambio de la
entrada es tambien invisible si la entrada viene de otro programa
via un mecanismo de interconexion (pipe): en algunos sistemas, la
linea de ordenes
</p>

<div class="org-src-container">
<pre class="src src-sh">otroprog | prog
</pre>
</div>

<p>
ejecuta tanto al programa <code>otroprog</code> como a <code>prog</code>, e interconecta
la salida estandar de <code>otroprog</code> con la entrada estandar para
<code>prog</code>.
</p>

<p>
La funcion
</p>

<div class="org-src-container">
<pre class="src src-c"><span style="color: #98fb98;">int</span> <span style="color: #87cefa;">putchar</span>(<span style="color: #98fb98;">int</span>)
</pre>
</div>

<p>
se emplea para salida: <code>putchar(c)</code> coloca el caracter <code>c</code> en la
<i>salida estandar</i>, que por omision es la pantalla. <a href="#orgc7f0a8a"><code>putchar</code></a>
regresa el caracter escrito, o <code>EOF</code> si ocurre algun error. De
nuevo, la salida puede ser dirigida hacia algun archivo con
<code>&gt; nombrearch</code>: si <code>prog</code> utiliza <a href="#orgc7f0a8a"><code>putchar</code></a>,
</p>

<div class="org-src-container">
<pre class="src src-sh">prog &gt; archsal
</pre>
</div>

<p>
escribira la salida estandar hacia <code>archsal</code>. Si se permite la
interconexion,
</p>

<div class="org-src-container">
<pre class="src src-sh">prog | otroprog
</pre>
</div>

<p>
deja la salida estandar de <code>prog</code> en la entrada estandar de
<code>otroprog</code>.
</p>

<p>
La salida producida por <a href="#org0458a76"><code>printf</code></a> tambien encuentra su camino hacia
la salida estandar. Las llamadas a <a href="#orgc7f0a8a"><code>putchar</code></a> y a <a href="#org0458a76"><code>printf</code></a> pueden
estar traslapadas – la salida aparece en el orden en que se
hicieron las llamadas.
</p>

<p>
Cada archivo fuente que se refiera a una funcion de biblioteca de
entrada/salida debe contener la linea
</p>

<div class="org-src-container">
<pre class="src src-c"><span style="color: #b0c4de;">#include</span> <span style="color: #ffa07a;">&lt;stdio.h&gt;</span>
</pre>
</div>

<p>
antes de la primera referencia. Cuando un nombre se delimita por
<code>&lt;</code> y <code>&gt;</code> se realiza una busqueda del <i>header</i> en algunos lugares
estandar (por ejemplo, en los sistemas UNIX, tipicamente en el
directorio <code>/usr/include</code>).
</p>

<p>
Muchos programas leen solo un flujo de entrada y escriben solo un
flujo de salida; para tales programas la entrada y salida con
<a href="#org4d38061"><code>getchar</code></a>, <a href="#orgc7f0a8a"><code>putchar</code></a> y <a href="#org0458a76"><code>printf</code></a> puede ser totalmente adecuada y en
realidad es suficiente para comenzar. Esto es particularmente
cierto si se emplea la redireccion para conectar la salida de un
programa a la entrada de otro. Por ejemplo, considerese el programa
<code>lower</code>, que convierte su entrada a minusculas:
</p>

<div class="org-src-container">
<pre class="src src-c"><span style="color: #b0c4de;">#include</span> <span style="color: #ffa07a;">&lt;stdio.h&gt;</span>
<span style="color: #b0c4de;">#include</span> <span style="color: #ffa07a;">&lt;ctype.h&gt;</span>

<span style="color: #87cefa;">main</span>() <span style="color: #ff4500;">/* </span><span style="color: #ff4500;">lower: convierte la entrada a minusculas </span><span style="color: #ff4500;">*/</span>
{
  <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">c</span>;

  <span style="color: #00ffff;">while</span> ((c = getchar()) != EOF)
    putchar(tolower(c));
  <span style="color: #00ffff;">return</span> 0;
}
</pre>
</div>

<p>
La funcion <code>tolower</code> esta definida en <code>&lt;ctype.h&gt;</code>; convierte una
letra mayuscula a minuscula, y regresa los otros caracteres
intactos. Como mencionamos antes, las "funciones" como <a href="#org4d38061"><code>getchar</code></a> y
<a href="#orgc7f0a8a"><code>putchar</code></a> en <code>&lt;stdio.h&gt;</code> y <code>tolower</code> en <code>&lt;ctype.h&gt;</code> son a menudo
macros, evitandose asi la sobrecarga de una llamada a funcion por
cada caracter. En la <a href="#orge4244db">seccion 8.5</a> se mostrara como se hace esto. Sin
importar como sean las funciones de <code>&lt;ctype.h&gt;</code> en una maquina
dada, los programas que las emplean estan aislados del juego de
caracteres.
</p>

<p>
<b>Ejercicio 7-1</b>. Escriba un programa que convierta mayusculas a
minusculas o viceversa, dependiendo del nombre con que se invoque,
dado en <code>argv[0]</code>.
</p>
</div>
</div>

<div id="outline-container-org310ffee" class="outline-3">
<h3 id="org310ffee">7.2  Salida con formato - <a href="#org0458a76"><code>printf</code></a>                                 <a id="orga1729da"></a></h3>
<div class="outline-text-3" id="text-org310ffee">
<p>
La funcion de salida <a href="#org0458a76"><code>printf</code></a> traduce valores internos a
caracteres. Ya hemos empleado informalmente <a href="#org0458a76"><code>printf</code></a> en los
capitulos anteriores. La descripcion de aqui cubre los usos mas
tipicos, pero no esta completa; para la definicion completa, vease
el <a href="#org89d4232">apendice B</a>.
</p>

<div class="org-src-container">
<pre class="src src-c"><span style="color: #98fb98;">int</span> <span style="color: #87cefa;">printf</span>(<span style="color: #98fb98;">char</span> *<span style="color: #eedd82;">format</span>, arg1, arg2, ...)
</pre>
</div>

<p>
<a href="#org0458a76"><code>printf</code></a> convierte, da formato e imprime sus argumentos en la
salida estandar bajo el control de <code>format</code>. Regresa el numero de
caracteres impresos.
</p>

<p>
La cadena de formato contiene dos tipos de objetos: caracteres
ordinarios, Que son copiados al flujo de salida, y especificaciones
de conversion, cada uno de los cuales causa la conversion e
impresion de los siguientes argumentos sucesivos de <a href="#org0458a76"><code>printf</code></a>. Cada
especificacion de conversion comienza con un <code>%</code> y termina con un
caracter de conversion. Entre el <code>%</code> y el caracter de conversion
pueden estar, en orden:
</p>

<ul class="org-ul">
<li>Un signo menos, que especifica el ajuste a la izquierda del
argumento convertido.</li>

<li>Un numero que especifica el ancho minimo de campo. El argumento
convertido sera impreso dentro de un campo de al menos este
ancho. Si es necesario sera llenado de blancos a la izquierda (o
a la derecha, si se requiere ajuste a la izquierda) para
completar la amplitud del campo.</li>

<li>Un punto, que separa el ancho de campo de la precision.</li>

<li>Un numero, la precision, que especifica el numero maximo de
caracteres de una cadena que seran impresos, o el numero de
digitos despues del punto decimal de un valor de punto flotante,
o el numero minimo de digitos para un entero.</li>

<li>Una <code>h</code> si el entero sera impreso como un <code>short</code>, o una <code>l</code>
(letra ele) si sera como un <code>long</code>.</li>
</ul>


<p>
Los caracteres de conversion se muestran en la <a href="#org3c1dc49">tabla 7-1</a>. Si el
caracter despues del <code>%</code> no es una especificacion de conversion, el
comportamiento no esta definido.
</p>

<dl class="org-dl">
<dt><a id="org3c1dc49">Tabla 7-1</a></dt><dd><p>
Conversiones basicas de <a href="#org0458a76"><code>printf</code></a>
</p>

<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-left" />

<col  class="org-left" />
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">CARACTER</th>
<th scope="col" class="org-left">Tipo de argumento : impreso como</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left">d, i</td>
<td class="org-left"><code>int</code>: numero decimal.</td>
</tr>

<tr>
<td class="org-left">o</td>
<td class="org-left"><code>int</code>: numero octal sin signo (sin cero inicial).</td>
</tr>

<tr>
<td class="org-left">x, X</td>
<td class="org-left"><code>int</code>: numero hexadecimal sin signo (con un <code>Ox</code> o <code>OX</code> inicial, usando <code>abcde</code> o <code>ABCDEF</code> para 10, &#x2026;, 15.</td>
</tr>

<tr>
<td class="org-left">u</td>
<td class="org-left"><code>int</code>: numero decimal sin signo,</td>
</tr>

<tr>
<td class="org-left">c</td>
<td class="org-left"><code>int</code>: caracter sencillo.</td>
</tr>

<tr>
<td class="org-left">s</td>
<td class="org-left"><code>char *</code>: imprime caracteres de una cadena hasta un '<code>\0</code>' o el numero de caracteres dado por la precision.</td>
</tr>

<tr>
<td class="org-left">f</td>
<td class="org-left"><code>double</code>: <code>[-]m.dddddd</code>, en donde el numero de <i>d's</i> esta dado por la precision (predeterminado a 6).</td>
</tr>

<tr>
<td class="org-left">e, E</td>
<td class="org-left"><code>double</code>: <code>[-]m.dddddde+/-xx</code> o <code>[-]m.ddddddE+/-xx</code>, en donde el numero de <i>d's</i> esta dado por la precision (predeterminado a 6).</td>
</tr>

<tr>
<td class="org-left">g, G</td>
<td class="org-left"><code>double</code>: usa <code>%e</code> o <code>%E</code> si el exponente es menor que <code>-4</code> o mayor o igual a la precision; de otra forma usa <code>%f</code>. Los ceros o el punto al final no se imprimen.</td>
</tr>

<tr>
<td class="org-left">p</td>
<td class="org-left"><code>void *</code>: apuntador (representacion dependiente de la instalacion),</td>
</tr>

<tr>
<td class="org-left">%</td>
<td class="org-left">no es convertido en ningun argumento; imprime un <code>%</code>.</td>
</tr>
</tbody>
</table></dd>
</dl>


<p>
Una amplitud o precision se puede especificar por <code>*</code>, en cuyo caso
el valor se calcula convirtiendo el siguiente argumento (que debe
ser <code>int</code>). Por ejemplo, para imprimir al menos <code>max</code> caracteres de
una cadena <code>s</code>,
</p>

<div class="org-src-container">
<pre class="src src-c">printf(<span style="color: #ffa07a;">"%.*s"</span>, max, s);
</pre>
</div>

<p>
La mayoria de las conversiones de formato se han ilustrado en
capitulos anteriores. Una excepcion es la precision relacionada con
las cadenas. La siguiente tabla muestra el efecto de una variedad
de especificaciones al imprimir "hello, world" (12 caracteres).
Hemos colocado el caracter dos puntos alrededor de cada campo para
que se pueda apreciar su extension.
</p>

<pre class="example">
:%s:       | :hello, world:
:%10s:     | :hello, world:
:%.10s:    | :hello, wor:
:%-10s:    | :hello, world:
:%.15s:    | :hello, world:
:%-15s:    | :hello, world   :
:%15.10s:  | :     hello, wor:
:%-15.10s: | :hello, wor     :
</pre>

<p>
Una advertencia: <a href="#org0458a76"><code>printf</code></a> emplea su primer argumento para decidir
cuantos argumentos le siguen y cuales son sus tipos, <a href="#org0458a76"><code>printf</code></a> se
confundira y se obtendran resultados erroneos si no hay suficientes
argumentos o si tienen tipos incorrectos. Tambien debe advertir la
diferencia entre estas dos llamadas:
</p>

<div class="org-src-container">
<pre class="src src-c"><span style="color: #87cefa;">printf</span>(s);            <span style="color: #ff4500;">/* </span><span style="color: #ff4500;">FALLA si s contiene % </span><span style="color: #ff4500;">*/</span>
printf(<span style="color: #ffa07a;">"%s"</span>, s);      <span style="color: #ff4500;">/* </span><span style="color: #ff4500;">SEGURO                </span><span style="color: #ff4500;">*/</span>
</pre>
</div>

<p>
La funcion <a href="#org44a4902"><code>sprintf</code></a> realiza las mismas conversiones que <a href="#org0458a76"><code>printf</code></a>,
pero almacena la salida en una cadena:
</p>

<div class="org-src-container">
<pre class="src src-c"><span style="color: #98fb98;">int</span> <span style="color: #87cefa;">sprintf</span>(<span style="color: #98fb98;">char</span> *<span style="color: #eedd82;">cadena</span>, <span style="color: #98fb98;">char</span> *<span style="color: #eedd82;">format</span>, arg1, arg2, ...);
</pre>
</div>

<p>
<a href="#org44a4902"><code>sprintf</code></a> da formato a los argumentos que estan en <code>arg1</code>, <code>arg2</code>,
etc., de acuerdo con <code>format</code> como antes, pero coloca el resultado
en <code>cadena</code> en vez de en la salida estandar; <code>cadena</code> debe ser
suficientemente grande como para recibir el resultado.
</p>

<p>
<b>Ejercicio 7-2</b>. Escriba un programa que imprima una entrada
arbitraria en forma sensata. Como minimo, debera imprimir
caracteres no graficos en octal o hexadecimal de acuerdo con la
costumbre local, y separar lineas largas de texto.
</p>
</div>
</div>

<div id="outline-container-orgdb129c6" class="outline-3">
<h3 id="orgdb129c6">7.3  Listas de argumentos de longitud variable                     <a id="org123cddb"></a></h3>
<div class="outline-text-3" id="text-orgdb129c6">
<p>
Esta seccion contiene la realizacion de una version minima de
<a href="#org0458a76"><code>printf</code></a>, para Mostrar como escribir una funcion que procese una
lista de argumentos de longitud variable en una forma
transportable. Puesto que estamos interesados principalmente en el
procesamiento de argumentos, <code>minprintf</code> procesara la cadena de
formato y los argumentos, pero llamara al <a href="#org0458a76"><code>printf</code></a> real para hacer
las conversiones de formato.
</p>

<p>
La declaracion correcta para <a href="#org0458a76"><code>printf</code></a> es
</p>

<div class="org-src-container">
<pre class="src src-c"><span style="color: #98fb98;">int</span> <span style="color: #87cefa;">printf</span>(<span style="color: #98fb98;">char</span> *<span style="color: #eedd82;">fmt</span>, ...)
</pre>
</div>

<p>
donde la declaracion <code>...</code> significa que el numero y tipo de esos
argumentos puede variar. La declaracion <code>...</code> solo puede aparecer
al final de la lista de argumentos.
</p>

<p>
Nuestra <code>minprintf</code> se declara como
</p>

<div class="org-src-container">
<pre class="src src-c"><span style="color: #98fb98;">void</span> <span style="color: #87cefa;">minprintf</span> (<span style="color: #98fb98;">char</span> *<span style="color: #eedd82;">fmt</span>, ...)
</pre>
</div>

<p>
ya que no regresara la cuenta de caracteres que regresa <a href="#org0458a76"><code>printf</code></a>.
</p>

<p>
El truco esta en como <code>minprintf</code> recorre la lista de argumentos
cuando la lista ni siquiera tiene un nombre. El <i>header</i> estandar
<code>&lt;stdarg.h&gt;</code> contiene un conjunto de macrodefiniciones que definen
como avanzar sobre una lista de argumentos. La realizacion de este
<i>header</i> variara de una maquina a otra, pero la interfaz que
presenta es uniforme.
</p>

<p>
El tipo <code>va_list</code> se emplea para declarar una variable que se
referira a cada argumento en su momento; en <code>minprintf</code>, esta
variable se llama <code>ap</code>, por "argument pointer" (apuntador a
argumento). La macro <code>va_start</code> inicializa <code>ap</code> para apuntar al
primer argumento sin nombre. Debe llamarse una vez antes de usar
<code>ap</code>. Al menos debe haber un argumento con nombre; el ultimo
argumento con nombre es empleado por <code>va_start</code> para iniciar.
</p>

<p>
Cada llamada de <code>va_arg</code> regresa un argumento y avanza <code>ap</code> al
siguiente; <code>va_arg</code> emplea un nombre de tipo para determinar que
tipo regresar y cuan grande sera el avance. Finalmente, <code>va_end</code>
realiza las labores de limpieza y arreglo que sean necesarias. Debe
invocarse antes que la funcion regrese.
</p>

<p>
Estas propiedades forman la base de nuestro <a href="#org0458a76"><code>printf</code></a> simplificado:
</p>

<div class="org-src-container">
<pre class="src src-c"><span style="color: #b0c4de;">#include</span> <span style="color: #ffa07a;">&lt;stdarg.h&gt;</span>

<span style="color: #ff4500;">/* </span><span style="color: #ff4500;">minprintf: printf minima con lista variable de argumentos </span><span style="color: #ff4500;">*/</span>
<span style="color: #98fb98;">void</span> <span style="color: #87cefa;">minprintf</span>(<span style="color: #98fb98;">char</span> *<span style="color: #eedd82;">fmt</span>, ...)
{
  <span style="color: #98fb98;">va_list</span> <span style="color: #eedd82;">ap</span>;        <span style="color: #ff4500;">/* </span><span style="color: #ff4500;">apunta a cada arg sin nombre en orden     </span><span style="color: #ff4500;">*/</span>
  <span style="color: #98fb98;">char</span> *<span style="color: #eedd82;">p</span>, *<span style="color: #eedd82;">sval</span>;
  <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">ival</span>;
  <span style="color: #98fb98;">double</span> <span style="color: #eedd82;">dval</span>;

  va_start(ap, fmt); <span style="color: #ff4500;">/* </span><span style="color: #ff4500;">hace que ap apunte al 1er. arg sin nombre </span><span style="color: #ff4500;">*/</span>
  <span style="color: #00ffff;">for</span> (p = fmt; *p; p++) {
    <span style="color: #00ffff;">if</span> (*p != <span style="color: #ffa07a;">'%'</span>) {
      putchar(*p);
      <span style="color: #00ffff;">continue</span>;
    }
    <span style="color: #00ffff;">switch</span> (*++p) {
    <span style="color: #00ffff;">case</span> <span style="color: #ffa07a;">'d'</span>:
      ival = va_arg(ap, <span style="color: #98fb98;">int</span>);
      printf(<span style="color: #ffa07a;">"%d"</span>, ival);
      <span style="color: #00ffff;">break</span>;
    <span style="color: #00ffff;">case</span> <span style="color: #ffa07a;">'f'</span>:
      dval = va_arg(ap, <span style="color: #98fb98;">double</span>);
      printf(<span style="color: #ffa07a;">"%f"</span>, dval);
      <span style="color: #00ffff;">break</span>;
    <span style="color: #00ffff;">case</span> <span style="color: #ffa07a;">'s'</span>:
      <span style="color: #00ffff;">for</span> (sval = va_arg(ap, <span style="color: #98fb98;">char</span> *); *sval; sval++)
        putchar(*sval);
      <span style="color: #00ffff;">break</span>;
    <span style="color: #00ffff;">default</span>:
      putchar(*p);
      <span style="color: #00ffff;">break</span>;
    }
  }
  va_end(ap);        <span style="color: #ff4500;">/* </span><span style="color: #ff4500;">limpia cuando todo esta hecho             </span><span style="color: #ff4500;">*/</span>
}
</pre>
</div>

<p>
<b>Ejercicio 7-3</b>. Aumente <code>minprintf</code> para que maneje otras de las
caracteristicas de <a href="#org0458a76"><code>printf</code></a>.
</p>
</div>
</div>

<div id="outline-container-org6b76a23" class="outline-3">
<h3 id="org6b76a23">7.4  Entrada con formato - <a href="#orgb47aa6e"><code>scanf</code></a>                                 <a id="org58236a0"></a></h3>
<div class="outline-text-3" id="text-org6b76a23">
<p>
La funcion <a href="#orgb47aa6e"><code>scanf</code></a> es la entrada analoga de <a href="#org0458a76"><code>printf</code></a>, y proporciona
muchas de las mismas facilidades de conversion en la direccion
opuesta.
</p>

<div class="org-src-container">
<pre class="src src-c"><span style="color: #98fb98;">int</span> <span style="color: #87cefa;">scanf</span>(<span style="color: #98fb98;">char</span> *<span style="color: #eedd82;">format</span>, ...)
</pre>
</div>

<p>
<a href="#orgb47aa6e"><code>scanf</code></a> lee caracteres de la entrada estandar, los interpreta de
acuerdo con las especificaciones que estan en <code>format</code>, y almacena
los resultados a traves de los argumentos restantes. El argumento
de formato se describe abajo; los otros argumentos, <i>cada uno de
los cuales debe ser un apuntador</i>, indican donde debera almacenarse
la entrada correspondientemente convertida. Como con <a href="#org0458a76"><code>printf</code></a>, esta
seccion es un resumen de las posibilidades mas utiles, no una lista
exhaustiva.
</p>

<p>
<a href="#orgb47aa6e"><code>scanf</code></a> se detiene cuando termina con su cadena de formato, o
cuando alguna entrada no coincide con la especificacion de
control. Regresa como su valor el numero de items de entrada que
coinciden con exito. Esto se puede emplear para decidir cuantos
items se encontraron. Al final del archivo, regresa <code>EOF</code>; notese
que esto es diferente de <code>0</code>, que significa que el siguiente
caracter de entrada no coincide con la primera especificacion en la
cadena de formato. La siguiente llamada a <a href="#orgb47aa6e"><code>scanf</code></a> continua la
busqueda inmediatamente despues del ultimo caracter que ya fue
convertido.
</p>

<p>
Existe tambien una funcion <a href="#org704633d"><code>sscanf</code></a> que lee de una cadena y no de
la entrada estandar:
</p>

<div class="org-src-container">
<pre class="src src-c"><span style="color: #98fb98;">int</span> <span style="color: #87cefa;">sscanf</span>(<span style="color: #98fb98;">char</span> *<span style="color: #eedd82;">string</span>, <span style="color: #98fb98;">char</span> *<span style="color: #eedd82;">format</span>, arg1, arg2, ...)
</pre>
</div>

<p>
Rastrea la cadena <code>string</code> de acuerdo con el formato en <code>format</code>, y
almacena el valor resultante a traves de <code>arg1</code>, <code>arg2</code>, etc. Estos
argumentos deben ser apuntadores.
</p>

<p>
La cadena de formato generalmente contiene especificaciones de
conversion, las cuales son empleadas para controlar la conversion
de entrada. La cadena de formato puede contener:
</p>

<ul class="org-ul">
<li>Espacios o tabuladores, los cuales son ignorados.</li>

<li>Caracteres ordinarios (no <code>%</code>), que se espera coincidan con el
siguiente caracter que no sea espacio en blanco del flujo de
entrada.</li>

<li>Especificaciones de conversion, consistentes en el caracter <code>%</code>,
un caracter optativo de supresion de asignacion <code>*</code>, un numero
optativo que especifica el ancho maximo de campo, una <code>h</code>, <code>l</code>, o
<code>L</code> optativa que indica la amplitud del objetivo, y un caracter
de conversion.</li>
</ul>


<p>
La especificacion de conversion dirige la conversion del siguiente
campo de entrada. Normalmente el resultado se coloca en la variable
apuntada por el argumento correspondiente. Si se indica la
supresion de asignacion con el caracter <code>*</code>, sin embargo, el campo
de entrada es ignorado y no se realiza asignacion alguna. Un campo
de entrada esta definido como una cadena de caracteres que no son
espacio en blanco; se extiende hasta el siguiente espacio en blanco
o hasta que el ancho de campo se agote, si esta especificado. Esto
implica que <a href="#orgb47aa6e"><code>scanf</code></a> leera entre varias lineas para encontrar su
entrada, ya que las nuevas lineas son espacios en blanco. (Los
caracteres de espacio en blanco son tabulador, nueva linea, retorno
de carro, tabulador vertical y avance de hoja.)
</p>

<p>
El caracter de conversion indica la interpretacion del campo de
entrada. El argumento correspondiente debe ser un apuntador, como
es requerido por la semantica de las llamadas por valor de C. Los
caracteres de conversion se muestran en la <a href="#org6888039">tabla 7-2</a>.
</p>

<dl class="org-dl">
<dt><a id="org6888039">Tabla 7-2</a></dt><dd><p>
Conversiones basicas de <a href="#orgb47aa6e"><code>scanf</code></a>
</p>

<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-left" />

<col  class="org-left" />
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">CARACTER</th>
<th scope="col" class="org-left">Dato DE ENTRADA: TIPO DE ARGUMENTO:</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left">d</td>
<td class="org-left">entero decimal; <code>int *</code>.</td>
</tr>

<tr>
<td class="org-left">i</td>
<td class="org-left">entero; <code>int *</code>. El entero puede estar en octal (iniciado con <code>0</code>) o hexadecimal (iniciado con <code>Ox</code> o <code>OX</code>).</td>
</tr>

<tr>
<td class="org-left">o</td>
<td class="org-left">entero octal (con o sin cero inicial); <code>int *</code>.</td>
</tr>

<tr>
<td class="org-left">u</td>
<td class="org-left">entero decimal sin signo; <code>unsigned int *</code>.</td>
</tr>

<tr>
<td class="org-left">x</td>
<td class="org-left">entero hexadecimal (iniciado o no con <code>Ox</code> o <code>OX</code>); <code>int *</code>.</td>
</tr>

<tr>
<td class="org-left">c</td>
<td class="org-left">caracteres; <code>char *</code>. Los siguientes caracteres de entrada (por omision 1) son colocados en el sitio indicado. El salto normal sobre los espacios en blanco es suprimido; para leer el siguiente espacio no blanco, use <code>%1s</code>.</td>
</tr>

<tr>
<td class="org-left">s</td>
<td class="org-left">cadena de caracteres (no entrecomillada); <code>char *</code>, apunta a un arreglo de caracteres suficientemente grande para la cadena y una terminacion '\0' que sera agregada.</td>
</tr>

<tr>
<td class="org-left">e, f, g</td>
<td class="org-left">numero de punto flotante con signo, punto decimal y exponente optativos; <code>float *</code>.</td>
</tr>

<tr>
<td class="org-left">%</td>
<td class="org-left"><code>%</code> literal; no se hace asignacion alguna.</td>
</tr>
</tbody>
</table></dd>
</dl>


<p>
Los caracteres de conversion <code>d</code>, <code>i</code>, <code>o</code>, <code>u</code> y <code>x</code> pueden ser
precedidos por <code>h</code> para indicar que en la lista de argumentos
aparece un apuntador a <code>short</code> en lugar de a <code>int</code>, o por <code>l</code>
(letra ele) para indicar que aparece un apuntador a <code>long</code> en la
lista de argumentos. En forma semejante, los caracteres de
conversion <code>e</code>, <code>f</code>, <code>g</code> pueden ser precedidos por <code>l</code> para indicar
que hay un apuntador a <code>double</code> en lugar de a <code>float</code> en la lista
de argumentos.
</p>

<p>
Como un primer ejemplo, la rudimentaria calculadora del <a href="#org05a38fc">capitulo 4</a>
se puede escribir con <a href="#orgb47aa6e"><code>scanf</code></a> para hacer la conversion de entrada:
</p>

<div class="org-src-container">
<pre class="src src-c"><span style="color: #b0c4de;">#include</span> <span style="color: #ffa07a;">&lt;stdio.h&gt;</span>

<span style="color: #87cefa;">main</span>() <span style="color: #ff4500;">/* </span><span style="color: #ff4500;">calculadora rudimentaria </span><span style="color: #ff4500;">*/</span>
{
  <span style="color: #98fb98;">double</span> <span style="color: #eedd82;">sum</span>, <span style="color: #eedd82;">v</span>;

  sum = 0;
  <span style="color: #00ffff;">while</span> (scanf(<span style="color: #ffa07a;">"%lf"</span>, &amp;v) == 1)
    printf(<span style="color: #ffa07a;">"\t%.2f\n"</span>, sum += v);
  <span style="color: #00ffff;">return</span> 0;
}
</pre>
</div>

<p>
Suponga que deseamos leer lineas de entrada que contienen fechas de
la forma
</p>

<pre class="example">
25 Dic 1988
</pre>

<p>
La proposicion <a href="#orgb47aa6e"><code>scanf</code></a> es
</p>

<div class="org-src-container">
<pre class="src src-c"><span style="color: #98fb98;">int</span> <span style="color: #eedd82;">day</span>, <span style="color: #eedd82;">year</span>;
<span style="color: #98fb98;">char</span> <span style="color: #eedd82;">monthname</span>[20];

scanf(<span style="color: #ffa07a;">"%d %s %d"</span>, &amp;day, monthname, &amp;year);
</pre>
</div>

<p>
No se emplea <code>&amp;</code> con <code>monthname</code>, ya que un nombre de arreglo es un
apuntador.
</p>

<p>
Pueden aparecer caracteres literales en la cadena de formato de
<a href="#orgb47aa6e"><code>scanf</code></a>, y deben coincidir con los mismos caracteres de la
entrada. De modo que podemos leer fechas de la forma <code>mm/dd/yy</code> con
esta proposicion <a href="#orgb47aa6e"><code>scanf</code></a>:
</p>

<div class="org-src-container">
<pre class="src src-c"><span style="color: #98fb98;">int</span> <span style="color: #eedd82;">day</span>, <span style="color: #eedd82;">month</span>, <span style="color: #eedd82;">year</span>;

scanf(<span style="color: #ffa07a;">"%d/%d/%d"</span>, &amp;month, &amp;day, &amp;year);
</pre>
</div>

<p>
<a href="#orgb47aa6e"><code>scanf</code></a> ignora los blancos y los tabuladores que esten en su cadena
de formato. Ademas, salta sobre los espacios en blanco (blancos,
tabuladores, nuevas lineas etc.) mientras busca los valores de
entrada. Para leer de entradas cuyo formato no esta fijo, a menudo
es mejor leer una linea a la vez, y despues separarla con
<a href="#org704633d"><code>sscanf</code></a>. Por ejemplo, suponga que deseamos leer lineas que pueden
contener fechas en cualquiera de las formas anteriores. Entonces
podemos escribir
</p>

<div class="org-src-container">
<pre class="src src-c"><span style="color: #00ffff;">while</span> (getline(line, <span style="color: #00ffff;">sizeof</span>(line)) &gt; 0) {
  <span style="color: #00ffff;">if</span> (sscanf(line, <span style="color: #ffa07a;">"%d %s %d"</span>, &amp;day, monthname, &amp;year) == 3)
    printf(<span style="color: #ffa07a;">"valid: %s\n"</span>, line);             <span style="color: #ff4500;">/* </span><span style="color: #ff4500;">forma 25 Dic 1988 </span><span style="color: #ff4500;">*/</span>
  <span style="color: #00ffff;">else</span> <span style="color: #00ffff;">if</span> (sscanf(line, <span style="color: #ffa07a;">"%d/%d/%d"</span>, &amp;month, &amp;day, &amp;year) == 3)
    printf(<span style="color: #ffa07a;">"valid: %s\n"</span>, line);             <span style="color: #ff4500;">/* </span><span style="color: #ff4500;">forma mm/dd/yy    </span><span style="color: #ff4500;">*/</span>
  <span style="color: #00ffff;">else</span>
    printf(<span style="color: #ffa07a;">"invalid: %s\n"</span>, line);           <span style="color: #ff4500;">/* </span><span style="color: #ff4500;">forma invalida    </span><span style="color: #ff4500;">*/</span>
 }
</pre>
</div>

<p>
Las llamadas a <a href="#orgb47aa6e"><code>scanf</code></a> pueden estar mezcladas con llamadas a otras
funciones de entrada. La siguiente llamada a cualquier funcion de
entrada iniciara leyendo el primer caracter no leido por <a href="#orgb47aa6e"><code>scanf</code></a>.
</p>

<p>
Una advertencia final: los argumentos de <a href="#orgb47aa6e"><code>scanf</code></a> y <a href="#org704633d"><code>sscanf</code></a> deben
ser apuntadores. El error mas comun es escribir
</p>

<div class="org-src-container">
<pre class="src src-c">scanf(<span style="color: #ffa07a;">"%d"</span>, n);
</pre>
</div>

<p>
en lugar de
</p>

<div class="org-src-container">
<pre class="src src-c">scanf(<span style="color: #ffa07a;">"%d"</span>, &amp;n);
</pre>
</div>

<p>
Este error generalmente no se detecta en tiempo de compilacion.
</p>

<p>
<b>Ejercicio 7-4</b>. Escriba una version privada de <a href="#orgb47aa6e"><code>scanf</code></a> analoga a
minprintf de la seccion anterior.
</p>

<p>
<b>Ejercicio 7-5</b>. Reescriba la calculadora postfija del <a href="#org05a38fc">capitulo 4</a>
usando <a href="#orgb47aa6e"><code>scanf</code></a> y/o <a href="#org704633d"><code>sscanf</code></a> para hacer la entrada y la conversion.
</p>
</div>
</div>

<div id="outline-container-org1da08db" class="outline-3">
<h3 id="org1da08db">7.5  Acceso a archivos                                             <a id="orgef678ae"></a></h3>
<div class="outline-text-3" id="text-org1da08db">
<p>
Hasta ahora todos los ejemplos han leido de la entrada estandar y
escrito en la salida estandar, las cuales se definen
automaticamente para los programas por el sistema operativo local.
</p>

<p>
El siguiente paso es escribir un programa que de acceso a un
archivo que no este ya conectado al programa. Un programa que
ilustra la necesidad de tales operaciones es <code>cat</code>, el cual
concatena en la salida estandar un conjunto de archivos nombrados,
<code>cat</code> se emplea para escribir archivos en la pantalla, y como un
colector de entradas de proposito general para programas que no
disponen de la capacidad de tener acceso a los archivos por
nombre. Por ejemplo, la orden
</p>

<div class="org-src-container">
<pre class="src src-sh">cat x.c y.c
</pre>
</div>

<p>
imprime el contenido de los archivos <code>x.c</code> y <code>y.c</code> (y nada mas) en
la salida estandar.
</p>

<p>
La pregunta es como hacer que los archivos nombrados sean leidos –
esto es, como conectar las proposiciones que leen los datos, con
los nombres externos que un usuario tiene en mente.
</p>

<p>
Las reglas son simples. Antes de que pueda ser leido o escrito, un
archivo tiene que ser <i>abierto</i> por la funcion de biblioteca
<a href="#orgd6dbcbe"><code>fopen</code></a>, la cual toma un nombre externo como <code>x.c</code> o <code>y.c</code>, hace
algunos arreglos y negociaciones con el sistema operativo (cuyos
detalles no deben importarnos), y regresa un apuntador que sera
usado en posteriores lecturas o escrituras del archivo.
</p>

<p>
Este apuntador, llamado <i>apuntador de archivo</i>, apunta a una
estructura que contiene informacion acerca del archivo, tal como la
ubicacion de un buffer, la posicion de caracter actual en el
buffer, si el archivo esta siendo leido o escrito y si han ocurrido
errores o fin de archivo. Los usuarios no necesitan saber los
detalles, debido a que las definiciones obtenidas de <code>&lt;stdio.h&gt;</code>
incluyen una declaracion de estructura llamada <code>FILE</code>. La unica
declaracion necesaria para un apuntador de archivo se ejemplifica
por
</p>

<div class="org-src-container">
<pre class="src src-c"><span style="color: #98fb98;">FILE</span> *<span style="color: #eedd82;">fp</span>;
<span style="color: #98fb98;">FILE</span> *<span style="color: #87cefa;">fopen</span>(<span style="color: #98fb98;">char</span> *<span style="color: #eedd82;">nombre</span>, <span style="color: #98fb98;">char</span> *<span style="color: #eedd82;">modo</span>);
</pre>
</div>

<p>
Esto dice que <code>fp</code> es un apuntador a un <code>FILE</code>, y <a href="#orgd6dbcbe"><code>fopen</code></a> regresa
un apuntador a <code>FILE</code>. Notese que <code>FILE</code> es un nombre de tipo, como
<code>int</code>, no una etiqueta de estructura; esta definido con un
<code>typedef</code>. (Los detalles de como realizar <a href="#orgd6dbcbe"><code>fopen</code></a> en el sistema
<code>UNIX</code> se explican en la <a href="#orge4244db">seccion 8.5</a>.)
</p>

<p>
La llamada a <a href="#orgd6dbcbe"><code>fopen</code></a> en un programa es
</p>

<div class="org-src-container">
<pre class="src src-c">fp = fopen(nombre, modo);
</pre>
</div>

<p>
El primer argumento de <a href="#orgd6dbcbe"><code>fopen</code></a> es una cadena de caracteres que
contiene el nombre del archivo. El segundo argumento es el <i>modo</i>,
tambien una cadena de caracteres, que indica como se intenta
emplear el archivo. Los modos disponibles incluyen lectura ("r"),
escritura ("w"), y añadido ("a"). Algunos sistemas distinguen entre
archivos de texto y binarios; para los ultimos, debe escribirse una
"b" luego de la cadena de modo.
</p>

<p>
Si un archivo que no existe se abre para escribir o añadir, se
crea, si es posible. Abrir un archivo existente para escribir
provoca que los contenidos anteriores sean desechados, mientras que
abrirlo para añadir los preserva. Es un error tratar de leer un
archivo que no existe, y tambien pueden haber otras causas de
error, como tratar de leer un archivo cuando no se tiene
permiso. Si existe cualquier error, <a href="#orgd6dbcbe"><code>fopen</code></a> regresa <code>NULL</code>. (El
error puede ser identificado en forma mas precisa; vease la
discusion de funciones para manipulacion de errores al final de la
<a href="#org7c1fb2a">seccion 1</a> en el <a href="#org89d4232">apendice B</a>.)
</p>

<p>
Lo siguiente que se requiere es una forma de leer o escribir el
archivo una vez que esta abierto. Existen varias posibilidades, de
las cuales <a href="#org7181de4"><code>getc</code></a> y <a href="#org38237ac"><code>putc</code></a> son las mas simples, <a href="#org7181de4"><code>getc</code></a> regresa el
siguiente caracter de un archivo; necesita el apuntador del archivo
para decirle cual es.
</p>

<div class="org-src-container">
<pre class="src src-c"><span style="color: #98fb98;">int</span> <span style="color: #87cefa;">getc</span>(<span style="color: #98fb98;">FILE</span> *<span style="color: #eedd82;">fp</span>)
</pre>
</div>

<p>
<a href="#org7181de4"><code>getc</code></a> regresa el siguiente caracter del flujo al que se refiere
<code>fp</code>; regresa <code>EOF</code> si ocurre algun error.
</p>

<p>
<a href="#org38237ac"><code>putc</code></a> es una funcion de salida:
</p>

<div class="org-src-container">
<pre class="src src-c"><span style="color: #98fb98;">int</span> <span style="color: #87cefa;">putc</span>(<span style="color: #98fb98;">int</span> <span style="color: #eedd82;">c</span>, <span style="color: #98fb98;">FILE</span> *<span style="color: #eedd82;">fp</span>)
</pre>
</div>

<p>
<a href="#org38237ac"><code>putc</code></a> escribe el caracter <code>c</code> en el archivo <code>fp</code> y regresa el
caracter escrito, o <code>EOF</code> si ocurre un error. Tal como <a href="#org4d38061"><code>getchar</code></a> y
<a href="#orgc7f0a8a"><code>putchar</code></a>, <a href="#org7181de4"><code>getc</code></a> y <a href="#org38237ac"><code>putc</code></a> pueden ser macros en lugar de funciones.
</p>

<p>
Cuando se arranca un programa en C, el medio ambiente del sistema
operativo es responsable de abrir tres archivos y proporcionar
apuntadores de archivo para ellos. Estos archivos son la entrada
estandar, la salida estandar y el error estandar; los apuntadores
de archivo correspondientes se llaman <code>stdin</code>, <code>stdout</code> y <code>stderr</code>,
y estan declarados en <code>&lt;stdio.h&gt;</code>. Normalmente <code>stdin</code> se conecta
al teclado y <code>stdout</code> y <code>stderr</code> se conectan a la pantalla, pero
<code>stdin</code> y <code>stdout</code> pueden ser redirigidos a archivos o a
interconexiones (pipes) como se describe en la <a href="#org009b376">seccion 7.1</a>.
</p>

<p>
<a href="#org4d38061"><code>getchar</code></a> y <a href="#orgc7f0a8a"><code>putchar</code></a> pueden estar definidos en terminos de <a href="#org7181de4"><code>getc</code></a>,
<a href="#org38237ac"><code>putc</code></a>, <code>stdin</code> y <code>stdout</code>, como sigue:
</p>

<div class="org-src-container">
<pre class="src src-c"><span style="color: #b0c4de;">#define</span> <span style="color: #87cefa;">getchar</span>()     getc(stdin)
<span style="color: #b0c4de;">#define</span> <span style="color: #87cefa;">putchar</span>(<span style="color: #eedd82;">c</span>)    putc((c), stdout)
</pre>
</div>

<p>
Para entrada o salida de archivos con formato se pueden emplear las
funciones <a href="#org871b649"><code>fscanf</code></a> y <a href="#org74b2389"><code>fprintf</code></a>. Estas son identicas a <a href="#orgb47aa6e"><code>scanf</code></a> y
<a href="#org0458a76"><code>printf</code></a>, excepto en que el primer argumento es un apuntador de
archivo que especifica el archivo que sera leido o escrito; la
cadena de formato es el segundo argumento.
</p>

<div class="org-src-container">
<pre class="src src-c"><span style="color: #98fb98;">int</span> <span style="color: #87cefa;">fscanf</span>(<span style="color: #98fb98;">FILE</span> *<span style="color: #eedd82;">fp</span>, <span style="color: #98fb98;">char</span> *<span style="color: #eedd82;">formato</span>, ...)
<span style="color: #98fb98;">int</span> <span style="color: #87cefa;">fprintf</span>(<span style="color: #98fb98;">FILE</span> *<span style="color: #eedd82;">fp</span>, <span style="color: #98fb98;">char</span> *<span style="color: #eedd82;">formato</span>, ...)
</pre>
</div>

<p>
Habiendo hecho a un lado estos prerrequisitos, ya estamos ahora en
posicion de escribir el programa <code>cat</code>, que concatena archivos. El
diseño se ha encontrado conveniente para muchos programas. Si
existen argumentos en la linea de ordenes, se interpretan como
nombres de archivos, y se procesan en orden. Si no hay argumentos,
se procesa la entrada estandar.
</p>

<div class="org-src-container">
<pre class="src src-c"><span style="color: #b0c4de;">#include</span> <span style="color: #ffa07a;">&lt;stdio.h&gt;</span>

<span style="color: #ff4500;">/* </span><span style="color: #ff4500;">cat: concatena archivos, version 1 </span><span style="color: #ff4500;">*/</span>
<span style="color: #87cefa;">main</span>(<span style="color: #98fb98;">int</span> <span style="color: #eedd82;">argc</span>, <span style="color: #98fb98;">char</span> *<span style="color: #eedd82;">argv</span>[])
{
  <span style="color: #98fb98;">FILE</span> *<span style="color: #eedd82;">fp</span>;
  <span style="color: #98fb98;">void</span> <span style="color: #87cefa;">filecopy</span>(<span style="color: #98fb98;">FILE</span> *, <span style="color: #98fb98;">FILE</span> *);

  <span style="color: #00ffff;">if</span> (argc == 1)    <span style="color: #ff4500;">/* </span><span style="color: #ff4500;">sin args; copia la entrada estandar </span><span style="color: #ff4500;">*/</span>
    filecopy(stdin, stdout);
  <span style="color: #00ffff;">else</span>
    <span style="color: #00ffff;">while</span>(--argc &gt; 0)
      <span style="color: #00ffff;">if</span> ((fp = fopen(*++argv, <span style="color: #ffa07a;">"r"</span>)) == <span style="color: #7fffd4;">NULL</span>) {
        printf(<span style="color: #ffa07a;">"cat: no se puede abrir %s\n"</span>, *argv);
        <span style="color: #00ffff;">return</span> 1;
      } <span style="color: #00ffff;">else</span> {
        filecopy(fp, stdout);
        fclose(fp);
      }
  <span style="color: #00ffff;">return</span> 0;
}

<span style="color: #ff4500;">/* </span><span style="color: #ff4500;">filecopy: copia el archivo ifp al archivo ofp </span><span style="color: #ff4500;">*/</span>
<span style="color: #98fb98;">void</span> <span style="color: #87cefa;">filecopy</span>(<span style="color: #98fb98;">FILE</span> *<span style="color: #eedd82;">ifp</span>, <span style="color: #98fb98;">FILE</span> *<span style="color: #eedd82;">ofp</span>)
{
  <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">c</span>;
  <span style="color: #00ffff;">while</span> ((c = getc(ifp)) != EOF)
    putc(c, ofp);
}
</pre>
</div>

<p>
Los apuntadores de archivo <code>stdin</code> y <code>stdout</code> son objetos de tipo
<code>FILE *</code>. Sin embargo, son constantes, no variables, por lo que no
es posible asignarles algo.
</p>

<p>
La funcion
</p>

<div class="org-src-container">
<pre class="src src-c"><span style="color: #98fb98;">int</span> <span style="color: #87cefa;">fclose</span>(<span style="color: #98fb98;">FILE</span> *<span style="color: #eedd82;">fp</span>)
</pre>
</div>

<p>
es lo inverso de <a href="#orgd6dbcbe"><code>fopen</code></a>; interrumpe la conexion que fue
establecida por <a href="#orgd6dbcbe"><code>fopen</code></a> entre el apuntador de archivo y el nombre
externo, liberando al apuntador de archivo para otro archivo.
Puesto que la mayoria de los sistemas operativos tienen algunas
limitantes sobre el numero de archivos que un programa puede tener
abiertos simultaneamente, es una buena idea liberar los apuntadores
de archivo cuando ya no son necesarios, como se hizo en <code>cat</code>.
Tambien hay otra razon para usar <a href="#orge0fc4f1"><code>fclose</code></a> en un archivo de salida –
vacia el buffer en el cual <a href="#org38237ac"><code>putc</code></a> esta colectando la salida. Cuando
un programa termina normalmente, <a href="#orge0fc4f1"><code>fclose</code></a> es llamado
automaticamente para cada archivo abierto. (Se puede cerrar <code>stdin</code>
y <code>stdout</code> si no son necesarios. Tambien pueden ser reasignados por
la funcion de biblioteca <a href="#orgc1d8ed1"><code>freopen</code></a>.)
</p>
</div>
</div>

<div id="outline-container-org320c33f" class="outline-3">
<h3 id="org320c33f">7.6  Manejo de errores - <code>stderr</code> y <a href="#org394ccc4"><code>exit</code></a>                         <a id="org8c94beb"></a></h3>
<div class="outline-text-3" id="text-org320c33f">
<p>
El manejo de los errores en <code>cat</code> no es el ideal. El problema es
que si no se puede tener acceso a uno de los archivos por alguna
razon, el diagnostico se imprime al final de la salida
concatenada. Eso podria ser aceptable si la salida va a la
pantalla, pero no si va hacia un archivo o hacia otro programa
mediante una interconexion.
</p>

<p>
Para manejar mejor esta situacion, se asigna un segundo flujo de
salida, llamado <code>stderr</code>, a un programa en la misma forma en que
<code>stdin</code> y <code>stdout</code>. La salida escrita hacia <code>stderr</code> normalmente
aparece en la pantalla, aun si la salida estandar es redirigida.
</p>

<p>
Corrijamos <code>cat</code> para escribir sus mensajes de error en el archivo
de error estandar.
</p>

<div class="org-src-container">
<pre class="src src-c"><span style="color: #b0c4de;">#include</span> <span style="color: #ffa07a;">&lt;stdio.h&gt;</span>

<span style="color: #ff4500;">/* </span><span style="color: #ff4500;">cat: concatena archivos, version 2 </span><span style="color: #ff4500;">*/</span>
<span style="color: #87cefa;">main</span>(<span style="color: #98fb98;">int</span> <span style="color: #eedd82;">argc</span>, <span style="color: #98fb98;">char</span> *<span style="color: #eedd82;">argv</span>[])
{
  <span style="color: #98fb98;">FILE</span> *<span style="color: #eedd82;">fp</span>;
  <span style="color: #98fb98;">void</span> <span style="color: #87cefa;">filecopy</span>(<span style="color: #98fb98;">FILE</span> *, <span style="color: #98fb98;">FILE</span> *);
  <span style="color: #98fb98;">char</span> *<span style="color: #eedd82;">prog</span> = argv[0];   <span style="color: #ff4500;">/* </span><span style="color: #ff4500;">nombre del programa para errores </span><span style="color: #ff4500;">*/</span>

  <span style="color: #00ffff;">if</span> (argc == 1)          <span style="color: #ff4500;">/* </span><span style="color: #ff4500;">sin args; copia la entrada estandar </span><span style="color: #ff4500;">*/</span>
    filecopy(stdin, stdout);
  <span style="color: #00ffff;">else</span>
    <span style="color: #00ffff;">while</span>(--argc &gt; 0)
      <span style="color: #00ffff;">if</span> ((fp = fopen(*++argv, <span style="color: #ffa07a;">"r"</span>)) == <span style="color: #7fffd4;">NULL</span>) {
        fprintf(stderr, <span style="color: #ffa07a;">"%s: no se puede abrir %s\n"</span>, prog, *argv);
        exit(1);
      } <span style="color: #00ffff;">else</span> {
        filecopy(fp, stdout);
        fclose(fp);
      }
  <span style="color: #00ffff;">if</span> (ferror(stdout)){
    fprintf(stderr, <span style="color: #ffa07a;">"%s: error al escribir stdout\n"</span>, prog);
    exit(2);
  }
  exit(0);
}
</pre>
</div>

<p>
El programa señala errores en dos maneras. Primero, la salida de
diagnosticos producida por <a href="#org74b2389"><code>fprintf</code></a> va hacia <code>stderr</code>, de modo que
encuentra su camino hacia la pantalla en lugar de desaparecer en
una interconexion o dentro de un archivo de salida. Incluimos el
nombre del programa, tomandolo de <code>argv[0]</code>, en el mensaje, para
que si este programa se usa con otros, se identifique la fuente del
error.
</p>

<p>
Segundo, el programa utiliza la funcion de biblioteca estandar
<a href="#org394ccc4"><code>exit</code></a>, que termina la ejecucion de un programa cuando se le
llama. El argumento de <a href="#org394ccc4"><code>exit</code></a> esta disponible para cualquier
proceso que haya llamado a este, para que se pueda probar el exito
o fracaso del programa por otro que lo use como
subproceso. Convencionalmente, un valor de retorno <code>0</code> señala que
todo esta bien; los valores diferentes de cero generalmente señalan
situaciones anormales, <a href="#org394ccc4"><code>exit</code></a> llama a <a href="#orge0fc4f1"><code>fclose</code></a> por cada archivo de
salida abierto, para vaciar cualquier salida generada a traves de
un buffer.
</p>

<p>
Dentro de <code>main</code>, <code>return</code> <i>expr</i> es equivalente a <code>exit (expr)</code>.
<a href="#org394ccc4"><code>exit</code></a> tiene la ventaja de que puede ser llamada desde otras
funciones, y que las llamadas a ella se pueden encontrar con un
programa de busqueda de patrones como el del <a href="#org69d49af">capitulo 5</a>.
</p>

<p>
La funcion <a href="#orgc3f53c8"><code>ferror</code></a> regresa un valor diferente de cero si ocurrio
un error en el flujo <code>fp</code>.
</p>

<div class="org-src-container">
<pre class="src src-c"><span style="color: #98fb98;">int</span> <span style="color: #87cefa;">ferror</span>(<span style="color: #98fb98;">FILE</span> *<span style="color: #eedd82;">fp</span>)
</pre>
</div>

<p>
Aunque los errores de salida son raros, si ocurren (por ejemplo, si
un disco se llena), por lo que los programas de produccion deben
revisar tambien esto.
</p>

<p>
La funcion <code>feof(FILE *)</code> es analoga a <a href="#orgc3f53c8"><code>ferror</code></a>; regresa un valor
diferente de cero si ha ocurrido un fin de archivo en el archivo
especificado.
</p>

<div class="org-src-container">
<pre class="src src-c"><span style="color: #98fb98;">int</span> <span style="color: #87cefa;">feof</span>(<span style="color: #98fb98;">FILE</span> *<span style="color: #eedd82;">fp</span>)
</pre>
</div>

<p>
En general, no nos hemos preocupado por el estado de la salida de
nuestros pequeños programas ilustrativos, pero todo programa serio
debe tener cuidado de regresar valores de estado sensatos y utiles.
</p>
</div>
</div>

<div id="outline-container-orge5bbcf2" class="outline-3">
<h3 id="orge5bbcf2">7.7  Entrada y salida de lineas                                    <a id="org60c1e77"></a></h3>
<div class="outline-text-3" id="text-orge5bbcf2">
<p>
La biblioteca estandar proporciona una rutina de entrada <a href="#org720aa41"><code>fgets</code></a>,
es semejante a la funcion <code>getline</code> que hemos empleado en capitulos
anteriores:
</p>

<div class="org-src-container">
<pre class="src src-c"><span style="color: #98fb98;">char</span> *<span style="color: #87cefa;">fgets</span>(<span style="color: #98fb98;">char</span> *<span style="color: #eedd82;">linea</span>, <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">maxlinea</span>, <span style="color: #98fb98;">FILE</span> *<span style="color: #eedd82;">fp</span>)
</pre>
</div>

<p>
<a href="#org720aa41"><code>fgets</code></a> lee la siguiente linea (incluyendo el caracter nueva linea)
del archivo <code>fp</code> y la deja en el arreglo de caracteres <code>linea</code>; se
leen hasta <code>maxline-1</code> caracteres. La linea resultante se termina
con '\0'. Normalmente, <a href="#org720aa41"><code>fgets</code></a> regresa <code>linea</code>; en caso de fin de
archivo o de error, regresa <code>NULL</code>. (Nuestra <code>getline</code> regresa la
longitud de la linea, que es un valor mas util; cero significa fin
de archivo.)
</p>

<p>
Para salida, la funcion <a href="#org2ce723f"><code>fputs</code></a> escribe una cadena (que no necesita
contener una nueva linea) a un archivo:
</p>

<div class="org-src-container">
<pre class="src src-c"><span style="color: #98fb98;">int</span> <span style="color: #87cefa;">fputs</span>(<span style="color: #98fb98;">char</span> *<span style="color: #eedd82;">linea</span>, <span style="color: #98fb98;">FILE</span> *<span style="color: #eedd82;">fp</span>)
</pre>
</div>

<p>
Esta funcion regresa <code>EOF</code> si ocurre un error y cero si no ocurre.
</p>

<p>
Las funciones de biblioteca <a href="#org27cb039"><code>gets</code></a> y <a href="#org039469f"><code>puts</code></a> son semejantes a
<a href="#org720aa41"><code>fgets</code></a> y <a href="#org2ce723f"><code>fputs</code></a>, pero operan sobre <code>stdin</code> y <code>stdout</code>. De modo
desconcertante, <a href="#org27cb039"><code>gets</code></a> elimina el '\n' terminal y <a href="#org039469f"><code>puts</code></a> lo agrega.
</p>

<p>
Para mostrar que no hay nada especial sobre funciones como <a href="#org720aa41"><code>fgets</code></a>
y <a href="#org2ce723f"><code>fputs</code></a>, aqui estan, copiadas de la biblioteca estandar de
nuestro sistema:
</p>

<div class="org-src-container">
<pre class="src src-c"><span style="color: #ff4500;">/* </span><span style="color: #ff4500;">fgets: obtiene hasta n caracteres de iop </span><span style="color: #ff4500;">*/</span>
<span style="color: #98fb98;">char</span> *<span style="color: #87cefa;">fgets</span>(<span style="color: #98fb98;">char</span> *<span style="color: #eedd82;">s</span>, <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">n</span>, <span style="color: #98fb98;">FILE</span> *<span style="color: #eedd82;">iop</span>)
{
  <span style="color: #00ffff;">register</span> <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">c</span>;
  <span style="color: #00ffff;">register</span> <span style="color: #98fb98;">char</span> *<span style="color: #eedd82;">cs</span>;

  cs = s;
  <span style="color: #00ffff;">while</span> (--n &gt; 0 &amp;&amp; (c = getc(iop)) != EOF)
    <span style="color: #00ffff;">if</span> ((*cs++ = c) == <span style="color: #ffa07a;">'\n'</span>)
      <span style="color: #00ffff;">break</span>;
  *cs = <span style="color: #ffa07a;">'\0'</span>;
  <span style="color: #00ffff;">return</span> (c == EOF &amp;&amp; cs == s) ? <span style="color: #7fffd4;">NULL</span> : s;
}

<span style="color: #ff4500;">/* </span><span style="color: #ff4500;">fputs: coloca la cadena s en el archivo iop </span><span style="color: #ff4500;">*/</span>
<span style="color: #98fb98;">int</span> <span style="color: #87cefa;">fputs</span>(<span style="color: #98fb98;">char</span> *<span style="color: #eedd82;">s</span>, <span style="color: #98fb98;">FILE</span> *<span style="color: #eedd82;">iop</span>)
{
  <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">c</span>;

  <span style="color: #00ffff;">while</span> (c = *s++)
    putc(c, iop);
  <span style="color: #00ffff;">return</span> ferror(iop) ? EOF : 0;
}
</pre>
</div>

<p>
Por razones que no son obvias, el estandar especifica valores de
retorno diferentes para <a href="#org720aa41"><code>fgets</code></a> y <a href="#org2ce723f"><code>fputs</code></a>.
</p>

<p>
Es facil realizar nuestro <code>getline</code> a partir de <a href="#org720aa41"><code>fgets</code></a>:
</p>

<div class="org-src-container">
<pre class="src src-c"><span style="color: #ff4500;">/* </span><span style="color: #ff4500;">getline: lee una linea, regresa su longitud </span><span style="color: #ff4500;">*/</span>
<span style="color: #98fb98;">int</span> <span style="color: #87cefa;">getline</span>(<span style="color: #98fb98;">char</span> *<span style="color: #eedd82;">line</span>, <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">max</span>)
{
  <span style="color: #00ffff;">if</span> (fgets(line, max, stdin) == <span style="color: #7fffd4;">NULL</span>)
    <span style="color: #00ffff;">return</span> 0;
  <span style="color: #00ffff;">else</span>
    <span style="color: #00ffff;">return</span> strlen(line);
}
</pre>
</div>

<p>
<b>Ejercicio 7-6</b>. Escriba un programa para comparar dos archivos,
imprimiendo la primera linea en donde difieran.
</p>

<p>
<b>Ejercicio 7-7</b>. Modifique el programa de busqueda de un patron del
<a href="#org69d49af">capitulo 5</a> para que tome su entrada de un conjunto de archivos
nombrados o, si no hay archivos nombrados como argumentos, de la
entrada estandar. ¿Debe escribirse el nombre del archivo cuando se
encuentra una linea que coincide?
</p>

<p>
<b>Ejercicio 7-8</b>. Escriba un programa para imprimir un conjunto de
archivos, iniciando cada nuevo archivo en una pagina nueva, con un
titulo y un contador de pagina por cada archivo.
</p>
</div>
</div>

<div id="outline-container-org7d23f09" class="outline-3">
<h3 id="org7d23f09">7.8  Otras funciones                                               <a id="org76dfc8c"></a></h3>
<div class="outline-text-3" id="text-org7d23f09">
<p>
La biblioteca estandar proporciona una amplia variedad de
funciones. Esta seccion es una breve sinopsis de las mas utiles. En
el <a href="#org89d4232">apendice B</a> pueden encontrarse mas detalles y muchas otras
funciones.
</p>
</div>

<div id="outline-container-org6aef657" class="outline-4">
<h4 id="org6aef657">7.8.1 Operaciones sobre cadenas                                   <a id="org4420b14"></a></h4>
<div class="outline-text-4" id="text-org6aef657">
<p>
Ya hemos mencionado las funciones sobre cadenas <code>strlen</code>,
<code>strcpy</code>, <code>strcat</code>, y <code>strcmp</code>, que se encuentran en <code>&lt;string.h&gt;</code>.
En adelante, <code>s</code> y <code>t</code> son de tipo <code>char *</code>, y <code>c</code> y <code>n</code> son
<code>int</code>.
</p>

<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-left" />

<col  class="org-left" />
</colgroup>
<tbody>
<tr>
<td class="org-left"><code>strcat(s,t)</code></td>
<td class="org-left">concatena <code>t</code> al final de <code>s</code></td>
</tr>

<tr>
<td class="org-left"><code>strncat(s,t,n)</code></td>
<td class="org-left">concatena <code>n</code> caracteres de <code>t</code> al final de <code>s</code></td>
</tr>

<tr>
<td class="org-left"><code>strcmp(s,t)</code></td>
<td class="org-left">regresa negativo, cero, o positivo para <code>s &lt; t</code>, <code>s == t</code>, o <code>s &gt; t</code></td>
</tr>

<tr>
<td class="org-left"><code>strncmp(s,t,n)</code></td>
<td class="org-left">igual que <code>strcmp</code> pero solo en los primeros <code>n</code> caracteres</td>
</tr>

<tr>
<td class="org-left"><code>strcpy(s,t)</code></td>
<td class="org-left">copia <code>t</code> en <code>s</code></td>
</tr>

<tr>
<td class="org-left"><code>strncpy(s,t,n)</code></td>
<td class="org-left">copia a lo mas <code>n</code> caracteres de <code>t</code> a <code>s</code></td>
</tr>

<tr>
<td class="org-left"><code>strlen(s)</code></td>
<td class="org-left">regresa la longitud de <code>s</code></td>
</tr>

<tr>
<td class="org-left"><code>strchr(s,c)</code></td>
<td class="org-left">regresa un apuntador al primer <code>c</code> que este en <code>s</code>, o <code>NULL</code> si no esta presente</td>
</tr>

<tr>
<td class="org-left"><code>strrchr(s,c)</code></td>
<td class="org-left">regresa un apuntador al ultimo <code>c</code> que este en <code>s</code>, o <code>NULL</code> si no esta presente</td>
</tr>
</tbody>
</table>
</div>
</div>

<div id="outline-container-orgaf127ef" class="outline-4">
<h4 id="orgaf127ef">7.8.2 Prueba y conversion de clases de caracteres                 <a id="org5879803"></a></h4>
<div class="outline-text-4" id="text-orgaf127ef">
<p>
Varias funciones de <code>&lt;ctype.h&gt;</code> realizan pruebas y conversiones de
caracteres. En lo que se muestra a continuacion, <code>c</code> es un <code>int</code>
que se puede representar como un <code>unsigned char</code> o <code>EOF</code>. Las
funciones regresan <code>int</code>.
</p>

<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-left" />

<col  class="org-left" />
</colgroup>
<tbody>
<tr>
<td class="org-left"><code>isalpha(c)</code></td>
<td class="org-left">diferente de cero si <code>c</code> es albafetica, <code>0</code> si no lo es</td>
</tr>

<tr>
<td class="org-left"><code>isupper(c)</code></td>
<td class="org-left">diferente de cero si <code>c</code> es mayuscula, <code>0</code> si no lo es</td>
</tr>

<tr>
<td class="org-left"><code>islower(c)</code></td>
<td class="org-left">diferente de cero si <code>c</code> es minuscula, <code>0</code> si no lo es</td>
</tr>

<tr>
<td class="org-left"><code>isdigit(c)</code></td>
<td class="org-left">diferente de cero si <code>c</code> un digito, <code>0</code> si no lo es</td>
</tr>

<tr>
<td class="org-left"><code>isalnum(c)</code></td>
<td class="org-left">diferente de cero si <code>isalpha(c)</code> o <code>isdigit(c)</code>, <code>0</code> si no lo es</td>
</tr>

<tr>
<td class="org-left"><code>isspace(c)</code></td>
<td class="org-left">diferente de cero si <code>c</code> es un blanco, tabulador, nueva linea, retorno, avance de linea tabulador vertical</td>
</tr>

<tr>
<td class="org-left"><code>toupper(c)</code></td>
<td class="org-left">regresa <code>c</code> convertida a mayuscula</td>
</tr>

<tr>
<td class="org-left"><code>tolower(c)</code></td>
<td class="org-left">regresa <code>c</code> convertida a minuscula</td>
</tr>
</tbody>
</table>
</div>
</div>

<div id="outline-container-orgacf4478" class="outline-4">
<h4 id="orgacf4478">7.8.3 <a href="#org32f1014"><code>ungetc</code></a>                                                    <a id="org38e9a50"></a></h4>
<div class="outline-text-4" id="text-orgacf4478">
<p>
La biblioteca estandar proporciona una version mas restringida de
la funcion <code>ungetch</code> que escribimos en el <a href="#org05a38fc">capitulo 4</a>; se llama
<a href="#org32f1014"><code>ungetc</code></a>.
</p>

<div class="org-src-container">
<pre class="src src-c"><span style="color: #98fb98;">int</span> <span style="color: #87cefa;">ungetc</span>(<span style="color: #98fb98;">int</span> <span style="color: #eedd82;">c</span>, <span style="color: #98fb98;">FILE</span> *<span style="color: #eedd82;">fp</span>)
</pre>
</div>

<p>
coloca el caracter <code>c</code> de nuevo en el archivo <code>fp</code> y regresa <code>c</code>,
o <code>EOF</code> en caso de error. Solo se garantiza poner un caracter de
regreso por archivo. Es posible utilizar <a href="#org32f1014"><code>ungetc</code></a> con cualquiera
de las funciones como <a href="#orgb47aa6e"><code>scanf</code></a>, <a href="#org7181de4"><code>getc</code></a> o <a href="#org4d38061"><code>getchar</code></a>.
</p>
</div>
</div>

<div id="outline-container-org4073399" class="outline-4">
<h4 id="org4073399">7.8.4 Ejecucion de ordenes                                        <a id="org79346ae"></a></h4>
<div class="outline-text-4" id="text-org4073399">
<p>
La funcion <code>system(char *s)</code> ejecuta la orden contenida en la
cadena de caracteres <code>s</code>, y despues continua la ejecucion del
programa actual. Los contenidos de <code>s</code> dependen fuertemente del
sistema operativo local. Como un ejemplo trivial, en sistemas
UNIX, la proposicion
</p>

<div class="org-src-container">
<pre class="src src-c">system(<span style="color: #ffa07a;">"date"</span>);
</pre>
</div>

<p>
provoca que se ejecute el programa <code>date</code>, el cual imprime la
fecha y hora del dia en la salida estandar, <a href="#org2bcae28"><code>system</code></a> regresa del
comando ejecutado un estado entero dependiente del sistema. En el
sistema UNIX, el estado de retorno es el valor regresado por
<a href="#org394ccc4"><code>exit</code></a>.
</p>
</div>
</div>

<div id="outline-container-org97c37b1" class="outline-4">
<h4 id="org97c37b1">7.8.5 Administracion del almacenamiento                           <a id="org6ab8399"></a></h4>
<div class="outline-text-4" id="text-org97c37b1">
<p>
Las funciones <a href="#org292ad05"><code>malloc</code></a> y <a href="#org1970706"><code>calloc</code></a> obtienen bloques de memoria
dinamicamente,
</p>

<div class="org-src-container">
<pre class="src src-c"><span style="color: #98fb98;">void</span> *<span style="color: #87cefa;">malloc</span>(<span style="color: #98fb98;">size__t</span> <span style="color: #eedd82;">n</span>)
</pre>
</div>

<p>
regresa un apuntador a <code>n</code> bytes de almacenamiento no
inicializado, o <code>NULL</code> si la peticion no se satisface.
</p>

<div class="org-src-container">
<pre class="src src-c"><span style="color: #98fb98;">void</span> *<span style="color: #87cefa;">calloc</span>(<span style="color: #98fb98;">size__t</span> <span style="color: #eedd82;">n</span>, <span style="color: #98fb98;">size__t</span> <span style="color: #eedd82;">size</span>)
</pre>
</div>

<p>
regresa un apuntador a suficiente espacio para almacenar un
arreglo de <code>n</code> objetos del tamaño especificado, o <code>NULL</code> si la
peticion no se satisface. El espacio de almacenamiento es
inicializado en cero.
</p>

<p>
El apuntador regresado por <a href="#org292ad05"><code>malloc</code></a> o <a href="#org1970706"><code>calloc</code></a> tiene la alineacion
apropiada para el objeto en cuestion, pero se le debe hacer una
conversion forzada al tipo apropiado, como en
</p>

<div class="org-src-container">
<pre class="src src-c"><span style="color: #98fb98;">int</span> <span style="color: #eedd82;">ip</span>;

ip = (<span style="color: #98fb98;">int</span> *) <span style="color: #87cefa;">calloc</span>(n, <span style="color: #00ffff;">sizeof</span>(<span style="color: #98fb98;">int</span>));
</pre>
</div>

<p>
<code>free(p)</code> libera el espacio apuntado por <code>p</code>, donde <code>p</code> se obtuvo
originalmente por una llamada a <a href="#org292ad05"><code>malloc</code></a> o <a href="#org1970706"><code>calloc</code></a>. No existen
restricciones sobre el orden en el que se libera el espacio, pero
es un grave error el liberar algo no obtenido por una llamada a
<a href="#org1970706"><code>calloc</code></a> o <a href="#org292ad05"><code>malloc</code></a>.
</p>

<p>
Tambien es un error usar algo despues de haber sido liberado. Un
tipico pero erroneo fragmento de codigo es este ciclo que libera
elementos de una lista:
</p>

<div class="org-src-container">
<pre class="src src-c"><span style="color: #00ffff;">for</span> (p = head; p != <span style="color: #7fffd4;">NULL</span>; p = p-&gt;next) <span style="color: #ff4500;">/* </span><span style="color: #ff4500;">INCORRECTO </span><span style="color: #ff4500;">*/</span>
  <span style="color: #87cefa;">free</span>(p);
</pre>
</div>

<p>
La forma correcta es guardar lo necesario antes de liberar:
</p>

<div class="org-src-container">
<pre class="src src-c"><span style="color: #00ffff;">for</span> (p = head; p != <span style="color: #7fffd4;">NULL</span>; p = q) {
  q = p-&gt;next;
  free(p);
}
</pre>
</div>

<p>
La <a href="#org2b166a5">seccion 8.7</a> muestra la realizacion de un asignador de
almacenamiento como <a href="#org292ad05"><code>malloc</code></a>, en el cual los bloques asignados se
pueden liberar en cualquier orden.
</p>
</div>
</div>

<div id="outline-container-org162b11c" class="outline-4">
<h4 id="org162b11c">7.8.6 Funciones matematicas                                       <a id="org973d825"></a></h4>
<div class="outline-text-4" id="text-org162b11c">
<p>
Existen mas de veinte funciones matematicas declaradas en
<code>&lt;math.h&gt;</code>; aqui estan algunas de las empleadas con mas
frecuencia. Cada una toma uno o dos argumentos <code>double</code> y regresa
un <code>double</code>.
</p>

<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-left" />

<col  class="org-left" />
</colgroup>
<tbody>
<tr>
<td class="org-left"><code>sin(x)</code></td>
<td class="org-left">seno de <code>x</code>, <code>x</code> en radianes</td>
</tr>

<tr>
<td class="org-left"><code>cos(x)</code></td>
<td class="org-left">coseno de <code>x</code>, <code>x</code> en radianes</td>
</tr>

<tr>
<td class="org-left"><code>atan2(y,x)</code></td>
<td class="org-left">arco tangente de <code>y/x</code>, en radianes</td>
</tr>

<tr>
<td class="org-left"><code>exp(x)</code></td>
<td class="org-left">funcion exponencial e<sup>x</sup></td>
</tr>

<tr>
<td class="org-left"><code>log(x)</code></td>
<td class="org-left">logaritmo natural (base e) de <code>x</code> (<code>x&gt;0</code>)</td>
</tr>

<tr>
<td class="org-left"><code>log10(x)</code></td>
<td class="org-left">logaritmo comun (base 10 ) de <code>x</code> (<code>x&gt;0</code>)</td>
</tr>

<tr>
<td class="org-left"><code>pow(x,y)</code></td>
<td class="org-left">x<sup>y</sup></td>
</tr>

<tr>
<td class="org-left"><code>sqrt(x,)</code></td>
<td class="org-left">raiz cuadrada de <code>x</code> (<code>x&gt;O</code>)</td>
</tr>

<tr>
<td class="org-left"><code>fabs(x)</code></td>
<td class="org-left">valor absoluto de <code>x</code></td>
</tr>
</tbody>
</table>
</div>
</div>

<div id="outline-container-orgd773f8a" class="outline-4">
<h4 id="orgd773f8a">7.8.7 Generacion de numeros aleatorios                            <a id="orgf14cdbc"></a></h4>
<div class="outline-text-4" id="text-orgd773f8a">
<p>
La funcion <code>rand()</code> calcula una secuencia de enteros
pseudoaleatorios en el rango de cero a <code>RAND_MAX</code>, que esta
definido en <code>&lt;stdlib.h&gt;</code>. Una forma de producir numeros aleatorios
de punto flotante mayores o iguales a cero pero menores que uno es
</p>

<div class="org-src-container">
<pre class="src src-c"><span style="color: #b0c4de;">#define</span> <span style="color: #87cefa;">frand</span>() ((<span style="color: #98fb98;">double</span>) rand() / (RAND_MAX + 1.0))
</pre>
</div>

<p>
(Si su biblioteca ya proporciona una funcion para numeros
aleatorios de punto flotante, es probable que tenga mejores
propiedades estadisticas que esta.)
</p>

<p>
La funcion <code>srand(unsigned)</code> fija la semilla para <a href="#orge269335"><code>rand</code></a>. La
implantacion portatil de <a href="#orge269335"><code>rand</code></a> y de <a href="#org6315f08"><code>srand</code></a> sugerida por el
estandar aparece en la <a href="#orgd14f820">seccion 2.7</a>.
</p>

<p>
<b>Ejercicio 7-9</b>. Se pueden escribir funciones como <code>isupper</code> para
ahorrar espacio o tiempo. Explore ambas posibilidades.
</p>
</div>
</div>
</div>
</div>

<div id="outline-container-orga6e66c5" class="outline-2">
<h2 id="orga6e66c5">capitulo 8: La interfaz con el sistema UNIX                         <a id="orgb0747de"></a></h2>
<div class="outline-text-2" id="text-orga6e66c5">
<p>
El sistema operativo UNIX proporciona sus servicios a traves de un
conjunto de <i>llamadas al sistema</i>, que consisten en funciones que
estan dentro del sistema operativo y que pueden ser invocadas por
programas del usuario. Este capitulo describe como emplear algunas
de las mas importantes llamadas al sistema desde programas en C. Si
el lector usa UNIX, esto debe serle directamente util, debido a que
algunas veces es necesario emplear llamadas al sistema para tener
maxima eficiencia, o para tener acceso a alguna facilidad que no
este en la biblioteca. Incluso, si se emplea C en un sistema
operativo diferente el lector deberia ser capaz de adentrarse en la
programacion estudiando estos ejemplos; aunque los detalles varian,
se encontrara un codigo semejante en cualquier sistema. Puesto que
la biblioteca de C ANSI esta en muchos casos modelada con base en
las facilidades de UNIX, este codigo puede ayudar tambien a su
entendimiento.
</p>

<p>
El capitulo esta dividido en tres partes fundamentales:
entrada/salida, sistema de archivos y asignacion de
almacenamiento. Las primeras dos partes suponen una modesta
familiaridad con las caracteristicas externas de los sistemas UNIX.
</p>

<p>
El <a href="#orgf1abb1c">capitulo 7</a> tuvo que ver con una interfaz de entrada/salida
uniforme entre sistemas operativos. En cualquier sistema las rutinas
de la biblioteca estandar se tienen que escribir en terminos de las
facilidades proporcionadas por el sistema anfitrion. En las
secciones de este capitulo describiremos las llamadas al sistema
UNIX para entrada y salida, y mostraremos como puede escribirse
parte de la biblioteca estandar con ellas.
</p>
</div>

<div id="outline-container-org798c0fa" class="outline-3">
<h3 id="org798c0fa">8.1  Descriptores de archivos                                      <a id="org08e3c5c"></a></h3>
<div class="outline-text-3" id="text-org798c0fa">
<p>
En el sistema operativo UNIX, todas las entradas y salidas se
realizan por la lectura o escritura de archivos, debido a que los
dispositivos perifericos, aun el teclado y la pantalla, son
archivos que estan en el sistema. Esto significa que una sencilla
interfaz homogenea maneja todas las comunicaciones entre un
programa y los dispositivos perifericos.
</p>

<p>
En el caso mas general, antes de leer o escribir un archivo,
primero se debe informar al sistema acerca de la intencion de
hacerlo, mediante el proceso llamado <i>abrir</i> un archivo. Si se va a
escribir en un archivo tambien puede ser necesario crearlo o
descartar el contenido previo. El sistema verifica los derechos
para hacer tal cosa (¿El archivo existe? ¿tiene permiso de hacer
acceso a el?) y, si todo esta correcto, regresa al programa un
pequeño entero no negativo llamado <i>descriptor de archivo</i>. Siempre
que se van a efectuar acciones de entrada y salida sobre ese
archivo, se usa el descriptor de archivo para identificarlo en
lugar del nombre.  (Un descriptor de archivo es analogo al
apuntador de archivo usado por la biblioteca estandar o al
manipulador de archivo de MS-DOS.) Toda la informacion acerca de un
archivo abierto es mantenida por el sistema; el programa del
usuario se refiere al archivo solo por el descriptor.
</p>

<p>
Puesto que es tan comun que la entrada y la salida involucren al
teclado y a la pantalla, existen arreglos especiales para hacer
esto convenientemente. Cuando el interprete de comandos (el
"shell") ejecuta un programa se abren tres archivos, con
descriptores <code>0</code>, <code>1</code> y <code>2</code>, llamados entrada estandar, salida
estandar y error estandar. Si un programa lee de <code>0</code> y escribe a
<code>1</code> y a <code>2</code>, puede hacer entrada y salida sin preocuparse de abrir
archivos.
</p>

<p>
El usuario de un programa puede redirigir la E/S hacia y desde
archivos con <code>&lt;</code> y <code>&gt;</code>:
</p>

<div class="org-src-container">
<pre class="src src-sh">prog &lt;infile &gt;outfile
</pre>
</div>

<p>
En este caso, la <code>shell</code> cambia las asignaciones predefinidas para
los descriptores <code>0</code> y <code>1</code> a los archivos nombrados. Normalmente el
descriptor de archivo <code>2</code> permanece asignado a la pantalla, para
que los mensajes de error puedan ir hacia alla.  Observaciones
semejantes se aplican para la entrada y salida asociada con una
interconexion. En todos los casos, la asignacion de archivos la
cambia la <code>shell</code>, no el programa. El programa no sabe de donde
proviene su entrada ni hacia donde va su salida, mientras use al
archivo <code>0</code> para entrada y <code>1</code> y <code>2</code> para salida.
</p>
</div>
</div>

<div id="outline-container-org1f773e9" class="outline-3">
<h3 id="org1f773e9">8.2  E/S de bajo nivel - <code>read</code> y <code>write</code>                          <a id="orga2a578c"></a></h3>
<div class="outline-text-3" id="text-org1f773e9">
<p>
La entrada y salida usa las llamadas al sistema <code>read</code> y <code>write</code>, a
las que se tiene acceso desde programas escritos en C a traves de
dos funciones llamadas <code>read</code> y <code>write</code>. Para ambas, el primer
argumento es un descriptor de archivo. El segundo argumento es un
arreglo de caracteres perteneciente al programa hacia o de donde
los datos van a ir o venir. El tercer argumento es el numero de
bytes que seran transferidos.
</p>

<div class="org-src-container">
<pre class="src src-c"><span style="color: #98fb98;">int</span> <span style="color: #eedd82;">n_read</span> = read(<span style="color: #98fb98;">int</span> <span style="color: #eedd82;">fd</span>, <span style="color: #98fb98;">char</span> *<span style="color: #eedd82;">buf</span>, <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">n</span>);
<span style="color: #98fb98;">int</span> <span style="color: #eedd82;">n_written</span> = write(<span style="color: #98fb98;">int</span> <span style="color: #eedd82;">fd</span>, <span style="color: #98fb98;">char</span> *<span style="color: #eedd82;">buf</span>, <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">n</span>);
</pre>
</div>

<p>
Cada llamada regresa una cuenta del numero de bytes
transferidos. En la lectura, el numero de bytes regresados puede
ser menor que el numero solicitado. Un valor de regreso de cero
bytes implica fin de archivo y <code>-1</code> indica un error de algun
tipo. Para escritura, el valor de retorno es el numero de bytes
escritos: si este no es igual al numero solicitado, ha ocurrido un
error.
</p>

<p>
En una llamada pueden leerse cualquier numero de bytes. Los valores
mas comunes son <code>1</code>, que significa un caracter a la vez (sin
buffer), y un numero como <code>1024</code> o <code>4096</code>, que corresponde al
tamaño de un bloque fisico de un dispositivo periferico. Los
valores mayores seran mas eficientes debido a que seran realizadas
menos llamadas al sistema.
</p>

<p>
Para juntar estos temas, podemos escribir un sencillo programa que
copie su entrada a su salida, el equivalente del programa copiador
de archivos escrito para el <a href="#orgc16243d">capitulo 1</a>. Este programa copiara
cualquier cosa a cualquier cosa, ya que la entrada y la salida
pueden ser redirigidas hacia cualquier archivo o dispositivo.
</p>

<div class="org-src-container">
<pre class="src src-c"><span style="color: #b0c4de;">#include</span> <span style="color: #ffa07a;">"syscalls.h"</span>

<span style="color: #87cefa;">main</span>() <span style="color: #ff4500;">/* </span><span style="color: #ff4500;">copia la entrada a la salida </span><span style="color: #ff4500;">*/</span>
{
  <span style="color: #98fb98;">char</span> <span style="color: #eedd82;">buf</span>[BUFSIZ];
  <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">n</span>;

  <span style="color: #00ffff;">while</span> ((n = read(0, buf, BUFSIZ)) &gt; 0)
    write(1, buf, n);
  <span style="color: #00ffff;">return</span> 0;
}
</pre>
</div>

<p>
Hemos reunido prototipos de funciones para las llamadas al sistema
en un archivo llamado <code>syscalls.h</code>, de modo que podamos incluirlo
en los programas de este capitulo. Sin embargo, este nombre no es
estandar.
</p>

<p>
El parametro <code>BUFSIZ</code> tambien esta definido dentro de <code>syscalls.h</code>;
su valor es un tamaño adecuado para el sistema local. Si el tamaño
del archivo no es un multiplo de <code>BUFSIZ</code>, algun <code>read</code> regresara
un numero menor de bytes a ser escritos por <code>write</code>; la siguiente
llamada a <code>read</code> despues de eso regresara cero.
</p>

<p>
Es instructivo ver como se pueden usar <code>read</code> y <code>write</code> para
construir rutinas de alto nivel como <a href="#org4d38061"><code>getchar</code></a>, <a href="#orgc7f0a8a"><code>putchar</code></a>, etc. Por
ejemplo, aqui esta una version de <a href="#org4d38061"><code>getchar</code></a> que realiza entrada sin
buffer, leyendo de la entrada estandar un caracter a la vez.
</p>

<div class="org-src-container">
<pre class="src src-c"><span style="color: #b0c4de;">#include</span> <span style="color: #ffa07a;">"syscalls.h"</span>

<span style="color: #ff4500;">/* </span><span style="color: #ff4500;">getchar: entrada de un caracter simple sin buffer </span><span style="color: #ff4500;">*/</span>
<span style="color: #98fb98;">int</span> <span style="color: #87cefa;">getchar</span>(<span style="color: #98fb98;">void</span>)
{
  <span style="color: #98fb98;">char</span> <span style="color: #eedd82;">c</span>;

  <span style="color: #00ffff;">return</span> (read(0, &amp;c, 1) == 1) ? (<span style="color: #98fb98;">unsigned</span> <span style="color: #98fb98;">char</span>) c : EOF;
}
</pre>
</div>

<p>
<code>c</code> debe ser un <code>char</code>, debido a que <code>read</code> necesita un apuntador a
caracter. Forzar <code>c</code> a ser <code>unsigned char</code> en la proposicion de
regreso elimina cualquier problema de extension de signo.
</p>

<p>
La segunda version de <a href="#org4d38061"><code>getchar</code></a> hace la entrada en grandes
fragmentos y saca los caracteres uno a la vez.
</p>

<div class="org-src-container">
<pre class="src src-c"><span style="color: #b0c4de;">#include</span> <span style="color: #ffa07a;">"syscalls.h"</span>

<span style="color: #ff4500;">/* </span><span style="color: #ff4500;">getchar: version con buffer simple </span><span style="color: #ff4500;">*/</span>
<span style="color: #98fb98;">int</span> <span style="color: #87cefa;">getchar</span>(<span style="color: #98fb98;">void</span>)
{
  <span style="color: #00ffff;">static</span> <span style="color: #98fb98;">char</span> <span style="color: #eedd82;">buf</span>[BUFSIZ];
  <span style="color: #00ffff;">static</span> <span style="color: #98fb98;">char</span> *<span style="color: #eedd82;">bufp</span> = buf;
  <span style="color: #00ffff;">static</span> <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">n</span> = 0;

  <span style="color: #00ffff;">if</span> (n == 0) {  <span style="color: #ff4500;">/* </span><span style="color: #ff4500;">el buffer esta vacio </span><span style="color: #ff4500;">*/</span>
    n = read(0, buf, <span style="color: #00ffff;">sizeof</span> buf);
    bufp = buf;
  }
  <span style="color: #00ffff;">return</span> (--n &gt;= 0) ? (<span style="color: #98fb98;">unsigned</span> <span style="color: #98fb98;">char</span>) *bufp++ : EOF;
}
</pre>
</div>

<p>
Si esta version de <a href="#org4d38061"><code>getchar</code></a> fuese a ser compilada con <code>&lt;stdio.h&gt;</code>
incluida, seria necesario eliminar la definicion del nombre
<a href="#org4d38061"><code>getchar</code></a> con <code>#undef</code> en caso de que este implantada como una
macro.
</p>
</div>
</div>

<div id="outline-container-org5ad2ba2" class="outline-3">
<h3 id="org5ad2ba2">8.3  <code>open</code>, <code>creat</code>, <code>close</code>, <code>unlink</code>                            <a id="org3d7a558"></a></h3>
<div class="outline-text-3" id="text-org5ad2ba2">
<p>
Ademas de la entrada, la salida y el error estandar, se pueden
abrir explicitamente archivos para leerlos o escribirlos. Existen
dos llamadas al sistema para esto, <code>open</code> y <code>creat</code> [sic a pesar de
que en ingles la palabra correcta es "create", el nombre de la
funcion es solo "creat"].
</p>

<p>
<code>open</code> es como el <a href="#orgd6dbcbe"><code>fopen</code></a> expuesto en el <a href="#orgf1abb1c">capitulo 7</a>, excepto que en
lugar de regresar un apuntador de archivo, regresa un descriptor de
archivo, que es tan solo un <code>int</code>. <code>open</code> regresa <code>-1</code> si ocurre
algun error.
</p>

<div class="org-src-container">
<pre class="src src-c"><span style="color: #b0c4de;">#include</span> <span style="color: #ffa07a;">&lt;fcntl.h&gt;</span>

<span style="color: #98fb98;">int</span> <span style="color: #eedd82;">fd</span>;
<span style="color: #98fb98;">int</span> <span style="color: #87cefa;">open</span>(<span style="color: #98fb98;">char</span> *<span style="color: #eedd82;">name</span>, <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">flags</span>, <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">perms</span>);
fd = open(name, flags, perms);
</pre>
</div>

<p>
Como con <a href="#orgd6dbcbe"><code>fopen</code></a>, el argumento <code>name</code> es una cadena de caracteres
que contiene el nombre del archivo. El segundo argumento, <code>flags</code>,
es Un <code>int</code> que especifica como sera abierto el archivo; los
principales valores son:
</p>

<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-left" />

<col  class="org-left" />
</colgroup>
<tbody>
<tr>
<td class="org-left"><code>O_RDONLY</code></td>
<td class="org-left">abrir solo para lectura</td>
</tr>

<tr>
<td class="org-left"><code>O_WRONLY</code></td>
<td class="org-left">abrir solo para escritura</td>
</tr>

<tr>
<td class="org-left"><code>O_RDWR</code></td>
<td class="org-left">abrir para lectura y escritura</td>
</tr>
</tbody>
</table>

<p>
Estas constantes estan definidas en <code>&lt;fcntl.h&gt;</code> en sistemas UNIX
System V, y en <code>&lt;sys/file.h&gt;</code> en versiones Berkeley (BSD).
</p>

<p>
Para abrir un archivo ya existente para lectura,
</p>

<div class="org-src-container">
<pre class="src src-c">fd = open(name, O_RDONLY, 0);
</pre>
</div>

<p>
El argumento <code>perms</code> es siempre cero para los usos de <code>open</code> que
discutiremos.
</p>

<p>
Es un error tratar de abrir un archivo que no existe. Para crear
nuevos archivos o reescribir anteriores, se proporciona la llamada
al sistema <code>creat</code>.
</p>

<div class="org-src-container">
<pre class="src src-c"><span style="color: #98fb98;">int</span> <span style="color: #87cefa;">creat</span>(<span style="color: #98fb98;">char</span> *<span style="color: #eedd82;">name</span>, <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">perms</span>);

fd = creat(name, perms);
</pre>
</div>

<p>
regresa un descriptor de archivo si fue capaz de crear el archivo,
y <code>-1</code> si no lo fue. Si el archivo ya existe, <code>creat</code> lo truncara a
longitud cero y por tanto descartara su contenido previo; esto no
es un error de <code>creat</code> para un archivo que ya existe.
</p>

<p>
Si el archivo no existe, <code>creat</code> lo crea con los permisos
especificados por el argumento <code>perms</code>. En el sistema de archivos
de UNIX hay nueve bits para informacion de permisos asociados con
un archivo, que controlan el acceso a la lectura, escritura y
ejecucion para el propietario del archivo, para el grupo del
propietario y para todos los demas. Asi, un numero octal de tres
digitos es conveniente para especificar los permisos. Por ejemplo,
<code>0755</code> especifica permisos para leer, escribir y ejecutar para el
propietario, y leer y ejecutar para el grupo y para cualquier otro.
</p>

<p>
Para ilustrarlo, aqui esta una version simplificada del programa
<code>cp</code> de UNIX, que copia un archivo a otro. Nuestra version copia
solo un archivo, no permite que el segundo argumento sea un
directorio e inventa los permisos en lugar de copiarlos.
</p>

<div class="org-src-container">
<pre class="src src-c"><span style="color: #b0c4de;">#include</span> <span style="color: #ffa07a;">&lt;stdio.h&gt;</span>
<span style="color: #b0c4de;">#include</span> <span style="color: #ffa07a;">&lt;fcntl.h&gt;</span>
<span style="color: #b0c4de;">#include</span> <span style="color: #ffa07a;">"syscalls.h"</span>
<span style="color: #b0c4de;">#define</span> <span style="color: #eedd82;">PERMS</span> 0666  <span style="color: #ff4500;">/* </span><span style="color: #ff4500;">lectura y escritura para propietario, grupo y otros </span><span style="color: #ff4500;">*/</span>

<span style="color: #98fb98;">void</span> <span style="color: #87cefa;">error</span>(<span style="color: #98fb98;">char</span> *, ...);

<span style="color: #ff4500;">/* </span><span style="color: #ff4500;">cp: copia f1 a f2 </span><span style="color: #ff4500;">*/</span>
<span style="color: #87cefa;">main</span>(<span style="color: #98fb98;">int</span> <span style="color: #eedd82;">argc</span>, <span style="color: #98fb98;">char</span> *<span style="color: #eedd82;">argv</span>[])
{
  <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">f1</span>, <span style="color: #eedd82;">f2</span>, <span style="color: #eedd82;">n</span>;
  <span style="color: #98fb98;">char</span> <span style="color: #eedd82;">buf</span>[BUFSIZ];

  <span style="color: #00ffff;">if</span> (argc != 3)
    error(<span style="color: #ffa07a;">"Uso: cp de hacia"</span>);
  <span style="color: #00ffff;">if</span> ((f1 = open(argv[1], O_RDONLY, 0)) == -1)
    error(<span style="color: #ffa07a;">"cp: no se puede abrir %s"</span>, argv[1]);
  <span style="color: #00ffff;">if</span> ((f2 = creat(argv[2], PERMS)) == -1)
    error(<span style="color: #ffa07a;">"cp: no se puede crear %s, modo %03o"</span>, argv[2], PERMS);
  <span style="color: #00ffff;">while</span> ((n = read(f1, buf, BUFSIZ)) &gt; 0)
    <span style="color: #00ffff;">if</span> (write(f2, buf, n) != n)
      error(<span style="color: #ffa07a;">"cp: error de escritura en el archivo %s"</span>, argv[2]);
  <span style="color: #00ffff;">return</span> 0;
}
</pre>
</div>

<p>
Este programa crea el archivo de salida con permisos fijos
<code>0666</code>. Con la llamada al sistema <code>stat</code>, descrita en la seccion
8.6, podemos determinar el modo de un archivo existente y asi dar
el mismo modo a la copia.
</p>

<p>
Notese que la funcion <code>error</code> es invocada con una lista variable de
argumentos muy semejante a la de <a href="#org0458a76"><code>printf</code></a>. La implementacion de
<code>error</code> ilustra como utilizar otros miembros de la familia
<a href="#org0458a76"><code>printf</code></a>. La funcion de biblioteca estandar <a href="#org4a030f4"><code>vprintf</code></a> es como
<a href="#org0458a76"><code>printf</code></a>, excepto que la lista variable de argumentos es
reemplazada por un solo argumento que ha sido inicializado llamando
a la macro <code>va_start</code>. En forma semejante, <a href="#org6018dca"><code>vfprintf</code></a> y <a href="#orgd1c58d2"><code>vsprintf</code></a>
coinciden con <a href="#org74b2389"><code>fprintf</code></a> y <a href="#org44a4902"><code>sprintf</code></a>.
</p>

<div class="org-src-container">
<pre class="src src-c"><span style="color: #b0c4de;">#include</span> <span style="color: #ffa07a;">&lt;stdio.h&gt;</span>
<span style="color: #b0c4de;">#include</span> <span style="color: #ffa07a;">&lt;stdarg.h&gt;</span>

<span style="color: #ff4500;">/* </span><span style="color: #ff4500;">error: imprime un mensaje de error y muere </span><span style="color: #ff4500;">*/</span>
<span style="color: #98fb98;">void</span> <span style="color: #87cefa;">error</span>(<span style="color: #98fb98;">char</span> *<span style="color: #eedd82;">fmt</span>, ...)
{
  <span style="color: #98fb98;">va_list</span> <span style="color: #eedd82;">args</span>;

  va_start(args, fmt);
  fprintf(stderr, <span style="color: #ffa07a;">"error: "</span>);
  vprintf(stderr, fmt, args);
  fprintf(stderr, <span style="color: #ffa07a;">"\n"</span>);
  va_end(args);
  exit(1);
}
</pre>
</div>

<p>
Existe un limite (regularmente <code>20</code>) en el numero de archivos que
un programa puede tener abiertos simultaneamente. De acuerdo con
esto, un programa que intente procesar muchos archivos debe ser
preparado para reutilizar descriptores de archivo. La funcion
<code>close(int fd)</code> suspende la conexion entre un descriptor de archivo
y un archivo abierto, y libera al descriptor de archivo para ser
utilizado con algun otro archivo; corresponde a <a href="#orge0fc4f1"><code>fclose</code></a> de la
biblioteca estandar excepto en que no existe un buffer que
vaciar. La terminacion de un programa via <a href="#org394ccc4"><code>exit</code></a> o <code>return</code> desde
el programa principal cierra todos los archivos abiertos.
</p>

<p>
La funcion <code>unlink(char *name)</code> remueve el archivo <code>name</code> del
sistema de archivos. Corresponde a la funcion de la biblioteca
estandar <a href="#org7d045ee"><code>remove</code></a>.
</p>

<p>
<b>Ejercicio 8-1</b>. Reescriba el programa <code>cat</code> del <a href="#orgf1abb1c">capitulo 7</a> usando
<code>read</code>, <code>write</code>, <code>open</code> y <code>close</code>, en lugar de sus equivalentes de
la biblioteca estandar. Haga experimentos para determinar la
velocidad relativa de las dos versiones.
</p>
</div>
</div>

<div id="outline-container-orge0ef88a" class="outline-3">
<h3 id="orge0ef88a">8.4  Acceso aleatorio - <code>lseek</code>                                    <a id="orgbf7043e"></a></h3>
<div class="outline-text-3" id="text-orge0ef88a">
<p>
La entrada y la salida son normalmente secuenciales: cada <code>read</code> o
<code>write</code> ocurre en una posicion del archivo justo despues de la
anterior. Sin embargo, cuando es necesario, un archivo se puede
leer o escribir en cualquier orden arbitrario. La llamada al
sistema <code>lseek</code> proporciona una forma de moverse en un archivo sin
leer o escribir ningun dato:
</p>

<div class="org-src-container">
<pre class="src src-c"><span style="color: #98fb98;">long</span> <span style="color: #87cefa;">lseek</span>(<span style="color: #98fb98;">int</span> <span style="color: #eedd82;">fd</span>, <span style="color: #98fb98;">long</span> <span style="color: #eedd82;">offset</span>, <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">origin</span>);
</pre>
</div>

<p>
fija en <code>offset</code> la posicion actual en el archivo cuyo descriptor
es <code>fd</code>, que se toma relativo a la localizacion especificada por
<code>origin</code>. Una lectura o escritura posterior iniciara en esa
posicion, <code>origin</code> puede ser <code>0</code>, <code>1</code> o <code>2</code> para especificar que el
desplazamiento <code>offset</code> sera medido desde el principio, desde la
posicion actual, o desde el fin del archivo, respectivamente. Por
ejemplo, para agregar a un archivo (la redireccion <code>&gt;&gt;</code> en el
<code>shell</code> de UNIX, o "a" de <a href="#orgd6dbcbe"><code>fopen</code></a>), hay que ir al final antes de
escribir:
</p>

<div class="org-src-container">
<pre class="src src-c"><span style="color: #87cefa;">lseek</span>(fd, 0L, 2);
</pre>
</div>

<p>
Para regresar al principio ("rebobinar"),
</p>

<div class="org-src-container">
<pre class="src src-c"><span style="color: #87cefa;">lseek</span>(fd, 0L, 0);
</pre>
</div>

<p>
Notese el argumento <code>0L</code>; tambien podria ser escrito como <code>(long)
   0</code> o solo como <code>0</code> si <code>lseek</code> esta declarado adecuadamente.
</p>

<p>
Con <code>lseek</code>, es posible tratar a los archivos mas o menos como
arreglos extensos, al precio de un acceso mas lento. Por ejemplo,
la siguiente funcion lee cualquier numero de bytes en cualquier
lugar arbitrario de un archivo. Regresa el numero leido, o <code>-1</code> en
caso de error.
</p>

<div class="org-src-container">
<pre class="src src-c"><span style="color: #b0c4de;">#include</span> <span style="color: #ffa07a;">"syscalls.h"</span>

<span style="color: #ff4500;">/* </span><span style="color: #ff4500;">get: lee n bytes de la posicion pos </span><span style="color: #ff4500;">*/</span>
<span style="color: #98fb98;">int</span> <span style="color: #87cefa;">get</span>(<span style="color: #98fb98;">int</span> <span style="color: #eedd82;">fd</span>, <span style="color: #98fb98;">long</span> <span style="color: #eedd82;">pos</span>, <span style="color: #98fb98;">char</span> *<span style="color: #eedd82;">buf</span>, <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">n</span>)
{
  <span style="color: #00ffff;">if</span> (lseek(fd, pos, 0) &gt;= 0) <span style="color: #ff4500;">/* </span><span style="color: #ff4500;">se situa en pos </span><span style="color: #ff4500;">*/</span>
    <span style="color: #00ffff;">return</span> read(fd, buf, n);
  <span style="color: #00ffff;">else</span>
    <span style="color: #00ffff;">return</span> -1;
}
</pre>
</div>

<p>
El valor de regreso de <code>lseek</code> es un <code>long</code> que da la nueva
posicion en el archivo, o <code>-1</code> si ocurre un error. La funcion de
biblioteca estandar <a href="#org20f3c96"><code>fseek</code></a> es semejante a <code>lseek</code>, excepto en que
el primer argumento es un <code>FILE *</code> y el valor de regreso es
diferente de cero si ocurrio un error.
</p>
</div>
</div>

<div id="outline-container-org5aa8f92" class="outline-3">
<h3 id="org5aa8f92">8.5  Ejemplo - una realizacion de <a href="#orgd6dbcbe"><code>fopen</code></a> y <a href="#org7181de4"><code>getc</code></a>                 <a id="orge4244db"></a></h3>
<div class="outline-text-3" id="text-org5aa8f92">
<p>
Ilustremos ahora como algunas de estas piezas quedan juntas,
mostrando una implementacion de las rutinas <a href="#orgd6dbcbe"><code>fopen</code></a> y <a href="#org7181de4"><code>getc</code></a> de la
biblioteca estandar.
</p>

<p>
Recuerdese que los archivos en la biblioteca estandar son descritos
por apuntadores de archivos en vez de con descriptores de
archivo. Un apuntador de archivo es un apuntador a una estructura
que contiene informacion varia acerca del archivo: un apuntador a
un buffer, para que el archivo pueda ser leido en grandes
fragmentos; una cuenta del numero de caracteres que quedan en el
buffer; un apuntador a la posicion del siguiente caracter en el
buffer; el descriptor de archivo, y banderas que describen el modo
de lectura/escritura, estado de error, etcetera.
</p>

<p>
La estructura de datos que describe un archivo esta contenida en
<code>&lt;stdio.h&gt;</code>, que se debe incluir (con <code>#include</code>) en cualquier
archivo fuente que utilice rutinas de la biblioteca de
entrada/salida estandar. Tambien esta incluido en las funciones de
la biblioteca. En el siguiente fragmento de un <code>&lt;stdio.h&gt;</code> tipico,
los nombres que se intenta emplear solo en las funciones de la
biblioteca estandar inician con un subguion, por lo que son menos
susceptibles de tener conflicto con nombres en los programas del
usuario. Esta convencion la emplean todas las rutinas de la
biblioteca estandar.
</p>

<div class="org-src-container">
<pre class="src src-c"><span style="color: #b0c4de;">#define</span> <span style="color: #eedd82;">NULL</span>     0
<span style="color: #b0c4de;">#define</span> <span style="color: #eedd82;">EOF</span>      (-1)
<span style="color: #b0c4de;">#define</span> <span style="color: #eedd82;">BUFSIZ</span>   1024
<span style="color: #b0c4de;">#define</span> <span style="color: #eedd82;">OPEN_MAX</span> 20   <span style="color: #ff4500;">/* </span><span style="color: #ff4500;">maximo numero de archivos abiertos a la vez </span><span style="color: #ff4500;">*/</span>

<span style="color: #00ffff;">typedef</span> <span style="color: #00ffff;">struct</span> <span style="color: #98fb98;">_iobuf</span> {
  <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">cnt</span>;             <span style="color: #ff4500;">/* </span><span style="color: #ff4500;">caracteres que quedan           </span><span style="color: #ff4500;">*/</span>
  <span style="color: #98fb98;">char</span> *<span style="color: #eedd82;">ptr</span>;           <span style="color: #ff4500;">/* </span><span style="color: #ff4500;">posicion del siguiente caracter </span><span style="color: #ff4500;">*/</span>
  <span style="color: #98fb98;">char</span> *<span style="color: #eedd82;">base</span>;          <span style="color: #ff4500;">/* </span><span style="color: #ff4500;">localizacion del buffer         </span><span style="color: #ff4500;">*/</span>
  <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">flag</span>;            <span style="color: #ff4500;">/* </span><span style="color: #ff4500;">modo de acceso al archivo       </span><span style="color: #ff4500;">*/</span>
  <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">fd</span>;              <span style="color: #ff4500;">/* </span><span style="color: #ff4500;">descriptor de archivo           </span><span style="color: #ff4500;">*/</span>
} <span style="color: #98fb98;">FILE</span>;
<span style="color: #00ffff;">extern</span> <span style="color: #98fb98;">FILE</span> <span style="color: #eedd82;">_iob</span>[OPEN_MAX];

<span style="color: #b0c4de;">#define</span> <span style="color: #eedd82;">stdin</span>   (&amp;_iob[0])
<span style="color: #b0c4de;">#define</span> <span style="color: #eedd82;">stdout</span>  (&amp;_iob[1])
<span style="color: #b0c4de;">#define</span> <span style="color: #eedd82;">stderr</span>  (&amp;_iob[2])

<span style="color: #00ffff;">enum</span> <span style="color: #98fb98;">_flags</span> {
  <span style="color: #eedd82;">_READ</span>     = 01,       <span style="color: #ff4500;">/* </span><span style="color: #ff4500;">archivo abierto para lectura                 </span><span style="color: #ff4500;">*/</span>
  <span style="color: #eedd82;">_WRITE</span>    = 02,       <span style="color: #ff4500;">/* </span><span style="color: #ff4500;">archivo abierto para escritura               </span><span style="color: #ff4500;">*/</span>
  <span style="color: #eedd82;">_UNBUF</span>    = 04,       <span style="color: #ff4500;">/* </span><span style="color: #ff4500;">archivo sin buffer                           </span><span style="color: #ff4500;">*/</span>
  <span style="color: #eedd82;">_EOF</span>      = 010,      <span style="color: #ff4500;">/* </span><span style="color: #ff4500;">ocurrio fin de archivo (EOF) en este archivo </span><span style="color: #ff4500;">*/</span>
  <span style="color: #eedd82;">_ERR</span>      = 020       <span style="color: #ff4500;">/* </span><span style="color: #ff4500;">ocurrio un error en este archivo             </span><span style="color: #ff4500;">*/</span>
};

<span style="color: #98fb98;">int</span> <span style="color: #87cefa;">_fillbuf</span>(<span style="color: #98fb98;">FILE</span> *);
<span style="color: #98fb98;">int</span> <span style="color: #87cefa;">_flushbuf</span>(<span style="color: #98fb98;">int</span>, <span style="color: #98fb98;">FILE</span> *);

<span style="color: #b0c4de;">#define</span> <span style="color: #87cefa;">feof</span>(<span style="color: #eedd82;">p</span>)      ((p)-&gt;flag &amp; _EOF) != 0)
<span style="color: #b0c4de;">#define</span> <span style="color: #87cefa;">ferror</span>(<span style="color: #eedd82;">p</span>)    ((p)-&gt;flag &amp; _ERR) != 0)
<span style="color: #b0c4de;">#define</span> <span style="color: #87cefa;">fileno</span>(<span style="color: #eedd82;">p</span>)    ((p)-&gt;fd)

<span style="color: #b0c4de;">#define</span> <span style="color: #87cefa;">getc</span>(<span style="color: #eedd82;">p</span>)   (--(p)-&gt;cnt &gt;= 0                              \
                   ? (<span style="color: #98fb98;">unsigned</span> <span style="color: #98fb98;">char</span>) *(p)-&gt;ptr++ : _fillbuf(p))
<span style="color: #b0c4de;">#define</span> <span style="color: #87cefa;">putc</span>(<span style="color: #eedd82;">x</span>,<span style="color: #eedd82;">p</span>) (--(p)-&gt;cnt &gt;= 0                              \
                   ? *(p)-&gt;ptr++ = (x) : _flushbuf((x),p))

<span style="color: #b0c4de;">#define</span> <span style="color: #87cefa;">getchar</span>()  getc(stdin)
<span style="color: #b0c4de;">#define</span> <span style="color: #87cefa;">putcher</span>(<span style="color: #eedd82;">x</span>) putc((x), stdout)
</pre>
</div>

<p>
La macro <a href="#org7181de4"><code>getc</code></a> normalmente decrementa la cuenta, avanza el
apuntador y regresa el caracter. (Recuerde que un <code>#define</code> largo
se continua con una diagonal invertida.) Si la cuenta se hace
negativa, sin embargo, <a href="#org7181de4"><code>getc</code></a> llama a la funcion <code>_fillbuf</code> para
llevar el buffer, reinicializa el contenido de la estructura, y
regresa un caracter. Los caracteres son devueltos <code>unsigned</code>, lo
que asegura que todos los caracteres seran positivos.
</p>

<p>
Aunque no discutiremos ningun detalle, hemos incluido la definicion
de <a href="#org38237ac"><code>putc</code></a> para mostrar que opera en forma muy semejante a <a href="#org7181de4"><code>getc</code></a>,
llamando a una funcion <code>_flushbuf</code> cuando su buffer esta
lleno. Tambien hemos incluido macros para tener acceso al estado de
error, fin de archivo, y al descriptor del mismo.
</p>

<p>
Ahora puede escribirse la funcion <a href="#orgd6dbcbe"><code>fopen</code></a>. La mayor parte de
<a href="#orgd6dbcbe"><code>fopen</code></a> tiene que ver con tener el archivo abierto y colocado en el
lugar correcto, y con fijar los bits de la bandera <code>flag</code> para
indicar el estado apropiado, <a href="#orgd6dbcbe"><code>fopen</code></a> no asigna ningun espado para
el buffer; esto es realizado por <code>_fillbuf</code> cuando el archivo se
lee por primera vez.
</p>

<div class="org-src-container">
<pre class="src src-c"><span style="color: #b0c4de;">#include</span> <span style="color: #ffa07a;">&lt;fcntl.h&gt;</span>
<span style="color: #b0c4de;">#include</span> <span style="color: #ffa07a;">"syscalls.h"</span>
<span style="color: #b0c4de;">#define</span> <span style="color: #eedd82;">PERMS</span> 0666    <span style="color: #ff4500;">/* </span><span style="color: #ff4500;">lectura y escritura para propietario, grupo, otros </span><span style="color: #ff4500;">*/</span>

<span style="color: #ff4500;">/* </span><span style="color: #ff4500;">iopen: abre un archivo, regresa un apuntador de archivo </span><span style="color: #ff4500;">*/</span>
<span style="color: #98fb98;">FILE</span> *<span style="color: #87cefa;">fopen</span>(<span style="color: #98fb98;">char</span> *<span style="color: #eedd82;">name</span>, <span style="color: #98fb98;">char</span> *<span style="color: #eedd82;">mode</span>)
{
  <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">fd</span>;
  <span style="color: #98fb98;">FILE</span> *<span style="color: #eedd82;">fp</span>;

  <span style="color: #00ffff;">if</span> (*mode != <span style="color: #ffa07a;">'r'</span> &amp;&amp; *mode != <span style="color: #ffa07a;">'w'</span> &amp;&amp; *mode != <span style="color: #ffa07a;">'a'</span>)
    <span style="color: #00ffff;">return</span> <span style="color: #7fffd4;">NULL</span>;
  <span style="color: #00ffff;">for</span> (fp = _iob; fp &lt; _iob + OPEN_MAX; fp++)
    <span style="color: #00ffff;">if</span> ((fp-&gt;flag &amp; (_READ | _WRITE)) == 0)
      <span style="color: #00ffff;">break</span>;                 <span style="color: #ff4500;">/* </span><span style="color: #ff4500;">se encontro una entrada libre </span><span style="color: #ff4500;">*/</span>
  <span style="color: #00ffff;">if</span> (fp &gt;= _iob + OPEN_MAX) <span style="color: #ff4500;">/* </span><span style="color: #ff4500;">no hay entradas libres        </span><span style="color: #ff4500;">*/</span>
    <span style="color: #00ffff;">return</span> <span style="color: #7fffd4;">NULL</span>;

  <span style="color: #00ffff;">if</span> (*mode == <span style="color: #ffa07a;">'w'</span>)
    fd = creat(name, PERMS);
  <span style="color: #00ffff;">else</span> <span style="color: #00ffff;">if</span> (*mode == <span style="color: #ffa07a;">'a'</span>) {
    <span style="color: #00ffff;">if</span> ((fd = open(name, O_WRONLY, 0)) == -1)
      fd = creat(name, PERMS);
    lseek(fd, 0L, 2);
  } <span style="color: #00ffff;">else</span>
    fd = open(name, O_RDONLY, 0);
  <span style="color: #00ffff;">if</span> (fd == -1)              <span style="color: #ff4500;">/* </span><span style="color: #ff4500;">no hubo acceso al nombre      </span><span style="color: #ff4500;">*/</span>
    <span style="color: #00ffff;">return</span> <span style="color: #7fffd4;">NULL</span>;
  fp-&gt;fd = fd;
  fp-&gt;cnt = 0;
  fp-&gt;base = <span style="color: #7fffd4;">NULL</span>;
  fp-&gt;flag = (*mode == <span style="color: #ffa07a;">'r'</span>) ? _READ : _WRITE;
  <span style="color: #00ffff;">return</span> fp;
}
</pre>
</div>

<p>
Esta version de <a href="#orgd6dbcbe"><code>fopen</code></a> no maneja todas las posibilidades de modos
de acceso del estandar, aunque el agregarlas no se llevaria mucho
codigo. En particular, nuestro <a href="#orgd6dbcbe"><code>fopen</code></a> no reconoce la "b" que
indica acceso binario, ya que eso no tiene significado en sistemas
UNIX, ni el "+" que permite tanto lectura como escritura.
</p>

<p>
La primera llamada a <a href="#org7181de4"><code>getc</code></a> para un archivo en particular encuentra
una cuenta de cero, lo que obliga a una llamada a <code>_fillbuf</code>. Si
<code>_fillbuf</code> encuentra que el archivo no esta abierto para lectura,
regresa <code>EOF</code> de inmediato. De otra forma, trata de asignar un
buffer (si la lectura sera con buffer).
</p>

<p>
Una vez que el buffer ha sido establecido, <code>_fillbuff</code> llama a
<code>read</code> para llenarlo, fija la cuenta y los apuntadores, y regresa
el caracter del principio del buffer. Las posteriores llamadas a
<code>_fillbuf</code> encontraran un buffer asignado.
</p>

<div class="org-src-container">
<pre class="src src-c"><span style="color: #b0c4de;">#include</span> <span style="color: #ffa07a;">"syscalls.h"</span>

<span style="color: #ff4500;">/* </span><span style="color: #ff4500;">_fillbuf: asigna y llena un buffer de entrada </span><span style="color: #ff4500;">*/</span>
<span style="color: #98fb98;">int</span> <span style="color: #87cefa;">_fillbuf</span>(<span style="color: #98fb98;">FILE</span> *<span style="color: #eedd82;">fp</span>)
{
  <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">bufsize</span>;

  <span style="color: #00ffff;">if</span> ((fp-&gt;flag&amp;(_READ|_EOF|_ERR)) != _READ)
    <span style="color: #00ffff;">return</span> EOF;
  bufsize = (fp-&gt;flag &amp; _UNBUF) ? 1 : BUFSIZ;
  <span style="color: #00ffff;">if</span> (fp-&gt;base == <span style="color: #7fffd4;">NULL</span>)  <span style="color: #ff4500;">/* </span><span style="color: #ff4500;">sin buffer aun             </span><span style="color: #ff4500;">*/</span>
    <span style="color: #00ffff;">if</span> ((fp-&gt;base = (<span style="color: #98fb98;">char</span> *) malloc(bufsize)) == <span style="color: #7fffd4;">NULL</span>)
      <span style="color: #00ffff;">return</span> EOF;        <span style="color: #ff4500;">/* </span><span style="color: #ff4500;">no puede obtener un buffer </span><span style="color: #ff4500;">*/</span>
  fp-&gt;ptr = fp-&gt;base;
  fp-&gt;cnt = read(fp-&gt;fd, fp-&gt;ptr, bufsize);
  <span style="color: #00ffff;">if</span> (--fp-&gt;cnt &lt; 0) {
    <span style="color: #00ffff;">if</span> (fp-&gt;cnt == -1)
      fp-&gt;flag |= _EOF;
    <span style="color: #00ffff;">else</span>
      fp-&gt;flag |= _ERR;
    fp-&gt;cnt = 0;
    <span style="color: #00ffff;">return</span> EOF;
  }
  <span style="color: #00ffff;">return</span> (<span style="color: #98fb98;">unsigned</span> <span style="color: #98fb98;">char</span>) *fp-&gt;ptr++;
}
</pre>
</div>

<p>
El unico cabo suelto es como arrancar todo. El arreglo <code>_iob</code> debe
ser definido e inicializado para <code>stdin</code>, <code>stdout</code> y <code>stderr</code>:
</p>

<div class="org-src-container">
<pre class="src src-c"><span style="color: #98fb98;">FILE</span> <span style="color: #eedd82;">_iob</span>[OPEN_MAX] = { <span style="color: #ff4500;">/* </span><span style="color: #ff4500;">stdin, stdout, stderr </span><span style="color: #ff4500;">*/</span>
  { 0, (<span style="color: #98fb98;">char</span> *) 0, (<span style="color: #98fb98;">char</span> *) 0, _READ, 0 },
  { 0, (<span style="color: #98fb98;">char</span> *) 0, (<span style="color: #98fb98;">char</span> *) 0, _WRITE, 1 },
  { 0, (<span style="color: #98fb98;">char</span> *) 0, (<span style="color: #98fb98;">char</span> *) 0, _WRITE | _UNBUF, 2 }
};
</pre>
</div>

<p>
La inicializacion de la parte <code>flag</code> de la estructura muestra que
<code>stdin</code> sera leido, <code>stdout</code> sera escrito, y <code>stderr</code> sera escrito
sin buffer.
</p>

<p>
<b>Ejercicio 8-2</b>. Reescriba <a href="#orgd6dbcbe"><code>fopen</code></a> y <code>_fillbut</code> con campos en vez
de operaciones explicitas de bits. Compare el tamaño del codigo y
la velocidad de ejecucion.
</p>

<p>
<b>Ejercicio 8-3</b>. Diseñe y escriba <code>_flushbuf</code>, <a href="#orgd4f97b8"><code>fflush</code></a>, y
<a href="#orge0fc4f1"><code>fclose</code></a>.
</p>

<p>
<b>Ejercicio 8-4</b>. La funcion de biblioteca estandar
</p>

<div class="org-src-container">
<pre class="src src-c"><span style="color: #98fb98;">int</span> <span style="color: #87cefa;">fseek</span>(<span style="color: #98fb98;">FILE</span> * <span style="color: #eedd82;">fp</span>, <span style="color: #98fb98;">long</span> <span style="color: #eedd82;">offset</span>, <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">origin</span>)
</pre>
</div>

<p>
es identica a <code>lseek</code> excepto que <code>fp</code> es un apuntador de archivo
en vez de un descriptor de archivo, y el valor regresado es un
estado <code>int</code>, no una posicion. Escriba <a href="#org20f3c96"><code>fseek</code></a>. Asegurese de que su
<a href="#org20f3c96"><code>fseek</code></a> se coordina apropiadamente con el manejo de buffers
realizado por las otras funciones de la biblioteca.
</p>
</div>
</div>

<div id="outline-container-org9a8872b" class="outline-3">
<h3 id="org9a8872b">8.6  Ejemplo - listado de directorios                              <a id="org6bb8329"></a></h3>
<div class="outline-text-3" id="text-org9a8872b">
<p>
Algunas veces se requiere una forma diferente de interaccion con el
sistema de archivos, para determinar informacion <i>acerca</i> de un
archivo, no lo que contiene. Un programa que lista un directorio
tal como la orden <code>ls</code> de UNIX es un ejemplo - imprime los nombres
de los archivos que estan en el directorio, y, en forma optativa,
mas informacion, tal como tamaños, permisos y esas cosas. La orden
<code>dir</code> de MS-DOS es analoga.
</p>

<p>
Como un directorio de UNIX es simplemente un archivo, <code>ls</code> solo
necesita leerlo para obtener los nombres de archivos. Pero es
necesario utilizar una llamada al sistema para tener acceso a la
otra informacion acerca del archivo, tal como su tamaño. En otros
sistemas puede ser necesaria una llamada al sistema incluso para
los nombres de los archivos; este es el caso de MS-DOS, por
ejemplo. Lo que nosotros queremos es proporcionar acceso a la
informacion en una forma relativamente independiente del sistema, a
pesar incluso de que la realizacion pueda ser altamente dependiente
del sistema.
</p>

<p>
Ilustraremos algo de esto escribiendo un programa llamado
<code>fsize</code>. <code>fsize</code> es una forma especial de <code>ls</code> que imprime los
tamaños de todos los archivos nombrados en su lista de
argumentos. Si uno de los archivos es un directorio <code>fsize</code> se
aplica en forma recursiva para ese directorio. Si no hay ningun
argumento, procesa el directorio actual.
</p>

<p>
Iniciemos con una breve revision de la estructura del sistema de
archivos de UNIX. Un <i>directorio</i> es un archivo que contiene una
lista de nombres de archivo y algunas indicaciones de donde se
localizan. La "localizacion" es un indice en otra tabla llamada la
"lista de i-nodos". El <i>inodo</i> para un archivo es donde se mantiene
toda la informacion acerca de un archivo, excepto su nombre.  Una
entrada en el directorio consiste generalmente en solo dos items,
el nombre del archivo y el numero de inodo.
</p>

<p>
Desafortunadamente, el formato y el contenido preciso de un
directorio no es el mismo en todas las versiones del sistema. De
modo que dividiremos la tarea en dos partes para tratar de aislar
las partes no transportables. El nivel mas externo define una
estructura llamada <code>Dirent</code> y tres rutinas, <code>opendir</code>, <code>readdir</code>, y
<code>closedir</code> para proporcionar acceso independiente del sistema al
nombre y numero de inodo en una entrada del directorio.
Escribiremos <code>fsize</code> con esta interfaz. Despues mostraremos como
hacer esto en sistemas que usan la misma estructura de directorios
que UNIX Version 7, y System V; las variantes son dejadas como
ejercicios.
</p>

<p>
La estructura <code>Dirent</code> contiene el numero de <code>inodo</code> y el
nombre. La longitud maxima de un componente del nombre de archivo
es <code>NAME_MAX</code>, que es un valor dependiente del sistema, <code>opendir</code>
regresa un apuntador a una estructura llamada <code>DIR</code>, analoga a
<code>FILE</code>, que es empleada por <code>readdir</code> y <code>closedir</code>. La informacion
es recolectada en un archivo llamado <code>dirent.h</code>.
</p>


<div class="org-src-container">
<pre class="src src-c"><span style="color: #b0c4de;">#define</span> <span style="color: #eedd82;">NAME_MAX</span> 14      <span style="color: #ff4500;">/* </span><span style="color: #ff4500;">componente de nombre de archivo mas grande; </span><span style="color: #ff4500;">*/</span>
                         <span style="color: #ff4500;">/* </span><span style="color: #ff4500;">dependiente del sistema                     </span><span style="color: #ff4500;">*/</span>

<span style="color: #00ffff;">typedef</span> <span style="color: #00ffff;">struct</span> {         <span style="color: #ff4500;">/* </span><span style="color: #ff4500;">entrada de directorio transportable: </span><span style="color: #ff4500;">*/</span>
  <span style="color: #98fb98;">long</span> <span style="color: #eedd82;">ino</span>;              <span style="color: #ff4500;">/* </span><span style="color: #ff4500;">numero de inodo                      </span><span style="color: #ff4500;">*/</span>
  <span style="color: #98fb98;">char</span> <span style="color: #eedd82;">name</span>[NAME_MAX+1]; <span style="color: #ff4500;">/* </span><span style="color: #ff4500;">nombre + terminador '\0'             </span><span style="color: #ff4500;">*/</span>
} <span style="color: #98fb98;">Dirent</span>;

<span style="color: #00ffff;">typedef</span> <span style="color: #00ffff;">struct</span> {         <span style="color: #ff4500;">/* </span><span style="color: #ff4500;">DIR minima: sin buffer, etc.             </span><span style="color: #ff4500;">*/</span>
  <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">fd</span>;                <span style="color: #ff4500;">/* </span><span style="color: #ff4500;">descriptor de archivo para el directorio </span><span style="color: #ff4500;">*/</span>
  <span style="color: #98fb98;">Dirent</span> <span style="color: #eedd82;">d</span>;              <span style="color: #ff4500;">/* </span><span style="color: #ff4500;">la entrada del directorio                </span><span style="color: #ff4500;">*/</span>
} <span style="color: #98fb98;">DIR</span>;

<span style="color: #98fb98;">DIR</span> *<span style="color: #87cefa;">opendir</span>(<span style="color: #98fb98;">char</span> *<span style="color: #eedd82;">dirname</span>);
<span style="color: #98fb98;">Dirent</span> *<span style="color: #87cefa;">readdir</span>(<span style="color: #98fb98;">DIR</span> *<span style="color: #eedd82;">dfd</span>);
<span style="color: #98fb98;">void</span> <span style="color: #87cefa;">closedir</span>(<span style="color: #98fb98;">DIR</span> *<span style="color: #eedd82;">dfd</span>);
</pre>
</div>

<p>
La llamada al sistema <code>stat</code> toma un nombre de archivo y regresa
toda la informacion que esta en el inodo para ese archivo, o <code>-1</code>
si existe un error. Esto es,
</p>

<div class="org-src-container">
<pre class="src src-c"><span style="color: #98fb98;">char</span> * <span style="color: #eedd82;">name</span>;
<span style="color: #00ffff;">struct</span> <span style="color: #98fb98;">stat</span> <span style="color: #eedd82;">stbuf</span>;
<span style="color: #98fb98;">int</span> <span style="color: #87cefa;">stat</span>(<span style="color: #98fb98;">char</span> *, <span style="color: #00ffff;">struct</span> <span style="color: #98fb98;">stat</span> *);

<span style="color: #87cefa;">stat</span>(name, &amp;strbuf);
</pre>
</div>

<p>
llena la estructura <code>stbuf</code> con la informacion del inodo para el
nombre de archivo.
</p>

<p>
La estructura que describe el valor regresado por <code>stat</code> esta en
<code>&lt;sys/stat.h&gt;</code>, y tipicamente se ve asi:
</p>

<div class="org-src-container">
<pre class="src src-c"><span style="color: #00ffff;">struct</span> <span style="color: #98fb98;">stat</span>  <span style="color: #ff4500;">/* </span><span style="color: #ff4500;">informacion de inodo regresada por stat </span><span style="color: #ff4500;">*/</span>
{
  <span style="color: #98fb98;">dev_t</span>    <span style="color: #eedd82;">st_dev</span>;     <span style="color: #ff4500;">/* </span><span style="color: #ff4500;">dispositivo de inodo             </span><span style="color: #ff4500;">*/</span>
  <span style="color: #98fb98;">ino_t</span>    <span style="color: #eedd82;">st_ino</span>;     <span style="color: #ff4500;">/* </span><span style="color: #ff4500;">numero de inodo                  </span><span style="color: #ff4500;">*/</span>
  <span style="color: #98fb98;">short</span>    <span style="color: #eedd82;">st_mode</span>;    <span style="color: #ff4500;">/* </span><span style="color: #ff4500;">bits de modo                     </span><span style="color: #ff4500;">*/</span>
  <span style="color: #98fb98;">short</span>    <span style="color: #eedd82;">st_nlink</span>;   <span style="color: #ff4500;">/* </span><span style="color: #ff4500;">numero de enlaces al archivo     </span><span style="color: #ff4500;">*/</span>
  <span style="color: #98fb98;">short</span>    <span style="color: #eedd82;">st_uid</span>;     <span style="color: #ff4500;">/* </span><span style="color: #ff4500;">id. de usuario del propietario   </span><span style="color: #ff4500;">*/</span>
  <span style="color: #98fb98;">short</span>    <span style="color: #eedd82;">st_gid</span>;     <span style="color: #ff4500;">/* </span><span style="color: #ff4500;">id. de grupo del propietario     </span><span style="color: #ff4500;">*/</span>
  <span style="color: #98fb98;">dev_t</span>    <span style="color: #eedd82;">st_rdev</span>;    <span style="color: #ff4500;">/* </span><span style="color: #ff4500;">para archivos especiales         </span><span style="color: #ff4500;">*/</span>
  <span style="color: #98fb98;">off_t</span>    <span style="color: #eedd82;">st_size</span>;    <span style="color: #ff4500;">/* </span><span style="color: #ff4500;">tama&#241;o del archivo en caracteres </span><span style="color: #ff4500;">*/</span>
  <span style="color: #98fb98;">time_t</span>   <span style="color: #eedd82;">st_atime</span>;   <span style="color: #ff4500;">/* </span><span style="color: #ff4500;">hora del ultimo acceso           </span><span style="color: #ff4500;">*/</span>
  <span style="color: #98fb98;">time_t</span>   <span style="color: #eedd82;">st_mtime</span>;   <span style="color: #ff4500;">/* </span><span style="color: #ff4500;">hora de la ultima modificacion   </span><span style="color: #ff4500;">*/</span>
  <span style="color: #98fb98;">time_t</span>   <span style="color: #eedd82;">st_ctime</span>;   <span style="color: #ff4500;">/* </span><span style="color: #ff4500;">hora de creacion original        </span><span style="color: #ff4500;">*/</span>
};
</pre>
</div>

<p>
La mayoria de estos valores son explicados por los campos de
comentario. Los tipos como <code>dev_t</code> e <code>ino_t</code> estan definidos en
<code>&lt;sys/types.h&gt;</code>, que tambien debe ser incluido.
</p>

<p>
La entrada <code>st_mode</code> contiene un conjunto de banderas que describen
el archivo. La definicion de banderas esta tambien incluida en
<code>&lt;sys/stat.h&gt;</code>; solo requerimos de la parte que tiene que ver con
el tipo de archivo
</p>

<div class="org-src-container">
<pre class="src src-c"><span style="color: #b0c4de;">#define</span> <span style="color: #eedd82;">S_IFMT</span>   0160000   <span style="color: #ff4500;">/* </span><span style="color: #ff4500;">tipo de archivo        </span><span style="color: #ff4500;">*/</span>
<span style="color: #b0c4de;">#define</span> <span style="color: #eedd82;">S_IFDIR</span>  0040000   <span style="color: #ff4500;">/* </span><span style="color: #ff4500;">directorio             </span><span style="color: #ff4500;">*/</span>
<span style="color: #b0c4de;">#define</span> <span style="color: #eedd82;">S_IFCHR</span>  0020000   <span style="color: #ff4500;">/* </span><span style="color: #ff4500;">especial de caracteres </span><span style="color: #ff4500;">*/</span>
<span style="color: #b0c4de;">#define</span> <span style="color: #eedd82;">S_IFBLK</span>  0060000   <span style="color: #ff4500;">/* </span><span style="color: #ff4500;">especial de bloque     </span><span style="color: #ff4500;">*/</span>
<span style="color: #b0c4de;">#define</span> <span style="color: #eedd82;">S_IFREG</span>  0100000   <span style="color: #ff4500;">/* </span><span style="color: #ff4500;">regular                </span><span style="color: #ff4500;">*/</span>
<span style="color: #ff4500;">/* </span><span style="color: #ff4500;">... </span><span style="color: #ff4500;">*/</span>
</pre>
</div>

<p>
Ahora estamos listos para escribir el programa <code>fsize</code>. Si el modo
obtenido de <code>stat</code> indica que un archivo no es un directorio,
entonces el tamaño esta a la mano y puede ser impreso
directamente. Si el archivo es un directorio, sin embargo, entonces
tenemos que procesar ese directorio un archivo a la vez; puede a su
vez contener subdirectorios, de modo que el proceso es recursivo.
</p>

<p>
La rutina principal trata con los argumentos de la linea de
ordenes; pasa cada argumento a la funcion <code>fsize</code>.
</p>

<div class="org-src-container">
<pre class="src src-c"><span style="color: #b0c4de;">#include</span> <span style="color: #ffa07a;">&lt;stdio.h&gt;</span>
<span style="color: #b0c4de;">#include</span> <span style="color: #ffa07a;">&lt;string.h&gt;</span>
<span style="color: #b0c4de;">#include</span> <span style="color: #ffa07a;">"syscalls.h"</span>
<span style="color: #b0c4de;">#include</span> <span style="color: #ffa07a;">&lt;fcntl.h&gt;</span>         <span style="color: #ff4500;">/* </span><span style="color: #ff4500;">banderas para lectura y escritura </span><span style="color: #ff4500;">*/</span>
<span style="color: #b0c4de;">#include</span> <span style="color: #ffa07a;">&lt;sys/types.h&gt;</span>     <span style="color: #ff4500;">/* </span><span style="color: #ff4500;">typedefs                          </span><span style="color: #ff4500;">*/</span>
<span style="color: #b0c4de;">#include</span> <span style="color: #ffa07a;">&lt;sys/stat.h&gt;</span>      <span style="color: #ff4500;">/* </span><span style="color: #ff4500;">estructura regresada por stat     </span><span style="color: #ff4500;">*/</span>
<span style="color: #b0c4de;">#include</span> <span style="color: #ffa07a;">"dirent.h"</span>

<span style="color: #98fb98;">void</span> <span style="color: #87cefa;">fsize</span>(<span style="color: #98fb98;">char</span> *);

<span style="color: #ff4500;">/* </span><span style="color: #ff4500;">imprime tama&#241;os de archivos </span><span style="color: #ff4500;">*/</span>
<span style="color: #87cefa;">main</span>(<span style="color: #98fb98;">int</span> <span style="color: #eedd82;">argc</span>, <span style="color: #98fb98;">char</span> **<span style="color: #eedd82;">argv</span>)
{
  <span style="color: #00ffff;">if</span> (argc == 1) <span style="color: #ff4500;">/* </span><span style="color: #ff4500;">default: directorio actual </span><span style="color: #ff4500;">*/</span>
    fsize(<span style="color: #ffa07a;">"."</span>);
  <span style="color: #00ffff;">else</span>
    <span style="color: #00ffff;">while</span> (--argc &gt; 0)
      fsize(*++argv);
  <span style="color: #00ffff;">return</span> 0;
}
</pre>
</div>

<p>
La funcion <code>fsize</code> imprime el tamaño del archivo. Sin embargo, si
el archivo es un directorio, <code>fsize</code> llama primero a <code>dirwalk</code> para
manejar todos los archivos en el. Note como se usan los nombres de
las banderas <code>S_IFMT</code> y <code>S_IFDIR</code> de <code>&lt;sys/stat.h&gt;</code> para decidir si
el archivo es un directorio. El uso de los parentesis importa,
debido a que la precedencia de <code>&amp;</code> es inferior que la de <code>==</code>.
</p>

<div class="org-src-container">
<pre class="src src-c"><span style="color: #98fb98;">int</span> <span style="color: #87cefa;">stat</span>(<span style="color: #98fb98;">char</span> *, <span style="color: #00ffff;">struct</span> <span style="color: #98fb98;">stat</span> *);
<span style="color: #98fb98;">void</span> <span style="color: #87cefa;">dirwalk</span>(<span style="color: #98fb98;">char</span> *, <span style="color: #98fb98;">void</span> (*<span style="color: #87cefa;">fcn</span>)(<span style="color: #98fb98;">char</span> *));

<span style="color: #ff4500;">/* </span><span style="color: #ff4500;">fsize: imprime el tama&#241;o del archivo "name" </span><span style="color: #ff4500;">*/</span>
<span style="color: #98fb98;">void</span> <span style="color: #87cefa;">fsize</span>(<span style="color: #98fb98;">char</span> *<span style="color: #eedd82;">name</span>)
{
  <span style="color: #00ffff;">struct</span> <span style="color: #98fb98;">stat</span> <span style="color: #eedd82;">stbuf</span>;

  <span style="color: #00ffff;">if</span> (stat(name, &amp;stbuf) == -1) {
    fprintf(stderr, <span style="color: #ffa07a;">"fsize: no se tiene acceso a %s\n"</span>, name);
    <span style="color: #00ffff;">return</span>;
  }
  <span style="color: #00ffff;">if</span> ((stbuf.st_mode &amp; S_IFMT) == S_IFDIR)
    dirwalk(name, fsize);
  printf(<span style="color: #ffa07a;">"%8ld %s\n"</span>, stbuf.st_size, name);
}
</pre>
</div>

<p>
La funcion <code>dirwalk</code> es una rutina de proposito general que aplica
una funcion a cada archivo que esta dentro de un directorio. Abre
el directorio, itera con todos los archivos que hay en el, llamando
en cada uno a la funcion; despues cierra el directorio y
regresa. Puesto que <code>fsize</code> llama a <code>dirwalk</code> en cada directorio,
las dos funciones se llaman recursivamente una a la otra.
</p>

<div class="org-src-container">
<pre class="src src-c"><span style="color: #b0c4de;">#define</span> <span style="color: #eedd82;">MAX_PATH</span> 1024

<span style="color: #ff4500;">/* </span><span style="color: #ff4500;">dirwalk: aplica fcn a todos los archivos de dir </span><span style="color: #ff4500;">*/</span>
<span style="color: #98fb98;">void</span> <span style="color: #87cefa;">dirwalk</span>(<span style="color: #98fb98;">char</span> *<span style="color: #eedd82;">dir</span>, <span style="color: #98fb98;">void</span> (*<span style="color: #87cefa;">fcn</span>)(<span style="color: #98fb98;">char</span> *))
{
  <span style="color: #98fb98;">char</span> <span style="color: #eedd82;">name</span>[MAX_PATH];
  <span style="color: #98fb98;">Dirent</span> *<span style="color: #eedd82;">dp</span>;
  <span style="color: #98fb98;">DIR</span> *<span style="color: #eedd82;">dfd</span>;

  <span style="color: #00ffff;">if</span> ((dfd = opendir(dir)) == <span style="color: #7fffd4;">NULL</span>) {
    fprintf(stderr, <span style="color: #ffa07a;">"dirwalk: no se puede abrir %s\n"</span>, dir);
    <span style="color: #00ffff;">return</span>;
  }
  <span style="color: #00ffff;">while</span> ((dp = readdir(dfd)) != <span style="color: #7fffd4;">NULL</span>) {
    <span style="color: #00ffff;">if</span> (strcmp(dp-&gt;name, <span style="color: #ffa07a;">"."</span>) == 0
        || strcmp(dp-&gt;name, <span style="color: #ffa07a;">".."</span>))
      <span style="color: #00ffff;">continue</span>;     <span style="color: #ff4500;">/* </span><span style="color: #ff4500;">se ignora a si mismo y a su padre </span><span style="color: #ff4500;">*/</span>
    <span style="color: #00ffff;">if</span> (strlen(dir)+strlen(dp-&gt;name)+2 &gt; <span style="color: #00ffff;">sizeof</span>(name))
      fprintf(stderr, <span style="color: #ffa07a;">"dirwalk: nombre %s %s demasiado largo\n"</span>,
              dir, dp-&gt;name);
    <span style="color: #00ffff;">else</span> {
      sprintf(name, <span style="color: #ffa07a;">"%s/%s"</span>, dir, dp-&gt;name);
      (*fcn)(name);
    }
  }
  closedir(dfd);
}
</pre>
</div>

<p>
Cada llamada a <code>readdir</code> regresa un apuntador a informacion para el
siguiente archivo, o <code>NULL</code> cuando ya no quedan archivos. Cada
directorio siempre contiene entradas para si mismo, llamada ".", y
para su padre ".."; deben ser ignoradas, o el programa iterara por
siempre.
</p>

<p>
En este nivel, el codigo es independiente de como esta el formato
de los directorios. El siguiente paso es presentar versiones
minimas de <code>opendir</code>, <code>readdir</code>, y <code>closedir</code> para un sistema
especifico. Las siguientes rutinas son para sistemas UNIX Version 7
y System V; utilizan la informacion que esta en el header
<code>&lt;sys/dir.h&gt;</code>, que aparece asi:
</p>

<div class="org-src-container">
<pre class="src src-c"><span style="color: #b0c4de;">#if</span><span style="color: #b0c4de;">n</span><span style="color: #b0c4de;">def</span> DIRSIZ
<span style="color: #b0c4de;">#define</span> <span style="color: #eedd82;">DIRSIZ</span> 14
<span style="color: #b0c4de;">#endif</span>
<span style="color: #00ffff;">struct</span> <span style="color: #98fb98;">direct</span> {        <span style="color: #ff4500;">/* </span><span style="color: #ff4500;">entrada del directorio            </span><span style="color: #ff4500;">*/</span>
  <span style="color: #98fb98;">ino_t</span> <span style="color: #eedd82;">d_ino</span>;         <span style="color: #ff4500;">/* </span><span style="color: #ff4500;">numero de inodo                   </span><span style="color: #ff4500;">*/</span>
  <span style="color: #98fb98;">char</span> <span style="color: #eedd82;">d_name</span>[DIRSIZ]; <span style="color: #ff4500;">/* </span><span style="color: #ff4500;">los nombres largos no tienen '\0' </span><span style="color: #ff4500;">*/</span>
};
</pre>
</div>

<p>
Algunas versiones del sistema permiten nombres mucho mas largos y
tienen una estructura de directorios mas complicada.
</p>

<p>
El tipo <code>ino_t</code> es un <code>typedef</code> que describe el indice de la lista
de inodos. En el sistema que usamos regularmente es un <code>unsigned
   short</code>, pero esta no es la clase de informacion para incluir en un
programa; puede ser distinta en un sistema diferente, de modo que
<code>typedef</code> es mejor. Un juego completo de tipos "del sistema" se
encuentra en <code>&lt;sys/types.h&gt;</code>.
</p>

<p>
<code>opendir</code> abre el directorio, verifica que el archivo sea un
directorio (esta vez por medio de la llamada al sistema <code>fstat</code>,
que es como <code>stat</code> excepto en que se aplica a un descriptor de
archivo), asigna una estructura de directorio, y graba la
informacion.
</p>

<div class="org-src-container">
<pre class="src src-c"><span style="color: #98fb98;">int</span> <span style="color: #87cefa;">fstat</span>(<span style="color: #98fb98;">int</span> <span style="color: #eedd82;">fd</span>, <span style="color: #00ffff;">struct</span> <span style="color: #98fb98;">stat</span> *);

<span style="color: #ff4500;">/* </span><span style="color: #ff4500;">opendir: abre un directorio para llamadas de readdir </span><span style="color: #ff4500;">*/</span>
<span style="color: #98fb98;">DIR</span> *<span style="color: #87cefa;">opendir</span>(<span style="color: #98fb98;">char</span> *<span style="color: #eedd82;">dirname</span>)
{
  <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">fd</span>;
  <span style="color: #00ffff;">struct</span> <span style="color: #98fb98;">stat</span> <span style="color: #eedd82;">stbuf</span>;
  <span style="color: #98fb98;">DIR</span> *<span style="color: #eedd82;">dp</span>;

  <span style="color: #00ffff;">if</span> ((fd = open(dirname, O_RDONLY, 0)) == -1
      || fstat(fd, &amp;stbuf) == -1
      || (stbuf.st_mode &amp; S_IFMT) != S_IFDIR
      || (dp = (<span style="color: #98fb98;">DIR</span> *) malloc(<span style="color: #00ffff;">sizeof</span>(DIR))) == <span style="color: #7fffd4;">NULL</span>)
    <span style="color: #00ffff;">return</span> <span style="color: #7fffd4;">NULL</span>;
  dp-&gt;fd = fd;
  <span style="color: #00ffff;">return</span> dp;
}
</pre>
</div>

<p>
<code>closedir</code> cierra el archivo del directorio y libera el espacio:
</p>

<div class="org-src-container">
<pre class="src src-c"><span style="color: #ff4500;">/* </span><span style="color: #ff4500;">closedir: cierra un directorio abierto por opendir </span><span style="color: #ff4500;">*/</span>
<span style="color: #98fb98;">void</span> <span style="color: #87cefa;">closedir</span>(<span style="color: #98fb98;">DIR</span> *<span style="color: #eedd82;">dp</span>)
{
  <span style="color: #00ffff;">if</span> (dp) {
    close(dp-&gt;fd);
    free(dp);
  }
}
</pre>
</div>

<p>
Finalmente, <code>readdir</code> usa a <code>read</code> para leer cada entrada del
directorio. Si una entrada del directorio no esta actualmente en
uso (debido a que ha sido removido un archivo), el numero de inodo
es cero, y esta posicion se salta. De otra forma, el numero de
inodo y el nombre son colocados en una estructura <code>static</code> y se
regresa al usuario un apuntador a ella. Cada llamada sobreescribe
la informacion de la anterior.
</p>

<div class="org-src-container">
<pre class="src src-c"><span style="color: #b0c4de;">#include</span> <span style="color: #ffa07a;">&lt;sys/dir.h&gt;</span>    <span style="color: #ff4500;">/* </span><span style="color: #ff4500;">estructura local de directorio </span><span style="color: #ff4500;">*/</span>

<span style="color: #ff4500;">/* </span><span style="color: #ff4500;">readdir: lee en secuencia las entradas de un directorio </span><span style="color: #ff4500;">*/</span>
<span style="color: #98fb98;">Dirent</span> *<span style="color: #87cefa;">readdir</span>(<span style="color: #98fb98;">DIR</span> *<span style="color: #eedd82;">dp</span>)
{
  <span style="color: #00ffff;">struct</span> <span style="color: #98fb98;">direct</span> <span style="color: #eedd82;">dirbuf</span>; <span style="color: #ff4500;">/* </span><span style="color: #ff4500;">estructura local de directorio    </span><span style="color: #ff4500;">*/</span>
  <span style="color: #00ffff;">static</span> <span style="color: #98fb98;">Dirent</span> <span style="color: #eedd82;">d</span>;      <span style="color: #ff4500;">/* </span><span style="color: #ff4500;">regreso: estructura transportable </span><span style="color: #ff4500;">*/</span>

  <span style="color: #00ffff;">while</span> (read(dp-&gt;fd, (<span style="color: #98fb98;">char</span> *) &amp;dirbuf, <span style="color: #00ffff;">sizeof</span>(dirbuf))
         == <span style="color: #00ffff;">sizeof</span>(dirbuf)) {
    <span style="color: #00ffff;">if</span> (dirbuf.d_ino == 0) <span style="color: #ff4500;">/* </span><span style="color: #ff4500;">entrada que no esta en uso </span><span style="color: #ff4500;">*/</span>
      <span style="color: #00ffff;">continue</span>;
    d.ino = dirbuf.d_ino;
    strncpy(d.name, dirbuf.d_name, DIRSIZ);
    d.name[DIRSIZ] = <span style="color: #ffa07a;">'\0'</span>; <span style="color: #ff4500;">/* </span><span style="color: #ff4500;">asegura la terminacion </span><span style="color: #ff4500;">*/</span>
    <span style="color: #00ffff;">return</span> &amp;d;
  }
  <span style="color: #00ffff;">return</span> <span style="color: #7fffd4;">NULL</span>;
}
</pre>
</div>

<p>
Aunque el programa <code>fsize</code> es bastante especializado, ilustra un
par de ideas importantes. Primera, muchos programas no son
"programas del sistema"; simplemente usan informacion que es
mantenida por el sistema operativo. Para tales programas es crucial
que la representacion de la informacion aparezca solo en <i>headers</i>
estandar, y que los programas incluyan esos archivos en vez de
tener las declaraciones en ellos mismos. La segunda observacion es
que con cuidado es posible crear una interfaz hacia objetos
dependientes del sistema que a su vez sea relativamente
independiente del mismo. Las funciones de la biblioteca estandar
son buenos ejemplos.
</p>

<p>
<b>Ejercicio 8-5</b>. Modifique el programa <code>fsize</code> para que imprima el
resto de la informacion contenida en la entrada del inodo.
</p>
</div>
</div>

<div id="outline-container-orgafd9577" class="outline-3">
<h3 id="orgafd9577">8.7  Ejemplo - asignador de memoria                                <a id="org2b166a5"></a></h3>
<div class="outline-text-3" id="text-orgafd9577">
<p>
En el <a href="#org69d49af">capitulo 5</a> presentamos un asignador de memoria muy limitado
que funcionaba en modo de pila. La version que escribiremos ahora
no tiene restricciones. Las llamadas a <a href="#org292ad05"><code>malloc</code></a> y <a href="#org0a5a9fe"><code>free</code></a> pueden
ocurrir en cualquier orden; <a href="#org292ad05"><code>malloc</code></a> llama al sistema operativo
para obtener mas memoria cuando es necesaria. Estas rutinas
ilustran algunas de las consideraciones implicadas en la creacion
de codigo dependiente de maquina en una forma relativamente
independiente, y tambien muestran una aplicacion de estructuras,
uniones y <code>typedef</code> en la vida real.
</p>

<p>
En vez de asignar un arreglo precompilado de tamaño fijo, <a href="#org292ad05"><code>malloc</code></a>
solicitara espacio al sistema operativo cuando sea necesario. Dado
que otras actividades en el programa tambien pueden requerir
espacio sin llamar a este asignador, el espacio que <a href="#org292ad05"><code>malloc</code></a> maneja
puede no ser contiguo. Asi, el espacio libre de almacenamiento es
mantenido como una lista de bloques libres. Cada bloque contiene un
tamaño, un apuntador al siguiente bloque, y el espacio en si. Los
bloques son mantenidos en orden ascendente de direccion de
almacenamiento, y el ultimo bloque (direccion mas alta) apunta al
primero.
</p>


<div class="figure">
<p><img src="img/img_08.07.01.png" alt="img_08.07.01.png" />
</p>
</div>

<p>
Cuando se hace una solicitud, se rastrea la lista libre hasta que
se encuentra un bloque suficientemente grande. Este algoritmo es
llamado "de primer ajuste" (first-fit), en contraste con (best
fit), que busca el bloque mas pequeño que satisfaga la solicitud.
Si el bloque es exactamente del tamaño requerido, se desliga de la
lista y se entrega al usuario. Si el bloque es demasiado grande se
divide, y la cantidad apropiada es entregada al usuario mientras
que el resto permanece en la lista libre. Si no se encuentra un
bloque suficientemente grande, algun otro trozo grande se obtiene
del sistema operativo y se enlaza a la lista libre.
</p>

<p>
La liberacion tambien provoca una busqueda en la lista libre, para
encontrar el lugar apropiado para insertar el bloque que esta
siendo liberado. Si el bloque que esta siendo liberado es adyacente
a un bloque libre en cualquiera de sus lados, se une con el en un
bloque unico mas grande, por lo que el almacenamiento no se
fragmenta demasiado. Determinar la adyacencia es facil puesto que
la lista libre es mantenida en orden ascendente de direcciones.
</p>

<p>
Un problema, al que aludimos en el <a href="#org69d49af">capitulo 5</a>, es asegurar que el
almacenamiento regresado por <a href="#org292ad05"><code>malloc</code></a> este alineado apropiadamente
para los objetos que se almacenaran en el. Aunque las maquinas
varian, para cada una existe un tipo que es el mas restrictivo: si
el tipo mas restrictivo puede ser almacenado en una direccion
particular, todos los otros tipos tambien lo seran. En algunas
maquinas, el tipo mas restrictivo es un <code>double</code>; en otras, basta
<code>int</code> o <code>long</code>.
</p>

<p>
Un bloque libre contiene un apuntador al siguiente bloque de la
cadena, un registro del tamaño del bloque, y luego el espacio
disponible en si; la informacion de control que esta al inicio es
llamada el encabezado. Para simplificar la alineacion, todos los
bloques son multiplos del tamaño del encabezado, y este se alinea
apropiadamente. Esto se logra mediante una union que contiene la
estructura deseada del encabezado y una ocurrencia del tipo de
alineacion mas restrictivo, al que arbitrariamente hemos hecho
long:
</p>

<div class="org-src-container">
<pre class="src src-c"><span style="color: #00ffff;">typedef</span> <span style="color: #98fb98;">long</span> <span style="color: #98fb98;">Align</span>;     <span style="color: #ff4500;">/* </span><span style="color: #ff4500;">para alineamiento al limite mayor          </span><span style="color: #ff4500;">*/</span>

<span style="color: #00ffff;">union</span> <span style="color: #98fb98;">header</span> {          <span style="color: #ff4500;">/* </span><span style="color: #ff4500;">encabezado del bloque                      </span><span style="color: #ff4500;">*/</span>
  <span style="color: #00ffff;">struct</span> {
    <span style="color: #00ffff;">union</span> <span style="color: #98fb98;">header</span> *<span style="color: #eedd82;">ptr</span>;  <span style="color: #ff4500;">/* </span><span style="color: #ff4500;">siguiente bloque si esta en la lista libre </span><span style="color: #ff4500;">*/</span>
    <span style="color: #98fb98;">unsigned</span> <span style="color: #eedd82;">size</span>;      <span style="color: #ff4500;">/* </span><span style="color: #ff4500;">tama&#241;o de este bloque                      </span><span style="color: #ff4500;">*/</span>
  } <span style="color: #eedd82;">s</span>;
  <span style="color: #98fb98;">Align</span> <span style="color: #eedd82;">x</span>;              <span style="color: #ff4500;">/* </span><span style="color: #ff4500;">obliga a la alineacion de bloques          </span><span style="color: #ff4500;">*/</span>
};

<span style="color: #00ffff;">typedef</span> <span style="color: #00ffff;">union</span> <span style="color: #98fb98;">header</span> <span style="color: #98fb98;">Header</span>;
</pre>
</div>

<p>
El campo <code>Align</code> nunca es utilizado; solo hace que cada encabezado
este alineado al limite del peor caso.
</p>

<p>
En <a href="#org292ad05"><code>malloc</code></a>, el tamaño requerido en caracteres es redondeado al
numero apropiado de unidades de tamaño del encabezado; el bloque
que sera asignado contiene una unidad mas, para el encabezado en
si, y este es el valor grabado en el campo <code>size</code>. El apuntador
regresado por <a href="#org292ad05"><code>malloc</code></a> apunta al espacio libre, no al
encabezado. El usuario puede hacer cualquier cosa con el espacio
requerido, pero si algo se escribe fuera del espacio asignado, la
lista se puede desorganizar.
</p>


<div class="figure">
<p><img src="img/img_08.07.02.png" alt="img_08.07.02.png" />
</p>
</div>

<p>
El campo <code>size</code> es necesario debido a que los bloques controlados
por <a href="#org292ad05"><code>malloc</code></a> no requieren ser contiguos - no es posible calcular
tamaños mediante aritmetica de apuntadores.
</p>

<p>
La variable <code>base</code> se usa para comenzar. Si <code>freep</code> es <code>NULL</code>, como
lo es en la primer llamada de <a href="#org292ad05"><code>malloc</code></a>, entonces se crea una lista
libre degenerada que contiene un bloque de tamaño cero y apunta a
si misma. En cualquier caso, luego se busca en la lista libre. La
busqueda de un bloque libre de tamaño adecuado principia en el
punto (<code>freep</code>) donde se encontro el ultimo bloque; esta estrategia
ayuda a mantener la lista homogenea. Si se encuentra un bloque
demasiado grande, al usuario se le regresa la parte final; de esta
forma el encabezado del original solo necesita tener ajustado su
tamaño. En todos los casos, el apuntador regresado al usuario
apunta al espacio libre dentro del bloque, que principia una unidad
mas alla del encabezado.
</p>

<div class="org-src-container">
<pre class="src src-c"><span style="color: #00ffff;">static</span> <span style="color: #98fb98;">Header</span> <span style="color: #eedd82;">base</span>;           <span style="color: #ff4500;">/* </span><span style="color: #ff4500;">lista vacia para iniciar  </span><span style="color: #ff4500;">*/</span>
<span style="color: #00ffff;">static</span> <span style="color: #98fb98;">Header</span> *<span style="color: #eedd82;">freep</span> = <span style="color: #7fffd4;">NULL</span>;  <span style="color: #ff4500;">/* </span><span style="color: #ff4500;">inicio de una lista libre </span><span style="color: #ff4500;">*/</span>

<span style="color: #ff4500;">/* </span><span style="color: #ff4500;">malloc: asignador de almacenamiento de proposito general </span><span style="color: #ff4500;">*/</span>
<span style="color: #98fb98;">void</span> *<span style="color: #87cefa;">malloc</span>(<span style="color: #98fb98;">unsigned</span> <span style="color: #eedd82;">nbytes</span>)
{
  <span style="color: #98fb98;">Header</span> *<span style="color: #eedd82;">p</span>, *<span style="color: #eedd82;">prevp</span>;
  <span style="color: #98fb98;">Header</span> *<span style="color: #87cefa;">morecore</span>(<span style="color: #98fb98;">unsigned</span>);
  <span style="color: #98fb98;">unsigned</span> <span style="color: #eedd82;">nunits</span>;
  nunits = (nbytes+<span style="color: #00ffff;">sizeof</span>(Header)-1)/<span style="color: #00ffff;">sizeof</span>(<span style="color: #00ffff;">union</span> <span style="color: #98fb98;">header</span>) + 1;
  <span style="color: #00ffff;">if</span> ((prevp = freep) == <span style="color: #7fffd4;">NULL</span>) {   <span style="color: #ff4500;">/* </span><span style="color: #ff4500;">no hay lista libre aun </span><span style="color: #ff4500;">*/</span>
    base.s.ptr = freep = prevp = &amp;base;
    base.s.size = 0;
  }
  <span style="color: #00ffff;">for</span> (p = prevp-&gt;s.ptr; ; prevp = p, p = p-&gt;s.ptr) {
    <span style="color: #00ffff;">if</span> (p-&gt;s.size &gt;= nunits) { <span style="color: #ff4500;">/* </span><span style="color: #ff4500;">suficientemente grande </span><span style="color: #ff4500;">*/</span>
      <span style="color: #00ffff;">if</span> (p-&gt;s.size == nunits) <span style="color: #ff4500;">/* </span><span style="color: #ff4500;">exacto                 </span><span style="color: #ff4500;">*/</span>
        prevp-&gt;s.ptr = p-&gt;s.ptr;
      <span style="color: #00ffff;">else</span> {                   <span style="color: #ff4500;">/* </span><span style="color: #ff4500;">asigna la parte final  </span><span style="color: #ff4500;">*/</span>
        p-&gt;s.size -= nunits;
        p += p-&gt;s.size;
        p-&gt;s.size = nunits;
      }
      freep = prevp;
      <span style="color: #00ffff;">return</span> (<span style="color: #98fb98;">void</span> *)(p+1);
    }
    <span style="color: #00ffff;">if</span> (p == freep)   <span style="color: #ff4500;">/* </span><span style="color: #ff4500;">dio la vuelta a !a lista libre </span><span style="color: #ff4500;">*/</span>
      <span style="color: #00ffff;">if</span> ((p = morecore(nunits)) == <span style="color: #7fffd4;">NULL</span>)
        <span style="color: #00ffff;">return</span> <span style="color: #7fffd4;">NULL</span>;  <span style="color: #ff4500;">/* </span><span style="color: #ff4500;">nada libre </span><span style="color: #ff4500;">*/</span>
  }
}
</pre>
</div>

<p>
La funcion <code>morecore</code> obtiene espacio de almacenamiento del sistema
operativo. Los detalles de como lo hace varian de sistema a
sistema. Debido a que pedir memoria al sistema es una operacion
comparativamente costosa, no deseamos hacerlo en cada llamada a
<a href="#org292ad05"><code>malloc</code></a>, asi que <code>morecore</code> solicita al menos <code>NALLOC</code> unidades;
este bloque grande sera seccionado de acuerdo con las necesidades.
Despues de fijar el campo <code>size</code>, <code>morecore</code> inserta la memoria
adicional llamando a <a href="#org0a5a9fe"><code>free</code></a>.
</p>

<div class="org-src-container">
<pre class="src src-c"><span style="color: #b0c4de;">#define</span> <span style="color: #eedd82;">NALLOC</span> 1024   <span style="color: #ff4500;">/* </span><span style="color: #ff4500;">minimo # de unidades por requerir </span><span style="color: #ff4500;">*/</span>

<span style="color: #ff4500;">/* </span><span style="color: #ff4500;">morecore: solicita mas memoria al sistema </span><span style="color: #ff4500;">*/</span>
<span style="color: #00ffff;">static</span> <span style="color: #98fb98;">Header</span> *<span style="color: #87cefa;">morecore</span>(<span style="color: #98fb98;">unsigned</span> <span style="color: #eedd82;">nu</span>)
{
  <span style="color: #98fb98;">char</span> *<span style="color: #eedd82;">cp</span>, *<span style="color: #87cefa;">sbrk</span>(<span style="color: #98fb98;">int</span>);
  <span style="color: #98fb98;">Header</span> *<span style="color: #eedd82;">up</span>;

  <span style="color: #00ffff;">if</span> (nu &lt; NALLOC)
    nu = NALLOC;
  cp = sbrk(<span style="color: #98fb98;">nu</span> * <span style="color: #00ffff;">sizeof</span>(Header));
  <span style="color: #00ffff;">if</span> (cp == (<span style="color: #98fb98;">char</span> *) -1)      <span style="color: #ff4500;">/* </span><span style="color: #ff4500;">no hay nada de espacio </span><span style="color: #ff4500;">*/</span>
    <span style="color: #00ffff;">return</span> <span style="color: #7fffd4;">NULL</span>;
  up = (<span style="color: #98fb98;">Header</span> *) cp;
  up-&gt;s.size = nu;
  free((<span style="color: #98fb98;">void</span> *)(up+1));
  <span style="color: #00ffff;">return</span> freep;
}
</pre>
</div>

<p>
La llamada <code>sbrk(n)</code> al sistema UNIX regresa un apuntador a <code>n</code>
bytes mas de almacenamiento, <code>sbrk</code> regresa <code>-1</code> si no hubo
espacio, aunque <code>NULL</code> hubiera sido un mejor diseño. El <code>-1</code> debe
ser forzado a <code>char *</code> para que pueda ser comparado con el valor de
retorno. Nuevamente, las conversiones forzadas hacen a la funcion
relativamente inmune a los detalles de representacion de
apuntadores en maquinas diferentes. Hay, sin embargo, una
suposicion mas; que los apuntadores a bloques diferentes regresados
por <code>sbrk</code> pueden ser comparados. Esto no es garantizado por el
estandar, que solo permite la comparacion de apuntadores dentro de
un arreglo. Asi, esta version de <a href="#org292ad05"><code>malloc</code></a> es portatil solo entre
maquinas para las que la comparacion general de apuntadores es
significativa.
</p>

<p>
<a href="#org0a5a9fe"><code>free</code></a> es la ultima seccion. Recorre la lista libre, iniciando en
<code>freep</code>, buscando donde insertar el bloque libre. Esto es entre dos
bloques existentes o en uno de los extremos de la lista. En
cualquier caso, si el bloque que esta siendo liberado es adyacente
a algun vecino, los bloques adyacentes se combinan. Los unicos
problemas son mantener los apuntadores señalando a las cosas
correctas y mantener los tamaños correctos.
</p>

<div class="org-src-container">
<pre class="src src-c"><span style="color: #ff4500;">/* </span><span style="color: #ff4500;">free: coloca el bloque ap en la lista vacia </span><span style="color: #ff4500;">*/</span>
<span style="color: #98fb98;">void</span> <span style="color: #87cefa;">free</span>( <span style="color: #98fb98;">void</span> *<span style="color: #eedd82;">ap</span> ){
  <span style="color: #98fb98;">Header</span> *<span style="color: #eedd82;">bp</span>, *<span style="color: #eedd82;">p</span>;

  bp = (<span style="color: #98fb98;">Header</span> *)ap - 1;          <span style="color: #ff4500;">/* </span><span style="color: #ff4500;">apunta al encabezado de un bloque   </span><span style="color: #ff4500;">*/</span>
  <span style="color: #00ffff;">for</span>( p = freep; !(bp &gt; p &amp;&amp; bp &lt; p-&gt;s.ptr ); p = p-&gt;s.ptr )
    <span style="color: #00ffff;">if</span>( p &gt;= p-&gt;s.ptr &amp;&amp; (bp &gt; p || bp &lt; p-&gt;s.ptr) )
      <span style="color: #00ffff;">break</span>;                      <span style="color: #ff4500;">/* </span><span style="color: #ff4500;">libera bloque al inicio o al final  </span><span style="color: #ff4500;">*/</span>

  <span style="color: #00ffff;">if</span>( bp + bp-&gt;s.size == p-&gt;s.ptr ){             <span style="color: #ff4500;">/* </span><span style="color: #ff4500;">une al nbr superior    </span><span style="color: #ff4500;">*/</span>
    bp-&gt;s.size += p-&gt;s.ptr-&gt;s.size;
    bp-&gt;s.ptr = p-&gt;s.ptr-&gt;s.ptr;
  } <span style="color: #00ffff;">else</span>
    bp-&gt;s.ptr = p-&gt;s.ptr;

  <span style="color: #00ffff;">if</span>( p + p-&gt;s.size == bp ){                     <span style="color: #ff4500;">/* </span><span style="color: #ff4500;">une al nbr inferior    </span><span style="color: #ff4500;">*/</span>
    p-&gt;s.size += bp-&gt;s.size;
    p-&gt;s.ptr = bp-&gt;s.ptr;
  } <span style="color: #00ffff;">else</span>
    p-&gt;s.ptr = bp;

  freep = p;
}
</pre>
</div>

<p>
Aunque la asignacion de memoria es intrinsecamente dependiente de
la maquina, el codigo anterior ilustra como pueden ser controladas
las dependencias de la maquina y confinadas a una parte muy pequeña
del programa. El uso de <code>typedef</code> y de <code>union</code> maneja la alineacion
(suponiendo que <code>sbrk</code> proporciona un apuntador apropiado). Las
conversiones forzosas hacen que los apuntadores se manejen adecuada
y explicitamente, e incluso se acoplan a una interfaz para el
sistema mal diseñada. Aun cuando los detalles aqui estan
relacionados con la asignacion de almacenamiento, el acercamiento
general es aplicable tambien a otras situaciones.
</p>

<p>
<b>Ejercicio 8-6</b>. La funcion <code>calloc(n,size)</code> de la biblioteca
estandar regresa un apuntador a <code>n</code> objetos de tamaño <code>size</code>, con
el almacenamiento inicializado en cero. Escriba <a href="#org1970706"><code>calloc</code></a>, invocando
a <a href="#org292ad05"><code>malloc</code></a> o modificandola.
</p>

<p>
<b>Ejercicio 8-7</b>. <a href="#org292ad05"><code>malloc</code></a> acepta un tamaño solicitado sin verificar
la posibilidad de que sea valido; <a href="#org0a5a9fe"><code>free</code></a> cree que el bloque que se
pide liberar contiene un campo de tamaño correcto. Mejore esas
rutinas para que se tomen mas molestias en la revision de errores.
</p>

<p>
<b>Ejercicio 8-8</b>. Escriba una rutina <code>bfree(p,n)</code> que libere un
bloque arbitrario <code>p</code> de <code>n</code> caracteres en la lista libre mantenida
por <a href="#org292ad05"><code>malloc</code></a> y <a href="#org0a5a9fe"><code>free</code></a>. Utilizando <code>bfree</code>, un usuario puede agregar
un arreglo estatico o externo a la lista libre en cualquier
momento.
</p>
</div>
</div>
</div>

<div id="outline-container-org920e841" class="outline-2">
<h2 id="org920e841">Apendice A: Manual de referencia                                    <a id="orgea26d39"></a></h2>
<div class="outline-text-2" id="text-org920e841">
</div>
<div id="outline-container-orgca49a38" class="outline-3">
<h3 id="orgca49a38">A1   Introduccion                                                  <a id="orga35e44d"></a></h3>
<div class="outline-text-3" id="text-orgca49a38">
<p>
Este manual describe al lenguaje C tal como se especifica en /Draft
Proposed American National Standard for Information Systems -
Programming Language C/, documento numero <b>X3J11/88-001</b>, con fecha
11 de enero de 1988. Este borrador no es el estandar final, y
todavia es posible que ocurran algunos cambios en el lenguaje. Asi
pues, este manual no describe la definicion final del lenguaje. Mas
aun es una interpretacion del borrador propuesto del estandar, no
el estandar en si, aunque se ha tenido cuidado de hacerlo una guia
confiable.
</p>

<p>
En su mayor parte, este manual sigue la linea amplia del borrador
estandar, que a su vez sigue la de la primera edicion de este
libro, aunque la organizacion difiere en el detalle. Excepto por
renombrar algunas producciones y porque no se formalizan las
definiciones de los componentes lexicos o del preprocesador, la
gramatica dada aqui para el lenguaje es equivalente a la del
borrador actual.
</p>

<div class="BLOOD">
<p>
En este manual, el material comentado se encuentra sangrado y
escrito en un tipo mas pequeño, como este. A menudo estos
comentarios resaltan las formas en las que el estandar ansi de C
difiere del lenguaje definido por la primera edicion de este
libro, o de refinamientos introducidos posteriormente en varios
compiladores.
</p>

</div>
</div>
</div>

<div id="outline-container-org5c060fe" class="outline-3">
<h3 id="org5c060fe">A2   Convenciones lexicas                                          <a id="org28b4e20"></a></h3>
<div class="outline-text-3" id="text-org5c060fe">
<p>
Un programa consiste en una o mas <i>unidades de traduccion</i>
almacenadas en archivos.  Es traducido en varias fases, que se
describen en <a href="#orgc912dbd">A12</a>. Las primeras fases hacen transformaciones lexicas
de bajo nivel, ejecutan directivas introducidas con lineas que
inician con el caracter <code>#</code>, y realizan macrodefiniciones y
expansiones. Cuando el preprocesamiento (<a href="#orgc912dbd">A12</a>) esta completo, el
programa se ha reducido a una secuencia de componentes lexicos.
</p>
</div>

<div id="outline-container-org59cca1e" class="outline-4">
<h4 id="org59cca1e">A2.1 Componentes lexicos (tokens)                                 <a id="org3dd3865"></a></h4>
<div class="outline-text-4" id="text-org59cca1e">
<p>
Existen seis clases de componentes lexicos: identificadores,
palabras reservadas, constantes, cadenas literales, operadores y
otros separadores. Los espacios, tabuladores horizontales y
verticales, nueva linea, avance de forma y comentarios, como se
describen adelante (en su conjunto, llamados "espacio en blanco")
son ignorados, excepto los que separan componentes. Se requiere de
algun espacio en blanco para separar identificadores de otra
manera adyacentes, palabras reservadas y constantes.
</p>

<p>
Si el flujo de entrada se ha separado en componentes hasta un
caracter determinado, el siguiente componente es la cadena mas
larga de caracteres que puede constituir uno.
</p>
</div>
</div>

<div id="outline-container-org3b1e3bd" class="outline-4">
<h4 id="org3b1e3bd">A2.2 Comentarios                                                  <a id="orgd977627"></a></h4>
<div class="outline-text-4" id="text-org3b1e3bd">
<p>
Los caracteres <code>/*</code> inician un comentario, que termina con los
caracteres <code>*/</code>. Los comentarios no se anidan y no pueden estar
dentro de cadenas o caracteres literales.
</p>
</div>
</div>

<div id="outline-container-orga28a346" class="outline-4">
<h4 id="orga28a346">A2.3 Identificadores                                              <a id="orgcf180a0"></a></h4>
<div class="outline-text-4" id="text-orga28a346">
<p>
Un identificador es una secuencia de letras y digitos. El primer
caracter debe ser una letra; el subguion <code>_</code> cuenta como una
letra. Las letras minusculas y mayusculas son diferentes. Los
identificadores pueden tener cualquier longitud y, para
identificadores internos, al menos los primeros 31 caracteres son
significativos; algunas implantaciones pueden hacer que mas
caracteres sean significativos. Los identificadores internos
incluyen los nombres de macros del preprocesador y todos los otros
nombres que no tienen ligado externo (<a href="#orgde38dea">A11.2</a>). Los identificadores
con ligado externo estan mas restringidos: las implantaciones
pueden hacer que solo sean significativos seis caracteres y pueden
ignorar la distincion entre mayusculas y minusculas.
</p>
</div>
</div>

<div id="outline-container-orge37dbd3" class="outline-4">
<h4 id="orge37dbd3">A2.4 Palabras reservadas                                          <a id="orgafe336a"></a></h4>
<div class="outline-text-4" id="text-orge37dbd3">
<p>
Los siguientes identificadores son palabras reservadas y no se
pueden utilizar de otra manera:
</p>

<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-left" />

<col  class="org-left" />

<col  class="org-left" />

<col  class="org-left" />
</colgroup>
<tbody>
<tr>
<td class="org-left">auto</td>
<td class="org-left">double</td>
<td class="org-left">int</td>
<td class="org-left">struct</td>
</tr>

<tr>
<td class="org-left">break</td>
<td class="org-left">else</td>
<td class="org-left">long</td>
<td class="org-left">switch</td>
</tr>

<tr>
<td class="org-left">case</td>
<td class="org-left">enum</td>
<td class="org-left">register</td>
<td class="org-left">typedef</td>
</tr>

<tr>
<td class="org-left">char</td>
<td class="org-left">extern</td>
<td class="org-left">return</td>
<td class="org-left">union</td>
</tr>

<tr>
<td class="org-left">const</td>
<td class="org-left">float</td>
<td class="org-left">short</td>
<td class="org-left">unsigned</td>
</tr>

<tr>
<td class="org-left">continue</td>
<td class="org-left">for</td>
<td class="org-left">signed</td>
<td class="org-left">void</td>
</tr>

<tr>
<td class="org-left">default</td>
<td class="org-left">goto</td>
<td class="org-left">sizeof</td>
<td class="org-left">volatile</td>
</tr>

<tr>
<td class="org-left">do</td>
<td class="org-left">if</td>
<td class="org-left">static</td>
<td class="org-left">while</td>
</tr>
</tbody>
</table>

<p>
Algunas implantaciones tambien reservan las palabras <code>fortran</code> y
<code>asm</code>.
</p>

<div class="BLOOD">
<p>
Las palabras <code>const</code>, <code>signed</code> y <code>volatile</code> son nuevas en el
estandar ANSI; <code>enum</code> y <code>void</code> son nuevas desde la primera
edicion, pero en uso comun: <code>entry</code>, antes reservada pero nunca
usada, ya no esta reservada. Dependiendo de las decisiones del
comite x3j11, la palabra <code>noalias</code> tambien puede estar
reservada.
</p>

</div>
</div>
</div>

<div id="outline-container-org188f7c6" class="outline-4">
<h4 id="org188f7c6">A2.5 Constantes                                                   <a id="orgec95c5f"></a></h4>
<div class="outline-text-4" id="text-org188f7c6">
<p>
Hay varias clases de constantes. Cada una tiene un tipo de dato;
en <a href="#org7d5338b">A4.2</a> se discuten los tipos basicos.
</p>

<pre class="example">
constante:
   constante-entera
   constante-de-caracter
   constante-flotante
   constante-de-enumeracion
</pre>
</div>

<div id="outline-container-org7fc886c" class="outline-5">
<h5 id="org7fc886c">A2.5.1 Constantes enteras                                        <a id="org6215f48"></a></h5>
<div class="outline-text-5" id="text-org7fc886c">
<p>
Una constante entera que consiste en una secuencia de digitos se
toma como octal si inicia con <code>0</code> (digito cero), de otra manera
es decimal. Las constantes octales no contienen los digitos <code>8</code> o
<code>9</code>. Una secuencia de digitos precedida por <code>Ox</code> o <code>OX</code> (digito
cero) se toma como un entero hexadecimal. Los digitos
hexadecimales incluyen de <code>a</code> o <code>A</code> hasta la <code>f</code> o <code>F</code> con
valores <code>10</code> al <code>15</code>.
</p>

<p>
Una constante entera puede tener la letra <code>u</code> o <code>U</code> como sufijo,
lo cual especifica que es <code>unsigned</code>. Tambien puede tener como
sufijo la letra <code>l</code> o <code>L</code> para estipular que es <code>long</code>.
</p>

<p>
El tipo de una constante entera depende de su forma, valor y
sufijo (vease <a href="#org672e151">A4</a> para una discusion de tipos). Un decimal sin
sufijo tiene el primero de estos tipos, en el que su valor pueda
ser representado: <code>int</code>, <code>long int</code>, <code>unsigned long int</code>. Si es
octal o hexadecimal sin sufijo, tiene el primer valor posible de
estos tipos: <code>int</code>, <code>unsigned int</code>, <code>long int</code>, <code>unsigned long
     int</code>. Si tiene el sufijo <code>u</code> o <code>U</code>, entonces es <code>unsigned int</code>,
<code>unsigned long int</code>. Si tiene el sufijo <code>l</code> o <code>L</code>, entonces es
<code>long int</code>, <code>unsigned long int</code>. Si una constante entera tiene el
sufijo <code>UL</code>, entonces es <code>unsigned long</code>.
</p>

<div class="BLOOD">
<p>
La elaboracion de los tipos de constantes enteras va
considerablemente mas alla de la primera edicion, que
simplemente hacia que las grandes constantes enteras fueran
<code>long</code>. Los sufijos <code>U</code> son nuevos.
</p>

</div>
</div>
</div>

<div id="outline-container-org4c93fed" class="outline-5">
<h5 id="org4c93fed">A2.5.2 Constantes de caracter                                    <a id="org4b66d10"></a></h5>
<div class="outline-text-5" id="text-org4c93fed">
<p>
Una constante de caracter es una secuencia de uno o mas
caracteres encerrados entre apostrofos, como 'x'. El valor de una
constante de caracter con un solo caracter es el valor numerico
del caracter en el conjunto de caracteres de la maquina al tiempo
de ejecucion. El valor de una constante multicaracter esta
definido por la implantacion.
</p>

<p>
Las constantes de caracter no contienen el caracter <code>’</code> o nueva
linea; para representarlos, asi como a algunos otros caracteres,
se pueden utilizar las siguientes secuencias de escape.
</p>

<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-left" />

<col  class="org-left" />

<col  class="org-left" />
</colgroup>
<tbody>
<tr>
<td class="org-left">nueva linea</td>
<td class="org-left">NL (LF)</td>
<td class="org-left"><code>\n</code></td>
</tr>

<tr>
<td class="org-left">tab horizontal</td>
<td class="org-left">HT</td>
<td class="org-left"><code>\t</code></td>
</tr>

<tr>
<td class="org-left">tab vertical</td>
<td class="org-left">VT</td>
<td class="org-left"><code>\v</code></td>
</tr>

<tr>
<td class="org-left">retroceso</td>
<td class="org-left">BS</td>
<td class="org-left"><code>\b</code></td>
</tr>

<tr>
<td class="org-left">regreso de carro</td>
<td class="org-left">CR</td>
<td class="org-left"><code>\r</code></td>
</tr>

<tr>
<td class="org-left">avance de forma</td>
<td class="org-left">FF</td>
<td class="org-left"><code>\f</code></td>
</tr>

<tr>
<td class="org-left">señal audible</td>
<td class="org-left">BEL</td>
<td class="org-left"><code>\a</code></td>
</tr>

<tr>
<td class="org-left">diagonal inversa</td>
<td class="org-left">\</td>
<td class="org-left"><code>\\</code></td>
</tr>

<tr>
<td class="org-left">interrogacion</td>
<td class="org-left">?</td>
<td class="org-left"><code>\?</code></td>
</tr>

<tr>
<td class="org-left">apostrofo</td>
<td class="org-left">'</td>
<td class="org-left"><code>\'</code></td>
</tr>

<tr>
<td class="org-left">comillas</td>
<td class="org-left">"</td>
<td class="org-left"><code>\"</code></td>
</tr>

<tr>
<td class="org-left">numero octal</td>
<td class="org-left">ooo</td>
<td class="org-left"><code>\ooo</code></td>
</tr>

<tr>
<td class="org-left">numero hexadecimal</td>
<td class="org-left">hh</td>
<td class="org-left"><code>\xhh</code></td>
</tr>
</tbody>
</table>


<p>
El escape <code>\ooo</code> consiste en la diagonal inversa seguida por <code>1</code>,
<code>2</code> o <code>3</code> digitos octales, que estipulan el Valor del caracter
deseado. Un ejemplo comun de esta construccion es <code>\0</code> (no
seguido por un digito), que especifica el caracter <code>NUL</code>. El
escape <code>\xhh</code> consiste en la diagonal inversa seguida por <code>x</code>,
seguida por digitos hexadecimales, que estipulan el valor de
caracter deseado. No hay limite en el numero de digitos, pero el
comportamiento queda indefinido si el valor de caracter
resultante excede al del caracter mas grande. Para caracteres
octales o hexadecimales, si la implantacion trata al tipo <code>char</code>
como signed, el valor es extendido en signo como si se forzara a
ser de tipo <code>char</code>. Si el caracter que sigue a <code>\</code> no es uno de
los especificados, el comportamiento no esta definido.
</p>

<p>
En algunas implantaciones, existe un conjunto extendido de
caracteres que no se puede representar por el tipo <code>char</code>. Una
constante en este conjunto extendido se escribe con una <code>L</code>
precedente, por ejemplo L'x', y se llama una constante de
caracter amplio. Tal constante tiene tipo <code>wchar_t</code>, un tipo
entero definido en el <i>header</i> <code>&lt;stddef.h&gt;</code>. Como con las
constantes de caracter ordinarias, se pueden emplear escapes
octales o hexadecimales; el efecto esta indefinido si el valor
especificado excede al que se representa con <code>wchar_t</code>.
</p>

<p>
Algunas de estas secuencias de escape son nuevas, en particular
la represen hexadecimal de caracteres. Los caracteres extendidos
tambien son nuevos. Los juegos de caracteres comunmente usados en
America y Europa occidental se pueden codificar para quedar en el
tipo <code>char</code>; la intencion principal de agregar <code>wchar_t</code> fue
adaptarse a los lenguajes asiaticos.
</p>
</div>
</div>

<div id="outline-container-orgb13f2c0" class="outline-5">
<h5 id="orgb13f2c0">A2.5.3 Constantes flotantes                                      <a id="orga5cd7fb"></a></h5>
<div class="outline-text-5" id="text-orgb13f2c0">
<p>
Una constante flotante consta de una parte entera, un punto
decimal, una parte fraccionaria, una <code>e</code> o <code>E</code>, un exponente
entero signado optativo y un tipo sufijo optativo entre <code>f</code> o
<code>F</code>, <code>l</code> o <code>L</code>. Las partes entera y fraccionaria constan de una
secuencia de digitos. Cualquiera de las partes entera o
fraccionaria (no ambas) puede omitirse; cualquiera de las partes
del punto decimal o la <code>e</code> y el exponente (no ambas) pueden
omitirse. El tipo esta determinado por el sufijo; <code>F</code> o <code>f</code> la
hacen <code>float</code>, <code>L</code> o <code>l</code> la hacen <code>long double</code>; de otra manera
es <code>double</code>.
</p>

<div class="BLOOD">
<p>
Los sufijos en constantes flotantes son nuevos.
</p>

</div>
</div>
</div>

<div id="outline-container-org21f04a8" class="outline-5">
<h5 id="org21f04a8">A2.5.4 Constantes de enumeracion                                 <a id="orgf3837df"></a></h5>
<div class="outline-text-5" id="text-org21f04a8">
<p>
Los identificadores declarados como enumeradores (vease <a href="#org4b53932">A8.4</a>)
son constantes de tipo <code>int</code>.
</p>
</div>
</div>
</div>

<div id="outline-container-org328d2fc" class="outline-4">
<h4 id="org328d2fc">A2.6 Cadenas literales                                            <a id="org3acb960"></a></h4>
<div class="outline-text-4" id="text-org328d2fc">
<p>
Una cadena literal, tambien llamada cadena constante es una
secuencia de caracteres delimitados por comillas, como en "&#x2026;"
Una cadena tiene el tipo "arreglo de caracteres" y categoria de
almacenamiento <code>static</code> (vease <a href="#org672e151">A4</a>, abajo) y se inicializa con los
caracteres dados. El que cadenas identicas sean distintas esta
definido por la implantacion, y el comportamiento de un programa
que intenta alterar una cadena literal esta indefinido.
</p>

<p>
Cadenas literales adyacentes se concatenan en una sola cadena.
Despues de cualquier concatenacion, se agrega un byte nulo <code>\0</code> a
la cadena, de modo que los programas que rastrean la cadena puedan
encontrar el fin. Las cadenas literales no contienen caracteres
nueva linea o comillas; para representarlos, se usan las mismas
secuencias de escape que para las constantes de caracter.
</p>

<p>
Como con las constantes de caracter, las cadenas literales en un
conjunto de caracteres extendido se escriben con una <code>L</code>
precedente, como en L"&#x2026;". Las cadenas literales amplias de
caracteres tienen tipo "arreglo de wchar<sub>t</sub>". La concatenacion de
cadenas literales ordinarias y amplias esta indefinida.
</p>

<div class="BLOOD">
<p>
La especificacion de que las cadenas literales no tienen por que
ser distintas, y la prohibicion en contra de modificarlas, son
novedades dentro del estandar ANSI, asi como la concatenacion de
cadenas literales adyacentes. Las cadenas literales de
caracteres amplios son nuevas.
</p>

</div>
</div>
</div>
</div>

<div id="outline-container-org1a3b387" class="outline-3">
<h3 id="org1a3b387">A3   Notacion sintactica                                           <a id="org93e38e2"></a></h3>
<div class="outline-text-3" id="text-org1a3b387">
<p>
Dentro de la notacion sintactica que se emplea en este manual, las
categorias sintacticas se indican con estilo <i>italico</i>, y las
palabras textuales y caracteres en estilo mecanografico.  Las
categorias alternativas usualmente se listan en lineas separadas;
en algunos casos, un conjunto amplio de alternativas cortas se
presenta en una linea, marcada por la frase "uno de". Un simbolo
optativo terminal o no terminal lleva el subindice "opt", de modo
que, por ejemplo,
</p>

<div class="BLOCK">
<p>
{ expresion<sub>opt</sub> }
</p>

</div>

<p>
significa una expresion optativa, encerrada entre llaves. La
sintaxis se resume en <a href="#orgbe6bcf9">A13</a>.
</p>

<div class="BLOOD">
<p>
A diferencia de la gramatica empleada en la primera edicion de
este libro, la que aqui se da hace explicita la precedencia y
asociatividad de los operadores de expresion.
</p>

</div>
</div>
</div>

<div id="outline-container-org23b7c5e" class="outline-3">
<h3 id="org23b7c5e">A4   Significado de los identificadores                            <a id="org672e151"></a></h3>
<div class="outline-text-3" id="text-org23b7c5e">
<p>
Los identificadores, o nombres, se refieren a una variedad de
cosas: funciones; etiquetas de estructuras, uniones y
enumeraciones; miembros de estructuras o de uniones; constantes de
enumeracion; nombres <code>typedef</code> y objetos. Un objeto, algunas veces
llamado variable, es una localidad en el espacio de almacenamiento
y su interpretacion depende de dos atributos fundamentales: su
<i>categoria de almacenamiento</i> y su <i>tipo</i>. La categoria de
almacenamiento determina el tiempo de vida del almacenamiento
asociado con el objeto identificado; el tipo determina el
significado de los valores encontrados en el objeto identificado.
Un nombre tambien tiene un alcance, que es la region del programa
dentro de la que se conoce, y una liga, que determina si el mismo
nombre en otro alcance se refiere al mismo objeto o funcion. El
alcance y la liga se discuten en <a href="#org73717e3">A11</a>.
</p>
</div>

<div id="outline-container-org002922b" class="outline-4">
<h4 id="org002922b">A4.1 Categorias de almacenamiento                                 <a id="orge2fa230"></a></h4>
<div class="outline-text-4" id="text-org002922b">
<p>
Existen dos categorias de almacenamiento: automatica y estatica.
Varias palabras reservadas, junto con el contexto de la
declaracion de un objeto, especifican su categoria de
almacenamiento. Los objetos automaticos son locales a un bloque
(<a href="#org8ed9206">A9.3</a>), y son descartados al salir del bloque. Las declaraciones
dentro de un bloque crean objetos automaticos si no se menciona
una especificacion de categoria de almacenamiento, o si se emplea
el especificador <code>auto</code>. Los objetos declarados como <code>register</code>
son automaticos, y se almacenan (si es posible) en registros
rapidos de la maquina.
</p>

<p>
Los objetos estaticos pueden ser locales a un bloque o externos a
todos los bloques, pero en cualquier caso mantienen su valor entre
las salidas y reentradas a funciones o bloques. Dentro de un
bloque, incluyendo uno que proporcione el codigo de una funcion,
los objetos estaticos se declaran con la palabra reservada
<code>static</code>. Los objetos que se declaran fuera de todos los bloques,
al mismo nivel que la definicion de las funciones, son siempre
estaticos. Se pueden hacer locales a una unidad de traduccion en
particular por el uso de la palabra reservada <code>static</code>; esto les
otorga <i>liga interna</i>. Se hacen globales a un programa completo
omitiendo una categoria explicita de almacenamiento, o utilizando
la palabra reservada <code>extern</code>; esto les otorga <i>liga externa</i>.
</p>
</div>
</div>

<div id="outline-container-org71ffce2" class="outline-4">
<h4 id="org71ffce2">A4.2 Tipos basicos                                                <a id="org7d5338b"></a></h4>
<div class="outline-text-4" id="text-org71ffce2">
<p>
Existen varios tipos basicos. El <i>header</i> estandar <code>&lt;limits.h&gt;</code>
que se describe en el <a href="#org89d4232">apendice B</a> define los valores mayores y
menores de cada tipo dentro de la implantacion local.  Los numeros
dados en el <a href="#org89d4232">apendice B</a> muestran las menores magnitudes aceptables.
</p>

<p>
Los objetos declarados como caracteres (<code>char</code>) son
suficientemente grandes para almacenar cualquier miembro del
conjunto de caracteres en ejecucion. Si un caracter genuino de ese
conjunto se almacena en un objeto <code>char</code>, su valor es equivalente
al codigo entero para ese caracter, y es no negativo. Se pueden
almacenar otras cantidades en variables <code>char</code>, pero el rango de
valores disponibles, y en especial si el valor tiene signo,
depende de la implantacion.
</p>

<p>
Los caracteres sin signo declarados <code>unsigned char</code> consumen la
misma cantidad de espacio que los caracteres sencillos, pero
siempre aparecen como no negativos; los caracteres explicitamente
signados que se declaran <code>signed char</code> toman igualmente el mismo
espacio que los caracteres sencillos.
</p>

<div class="BLOOD">
<p>
<code>unsigned char</code> no aparece en la primera edicion de este libro,
pero es de uso comun. <code>signed char</code> es nuevo.
</p>

</div>

<p>
Ademas de los tipos <code>char</code>, hay tres tamaños de enteros,
declarados como <code>short int</code>, <code>int</code>, y <code>long int</code>. Los objetos
<code>int</code> simples tienen el tamaño natural sugerido por la
arquitectura de la maquina donde se ejecuta; los otros tamaños se
proporcionan para cumplir con necesidades especiales. Los enteros
mas grandes proporcionan por lo menos tanto almacenamiento como
los menores, pero la implantacion puede hacer a los enteros
simples equivalentes a los enteros cortos, o a los enteros
largos. Todos los tipos <code>int</code> representan valores con signo a
menos que se especifique lo contrario.
</p>

<p>
Los enteros sin signo, declarados mediante la palabra reservada
<code>unsigned</code>, obedecen a las leyes de la aritmetica modulo 2, donde
<code>n</code> es el numero de bits en la representacion, por lo que la
aritmetica sobre cantidades signadas nunca puede desbordarse. El
conjunto de valores no negativos que se pueden almacenar en
objetos con signo es un subconjunto de los que se pueden almacenar
en el correspondiente objeto sin signo, y la representacion para
los valores en comun es la misma.
</p>

<p>
Cualquiera de los tipos punto flotante de precision sencilla
(<code>float</code>), punto flotante de precision doble (<code>double</code>) y punto
flotante de precision extra (<code>long double</code>) puede ser sinonimo,
pero los ultimos en la lista son al menos tan precisos como los
que los anteceden.
</p>

<div class="BLOOD">
<p>
<code>long double</code> es nuevo. La primera edicion hizo a <code>long float</code>
equivalente a <code>double</code>; esto se ha rechazado.
</p>

</div>

<p>
Las <i>enumeraciones</i> son tipos unicos que tienen valores enteros;
asociado con cada enumeracion hay un conjunto de constantes
nombradas (<a href="#org4b53932">A8.4</a>). Las enumeraciones se comportan como enteros,
pero es comun que un compilador de una advertencia cuando un
objeto de un tipo de enumeracion en particular se asigna a algo
que no sea una de sus constantes o una expresion de su tipo.
</p>

<p>
Debido a que los objetos de estos tipos se pueden interpretar como
numeros, se hara referencia a ellos como tipos aritmeticos. Los
tipos <code>char</code> e <code>int</code> de todos los tamaños, cada uno con o sin
signo, y tambien los tipos de enumeracion, se llamaran
conjuntamente tipos enteros. Los tipos <code>float</code>, <code>double</code> y <code>long
    double</code> se llamaran tipos flotantes.
</p>

<p>
El tipo <code>void</code> especifica un conjunto vacio de valores. Se usa
como el tipo regresado por funciones que no generan un valor.
</p>
</div>
</div>

<div id="outline-container-org11ec79a" class="outline-4">
<h4 id="org11ec79a">A4.3 Tipos derivados                                              <a id="org47e57bd"></a></h4>
<div class="outline-text-4" id="text-org11ec79a">
<p>
Ademas de los tipos basicos, existe una categoria conceptualmente
infinita de tipos derivados, construidos a partir de los tipos
fundamentales en las formas siguientes:
</p>

<ul class="org-ul">
<li><i>arreglos</i> de objetos de un tipo dado;</li>

<li><i>funciones</i> que regresan objetos de un tipo dado;</li>

<li><i>apuntadores</i> a objetos de un tipo dado;</li>

<li><i>estructuras</i> que contienen una secuencia de objetos de varios
tipos;</li>

<li><i>uniones</i> capaces de contener un objeto cualquiera de varios
tipos.</li>
</ul>


<p>
En general, estos metodos de construccion de objetos se pueden
aplicar en forma recursiva.
</p>
</div>
</div>

<div id="outline-container-org76c1877" class="outline-4">
<h4 id="org76c1877">A4.4 Calificadores de tipo                                        <a id="org7ac3702"></a></h4>
<div class="outline-text-4" id="text-org76c1877">
<p>
Un tipo de objeto puede tener calificadores adicionales. El
declarar <code>const</code> a un objeto anuncia que su valor no cambiara;
declararlo <code>volatile</code> anuncia que tiene propiedades especiales de
importancia para la optimizacion. Ningun calificador afecta el
rango de valores o propiedades aritmeticas del objeto. Los
calificadores se discuten en <a href="#org963fdbc">A8.2</a>.
</p>
</div>
</div>
</div>

<div id="outline-container-org99c6e1e" class="outline-3">
<h3 id="org99c6e1e">A5   Objetos y valores-l                                           <a id="org64e68bf"></a></h3>
<div class="outline-text-3" id="text-org99c6e1e">
<p>
Un objeto es una region de almacenamiento con nombre; un <i>valor-l</i>
es una expresion que se refiere a un objeto. Un ejemplo obvio de
una expresion valor-l es un identificador con un tipo adecuado y
una categoria de almacenamiento. Existen operadores que producen
valores-l: por ejemplo, si <code>E</code> es una expresion de tipo apuntador,
entonces <code>*E</code> es una expresion valor-1 que se refiere al objeto al
cual apunta E. El nombre "valor-l" proviene de la expresion de
asignacion <code>E1 = E2</code> en la que el operador izquierdo <code>E1</code> debe ser
una expresion valor-l. La discusion de cada operador especifica si
espera operandos valor-l y si entrega un valor-l.
</p>
</div>
</div>

<div id="outline-container-org9c390c4" class="outline-3">
<h3 id="org9c390c4">A6   Conversiones                                                  <a id="orgb740b71"></a></h3>
<div class="outline-text-3" id="text-org9c390c4">
<p>
Algunos operadores pueden, dependiendo de sus operandos, provocar
la conversion del valor de un operando de un tipo a otro. Esta
seccion explica el resultado que se espera de tales conversiones.
<a href="#orga718883">A6.5</a> resume las conversiones demandadas por la mayoria de los
operadores ordinarios; en donde se requiera, sera complementada con
la discusion de cada operador.
</p>
</div>

<div id="outline-container-org25b811b" class="outline-4">
<h4 id="org25b811b">A6.1 Promocion entera                                             <a id="org68f9d95"></a></h4>
<div class="outline-text-4" id="text-org25b811b">
<p>
Un caracter, un entero corto o un campo entero de bits, todos con
o sin signo, o un objeto de tipo enumeracion, se puede utilizar
dentro de una expresion en cualquier lugar en donde se pueda usar
un entero. Si un <code>int</code> puede representar a todos los valores del
tipo original, entonces el valor es convertido a <code>int</code>; de otra
manera el valor es convertido a <code>unsigned int</code>. Este proceso se
llama <i>promocion entera</i>.
</p>
</div>
</div>

<div id="outline-container-org3a3fed1" class="outline-4">
<h4 id="org3a3fed1">A6.2 Conversiones enteras                                         <a id="org6524680"></a></h4>
<div class="outline-text-4" id="text-org3a3fed1">
<p>
Un entero se convierte a un tipo sin signo dado encontrando el
menor valor no negativo que sea congruente con ese entero, modulo
uno mas que el mayor valor que se pueda representar en el tipo sin
signo. En una representacion complemento a dos, esto es
equivalente al truncamiento por la izquierda si el patron de bits
del tipo sin signo es mas estrecho, y al llenado con ceros de
valores sin signo y extension de signo en valores con signo si el
tipo sin signo es mas amplio.
</p>

<p>
Cuando cualquier entero se convierte a un tipo con signo, el valor
no se cambia si puede ser representado en el nuevo tipo, y en otro
caso esta definido por la implantacion.
</p>
</div>
</div>

<div id="outline-container-org9d7ba49" class="outline-4">
<h4 id="org9d7ba49">A6.3 Entero y flotante                                            <a id="org5e3e87d"></a></h4>
<div class="outline-text-4" id="text-org9d7ba49">
<p>
Cuando un valor de tipo flotante se convierte a un tipo entero, la
parte fraccionaria se descarta; si el valor resultante no puede
ser representado en el tipo entero, el comportamiento no esta
definido. En particular, el resultado de convertir valores
flotantes negativos a tipos enteros sin signo no esta
especificado.
</p>

<p>
Cuando un valor de tipo entero se convierte a flotante, y el valor
esta en el rango representable pero no es exactamente
representable, entonces el resultado puede ser el valor siguiente
mas alto o mas bajo. Si el resultado esta fuera de rango, el
comportamiento esta indefinido.
</p>
</div>
</div>

<div id="outline-container-org209debe" class="outline-4">
<h4 id="org209debe">A6.4 Tipos flotantes                                              <a id="org936126e"></a></h4>
<div class="outline-text-4" id="text-org209debe">
<p>
Cuando un valor flotante menos preciso se convierte a un tipo
flotante igual o mas preciso, el valor no se modifica. Cuando un
valor flotante mas preciso se convierte a un tipo flotante menos
preciso, y el valor esta dentro del rango representable, el
resultado puede ser el siguiente valor representable mas alto o el
siguiente mas bajo. Si el resultado esta fuera de rango, el
comportamiento esta indefinido.
</p>
</div>
</div>

<div id="outline-container-org2ef95c1" class="outline-4">
<h4 id="org2ef95c1">A6.5 Conversiones aritmeticas                                     <a id="orga718883"></a></h4>
<div class="outline-text-4" id="text-org2ef95c1">
<p>
Muchos operadores provocan una conversion y producen tipos
resultantes en forma semejante. El efecto es pasar los operandos a
un tipo comun, que es tambien el tipo del resultado. A este patron
se le llama conversiones aritmeticas usuales.
</p>

<ul class="org-ul">
<li>Primero, si cualquier operando es un <code>long double</code>, el otro es
convertido a <code>long double</code>.</li>

<li>De otra manera, si cualquier operando es <code>double</code>, el otro es
convertido a <code>double</code>.</li>

<li>De otra manera, si cualquier operando es <code>float</code>, el otro es
convertido a <code>float</code>.</li>

<li>De otra manera, se realiza promocion entera en ambos operandos;
despues, si cualquier operando es <code>unsigned long int</code>, el otro
es convertido a <code>unsigned long int</code>.</li>

<li>De otra manera, si un operando es <code>long int</code> y el otro es
<code>unsigned int</code>, el efecto depende de si un <code>long int</code> puede
representar a todos los valores de un <code>unsigned int</code>; si es asi,
el operando <code>unsigned int</code> es convertido a <code>long int</code>; si no lo
es, ambos son convertidos a <code>unsigned long int</code>.</li>

<li>De otra manera, si un operando es <code>long int</code>, el otro es
convertido a <code>long int</code>.</li>

<li>De otra manera, si cualquier operando es <code>unsigned int</code>, el
otro es convertido a <code>unsigned int</code>.</li>

<li>De otra manera, ambos operandos tienen tipo <code>int</code>.</li>
</ul>


<div class="BLOOD">
<p>
Aqui hay dos cambios. Primero, la aritmetica sobre operandos
<code>float</code> se puede realizar en precision sencilla, en lugar de
doble; la primera edicion especificaba que toda la aritmetica
flotante era de doble precision. Segundo, los tipos sin signo
mas pequeños, cuando se combinan con un tipo con signo mayor, no
propagan la propiedad de no signado al tipo resultante; en la
primera edicion, siempre dominaba lo no signado. Las nuevas
reglas son ligeramente mas complicadas, pero de alguna forma
reducen las sorpresas que pueden ocurrir cuando una cantidad sin
signo encuentra a otra con signo. Aun pueden ocurrir resultados
inesperados cuando una expresion sin signo es comparada con una
expresion con signo del mismo tamaño.
</p>

</div>
</div>
</div>

<div id="outline-container-org99a94be" class="outline-4">
<h4 id="org99a94be">A6.6 Apuntadores y enteros                                        <a id="orga91bc61"></a></h4>
<div class="outline-text-4" id="text-org99a94be">
<p>
Una expresion de tipo entero puede ser sumada o restada de un
apuntador; en tal caso, la expresion entera es convenida tal como
se especifica en la discusion del operador de adicion (<a href="#org3e54edb">A7.7</a>).
</p>

<p>
Dos apuntadores a objetos del mismo tipo, dentro del mismo
arreglo, pueden ser restados; el resultado es convertido a un
entero como se especifica en la discusion del operador de
sustraccion (<a href="#org3e54edb">A7.7</a>).
</p>

<p>
Una expresion entera constante con valor <code>0</code>, o esa expresion
forzada al tipo <code>void *</code>, puede ser convertida, por medio de un
<i>cast</i>, por asignacion, o por comparacion, a un apuntador de
cualquier tipo. Esto produce un apuntador nulo que es igual a otro
apuntador nulo del mismo tipo, pero diferente a cualquier
apuntador a una funcion u objeto.
</p>

<p>
Se permiten otras ciertas conversiones que involucran apuntadores,
pero tienen aspectos dependientes de la implantacion. Se deben
especificar con un operador explicito de conversion de tipo o cast
(<a href="#orge7874e6">A7.5</a> y <a href="#orgfab544e">A8.8</a> ).
</p>

<p>
Un apuntador se puede convertir a un tipo entero suficientemente
grande para mantenerlo; el tamaño requerido depende de la
implantacion. La funcion de mapeo tambien depende de la
implantacion.
</p>

<p>
Un objeto de tipo entero se puede explicitamente convertir a un
apuntador. El mapeo siempre lleva un entero suficientemente amplio
convertido de un apuntador de regreso al mismo apuntador, pero de
otra manera es dependiente de la implantacion.
</p>

<p>
Un apuntador de un tipo se puede convertir a un apuntador a otro
tipo. El apuntador resultante puede causar errores de
direccionamiento si no se refiere a un objeto adecuadamente
alineado en la memoria. Se garantiza que un apuntador a un objeto
se puede convertir a un apuntador a un objeto cuyo tipo requiere
de una menor o igualmente estricta alineacion en el almacenamiento
y regresado de nuevo sin cambio; la nocion de "alineacion" es
dependiente de la implantacion, pero los objetos de tipo <code>char</code>
tienen los requisitos de alineacion menos estrictos. Como se
describe en <a href="#orgc8031ca">A6.8</a>, un apuntador se puede convertir a tipo <code>void *</code>
y regresado de nuevo sin cambio.
</p>

<p>
Finalmente, un apuntador a una funcion se puede convertir a un
apuntador a otro tipo de funcion. La llamada a la funcion
especificada por el apuntador convertido es dependiente de la
implantacion; sin embargo, si el apuntador convertido es
reconvertido a su tipo original, el resultado es identico al
apuntador original.
</p>
</div>
</div>

<div id="outline-container-orgc716a8f" class="outline-4">
<h4 id="orgc716a8f">A6.7 Void                                                         <a id="orgdaab482"></a></h4>
<div class="outline-text-4" id="text-orgc716a8f">
<p>
El (inexistente) valor de un objeto <code>void</code> no se puede utilizar en
ninguna forma, ni se puede aplicar la conversion explicita o
implicita a ningun tipo no <code>void</code>. Debido a que la expresion
<code>void</code> denota un valor inexistente, solo se puede utilizar donde
no sea requerido el valor, por ejemplo, una proposicion de
expresion (<a href="#org85bdff4">A9.2</a>) o el operando izquierdo de un operador coma
(<a href="#org523ac57">A7.18</a>).
</p>

<p>
Una expresion se puede convertir a tipo <code>void</code> con un <i>cast</i>. Por
ejemplo, una conversion forzada a <code>void</code> deja documentado el
rechazo del valor de una llamada a funcion utilizada como
proposicion de expresion.
</p>

<div class="BLOOD">
<p>
<code>void</code> no aparecia en la primera edicion de este libro, pero se
ha vuelto comu desde entonces.
</p>

</div>
</div>
</div>

<div id="outline-container-org9e9092f" class="outline-4">
<h4 id="org9e9092f">A6.8 Apuntadores a void                                           <a id="orgc8031ca"></a></h4>
<div class="outline-text-4" id="text-org9e9092f">
<p>
Cualquier apuntador se puede convertir a tipo <code>void *</code> sin perdida
de informacion. Si el resultado se regresa al tipo de apuntador
original, este es recuperado. A diferencia de la conversion
apumador-a-apuntador discutida en <a href="#orga91bc61">A6.6</a>, que requiere un cast
explicito, los apuntadores pueden ser asignados hacia y desde
apuntadores de tipo <code>void *</code> y pueden ser comparados con ellos.
</p>

<div class="BLOOD">
<p>
Esta interpretacion de apuntadores <code>void *</code> es nueva;
anteriormente, los apuntadores <code>char *</code> jugaban el papel de
apuntadores genericos. El estandar ANSI especificamente
consiente el encuentro de apuntadores <code>void *</code> con apuntadores a
objetos en asignaciones y relaciones, mientras que requiere
<i>cast</i> explicitos para mezclas de apuntadores.
</p>

</div>
</div>
</div>
</div>

<div id="outline-container-org0ee3589" class="outline-3">
<h3 id="org0ee3589">A7   Expresiones                                                   <a id="org3340e38"></a></h3>
<div class="outline-text-3" id="text-org0ee3589">
<p>
La precedencia de los operadores en expresiones es la misma que el
orden de las subsecciones principales de esta seccion, primero la
mas alta precedencia. Asi, por ejemplo, las expresiones a las que
se hace referencia como operandos de <code>+</code> (<a href="#org3e54edb">A7.7</a>) son las definidas
en <a href="#orgd8413a7">A7.1</a>-<a href="#orgc233c52">A7.6</a>. Dentro de cada subseccion, los operadores tienen la
misma precedencia. En cada subseccion se especifica la
asociatividad por la izquierda o la derecha para los operadores
discutidos alli. La gramatica incorpora la precedencia y
asociatividad de los operadores de la expresion y se resume en <a href="#orgbe6bcf9">A13</a>.
</p>

<p>
La precedencia y asociatividad de los operadores esta especificada
completamente, pero el orden de evaluacion de las expresiones esta,
con ciertas excepciones, indefinido, aun si las subexpresiones
involucran efectos colaterales. Esto es, a menos que la definicion
de un operador garantice que sus operandos se evaluen en un orden
particular, la implantacion esta en libertad de evaluar los
operandos en cualquier orden, o incluso intercalar su
evaluacion. Sin embargo, cada operador combina los valores
producidos por sus operandos en una forma compatible con el
analisis gramatical de la expresion en que aparece.
</p>

<div class="BLOOD">
<p>
El comite ANSI decidio, ultimamente en sus reportes, restringir
la anterior libertad de reordenar las expresiones que involucran
operadores matematicamente conmutativos y asociativos, pero que
pueden no ser asociativos computacionalmente. En la practica, el
cambio solo afecta a los calculos de punto flotante cercanos a
los limites de su precision y en situaciones en donde es posible
el desbordamiento.
</p>

</div>

<p>
El manejo del desbordamiento, errores de division y otras
condiciones de error dentro de la evaluacion de expresiones no esta
definido por el lenguaje. La mayoria de las realizaciones
existentes de C ignoran el desbordamiento en la evaluacion de
expresiones y asignaciones enteras con signo, pero este
comportamiento no esta garantizado. El trato de la division entre
<code>0</code>, y todas las condiciones de error de punto flotante, varia
entre las implantaciones; algunas veces es ajustable mediante el
uso de funciones no estandar de biblioteca.
</p>
</div>

<div id="outline-container-org523e5e7" class="outline-4">
<h4 id="org523e5e7">A7.1 Generacion de apuntadores                                    <a id="orgd8413a7"></a></h4>
<div class="outline-text-4" id="text-org523e5e7">
<p>
Si el tipo de una expresion o subexpresion es un "arreglo de T",
para algun tipo T, entonces el valor de la expresion es un
apuntador al primer objeto del arreglo, y el tipo de la expresion
es alterado a "apuntador a T". Esta conversion no sucede si la
expresion es el operando de un operador <code>&amp;</code> unario, o de <code>++</code>,
<code>--</code>, <code>sizeof</code> o el operando izquierdo de un operador de
asignacion o el operador <code>.</code>. De modo semejante, una expresion de
tipo "funcion que regresa T", excepto cuando se utiliza como el
operando del operador <code>&amp;</code>, es convertida a "apuntador a funcion
que regresa T". Una expresion que ha sufrido una de estas
conversiones no es valor-l.
</p>
</div>
</div>

<div id="outline-container-orgc5bdccb" class="outline-4">
<h4 id="orgc5bdccb">A7.2 Expresiones primarias                                        <a id="org5501b88"></a></h4>
<div class="outline-text-4" id="text-orgc5bdccb">
<p>
Las expresiones primarias son identificadores, constantes,
cadenas, o expresiones entre parentesis.
</p>

<pre class="example">
expresion primaria:
  identificador
  constante
  cadena
  (expresion)
</pre>

<p>
Un identificador es una expresion primaria, siempre que haya sido
declarado adecuadamente tal como se discutio anteriormente. Su
tipo esta especificado por su declaracion. Un identificador es un
valor-l si se refiere a un objeto (<a href="#org64e68bf">A5</a>) y si su tipo es
aritmetico, estructura, union o apuntador.
</p>

<p>
Una constante es una expresion primaria. Su tipo depende de su
forma, tal como se discutio en <a href="#orgec95c5f">A2.5</a>.
</p>

<p>
Una cadena es una expresion primaria. Su tipo es originalmente
"arreglo de <code>char</code>" (para cadenas de caracteres amplios, "arreglo
de <code>wchar_t</code>"), pero siguiendo la regla dada en <a href="#orgd8413a7">A7.1</a>, usualmente
se modifica a "apuntador a <code>char</code>" (<code>wchar_t</code>) y el resultado es
un apuntador al primer caracter de la cadena. La conversion
tampoco ocurre en ciertos inicializadores; vease <a href="#orgbe0450e">A8.7</a>.
</p>

<p>
Una expresion entre parentesis es una expresion primaria cuyo tipo
y valor son identicos a los de una expresion que no lo este. La
presencia de parentesis no afecta el que la expresion sea un
valor-l.
</p>
</div>
</div>

<div id="outline-container-orgd0cc058" class="outline-4">
<h4 id="orgd0cc058">A7.3 Expresiones posfijas                                         <a id="orgc9464ec"></a></h4>
<div class="outline-text-4" id="text-orgd0cc058">
<p>
Los operadores de expresiones posfijas se agrupan de izquierda a
derecha.
</p>

<div class="BLOCK">
<p>
expresion-posfija:
  expresion-primaria
  expresion-posfija[expresion]
  expresion-posfija(lista-de-expresiones-argumento<sub>opt</sub>)
  expresion-posfija.identificador
  expresion-posfija-&gt;identificador
  expresion-posfija++
  expresion-posfija&#x2013;
</p>

<p>
lista-expresiones-argumento:
  expresion-de-asignacion
  lista-expresiones-argumento , expresion-de-asignacion
</p>

</div>
</div>

<div id="outline-container-orgac7249f" class="outline-5">
<h5 id="orgac7249f">A7.3.1 Referencias a arreglos                                    <a id="orgea0ffe8"></a></h5>
<div class="outline-text-5" id="text-orgac7249f">
<p>
Una expresion posfija seguida por una expresion dentro de
corchetes es una expresion posfija que denota una referencia
indexada a un arreglo. Una de las dos expresiones debe tener tipo
"apuntador a T"’, donde T es algun tipo, y la otra debe tener
tipo entero; el tipo de la expresion subindice es T. La expresion
<code>E1[E2]</code> es identica (por definicion) a <code>*((E1) + (E2))</code>. Vease
<a href="#org5559ce9">A8.6.2</a> para una discusion adicional.
</p>
</div>
</div>

<div id="outline-container-org25f0da6" class="outline-5">
<h5 id="org25f0da6">A7.3.2 Llamadas a funciones                                      <a id="org2308e57"></a></h5>
<div class="outline-text-5" id="text-org25f0da6">
<p>
Una llamada a funcion es una expresion posfija, conocida como
designador de funcion, seguido de parentesis que contienen una
lista posiblemente vacia de expresiones de asignacion separadas
por comas (<a href="#org985740a">A7.17</a>), que constituyen los argumentos de la
funcion. Si la expresion posfija consiste en un identificador
para el que no existe una declaracion dentro del alcance actual,
el identificador es explicitamente declarado como si la
declaracion
</p>

<div class="org-src-container">
<pre class="src src-c"><span style="color: #00ffff;">extern</span> <span style="color: #98fb98;">int</span> <span style="color: #87cefa;">identificador</span>();
</pre>
</div>

<p>
hubiese sido dada en el bloque mas interno que contenga la
llamada a la funcion. La expresion posfija (despues de una
posible declaracion implicita y generacion de apuntador, <a href="#orgd8413a7">A7.1</a>)
debe ser del tipo "apuntador a funcion que regresa T." para algun
tipo de T, y el valor de la llamada a la funcion tiene el tipo T.
</p>

<div class="BLOOD">
<p>
En la primera edicion, el tipo estaba restringido a "funcion" y
se requeria de un operador <code>*</code> explicito para invocar a traves
de apuntadores a funciones. El estandar ANSI esta de acuerdo
con algunos compiladores existentes permitiendo la misma
sintaxis para llamadas a funciones y a funciones especificadas
por apuntadores. La sintaxis anterior aun se puede utilizar.
</p>

</div>

<p>
El termino <i>argumento</i> se utiliza para una expresion pasada por
una llamada a funcion; el termino <i>parametro</i> se emplea para un
objeto de entrada (o su identificador) recibido por una
definicion de funcion o descrito dentro de la declaracion de una
funcion. Los terminos "argumento (parametro real)" y "argumento
(parametro) formal" respectivamente, se usan algunas veces para
hacer la misma distincion.
</p>

<p>
En preparacion para la llamada a una funcion, se hace una copia
de cada argumento; todo el paso de argumentos es estrictamente
por valor. Una funcion puede cambiar los valores de sus objetos
parametros, que son copias de las expresiones argumentos, pero
estos cambios no pueden afectar los valores de los argumentos.
Sin embargo, es posible pasar un apuntador en el entendimiento de
que la funcion puede cambiar el valor del objeto al que apunta el
apuntador.
</p>

<p>
Existen dos estilos en los que se pueden declarar las funciones.
En el nuevo estilo, los tipos de los parametros son explicitos y
son parte del tipo de la funcion; tal declaracion se llama
tambien el prototipo de la funcion. En el estilo anterior, los
tipos de los parametros no se especifican. La declaracion de una
funcion se trata en <a href="#org0d15d1b">A8.6.3</a> y <a href="#orgd45046b">A10.1</a>.
</p>

<p>
Si la declaracion de funcion dentro del alcance de una llamada
esta en el estilo anterior, entonces la promocion de argumentos
predefinida se aplica en cada argumento como sigue: la promocion
entera (<a href="#org68f9d95">A6.1</a>) se realiza en cada argumento de tipo entero, y
cada argumento <code>float</code> es convertido a <code>double</code>. El efecto de la
llamada queda indefinido si el numero de argumentos no coincide
con el numero de parametros de la definicion de la funcion, o si
el tipo de un argumento despues de la promocion no coincide con
el del parametro correspondiente. La coincidencia de tipos
depende de si la definicion de la funcion esta en el nuevo o el
viejo estilo. Si esta en el anterior, entonces la comparacion es
entre el tipo promovido del argumento de la llamada y el tipo
promovido del parametro; si la definicion esta en el estilo
nuevo, el tipo promovido del argumento debe ser el del parametro
en si, sin promocion.
</p>

<p>
Si la declaracion de la funcion en el alcance de una llamada esta
en estilo nuevo, entonces los argumentos se convierten, como por
asignacion, a los tipos de los parametros correspondientes del
prototipo de la funcion. El numero de argumentos debe ser el
mismo que el numero de parametros explicitamente declarados, a
menos de que la lista de parametros de la declaracion termine con
la notacion de coma y tres puntos (, &#x2026;). En ese caso, el numero
de argumentos debe igualar o exceder al numero de parametros; los
argumentos mas alla de los parametros con tipo explicitamente
declarado sufren la promocion predefinida de argumentos descrita
en el parrafo precedente. Si la definicion de la funcion esta en
el estilo anterior, entonces el tipo de cada parametro dentro del
prototipo visible a la llamada debe coincidir con los parametros
correspondientes de la definicion, despues de que al tipo de
parametro de la definicion se le ha hecho la promocion de
argumentos.
</p>

<div class="BLOOD">
<p>
Estas reglas son especialmente complicadas debido a que deben
satisfacer una mezcla de funciones en el nuevo y viejo
estilos. Las mezclas se deben evitar si es posible.
</p>

</div>

<p>
El orden de evaluacion de los argumentos no esta especificado;
notese que los compiladores difieren. Sin embargo, los argumentos
y los designadores de funcion son completamente evaluados,
incluyendo todos los efectos colaterales, antes de que se entre a
la funcion. Se Permiten las llamadas recursivas a cualquier
funcion.
</p>
</div>
</div>

<div id="outline-container-org16545c5" class="outline-5">
<h5 id="org16545c5">A7.3.3 Referencias a estructuras                                 <a id="org18dc54b"></a></h5>
<div class="outline-text-5" id="text-org16545c5">
<p>
Una expresion posfija seguida por un punto seguido de un
identificador es una expresion posfija. El primer operando de la
expresion debe ser una estructura o una union, y el identificador
debe nombrar a un miembro de la estructura o union. El valor es
el miembro nombrado de la estructura o union y su tipo es el tipo
del miembro. La expresion es un valor-l si la primera expresion
es un valor-l, y si el tipo de la segunda expresion no es un tipo
arreglo.
</p>

<p>
Una expresion posfija seguida por una flecha (construida con <code>-</code>
y <code>&gt;</code>) seguida por un identificador es una expresion posfija. El
primer operando en la expresion debe ser un apuntador a una
estructura o una union y el identificador debe nombrar a un
miembro de la estructura o union. El resultado se refiere al
miembro nombrado de la estructura o union al cual apunta el
apuntador de la expresion, y el tipo es el tipo del miembro; el
resultado es un valor-l si el tipo no es arreglo.
</p>

<p>
Asi la expresion <code>E1-&gt;MOS</code> es lo mismo que <code>(*E1).MOS</code>. Las
estructuras y uniones se discuten en <a href="#org8d2fe4a">A8.3</a>.
</p>

<div class="BLOOD">
<p>
En la primera edicion de este libro ya estaba la regla de que
un nombre de miembro en una expresion asi tenia que pertenecer
a la estructura o union mencionada en la expresion posfija; sin
embargo, una nota admitia que esta regla no se seguia
firmemente. Los compiladores recientes y el ANSI la siguen.
</p>

</div>
</div>
</div>

<div id="outline-container-orga0127a8" class="outline-5">
<h5 id="orga0127a8">A7.3.4 Incrementos posfijos                                      <a id="org99cc0d1"></a></h5>
<div class="outline-text-5" id="text-orga0127a8">
<p>
Una expresion posfija seguida de un operador <code>++</code> o <code>--</code> es una
expresion posfija.  El valor de la expresion es el valor del
operando. Despues de usar el valor, se incrementa el
operando(<code>++</code>) o se decrementa (<code>--</code>) en <code>1</code>. El operando debe
ser un valor-1; vease las discusion de operadores aditivos (<a href="#org3e54edb">A7.7</a>)
y de asignacion (<a href="#org985740a">A7.17</a>) para posteriores restricciones en el
operando y detalles de la operacion. El resultado no es un
valor-l.
</p>
</div>
</div>
</div>

<div id="outline-container-orgf0ae25f" class="outline-4">
<h4 id="orgf0ae25f">A7.4 Operadores unarios                                           <a id="org6044c97"></a></h4>
<div class="outline-text-4" id="text-orgf0ae25f">
<p>
Las expresiones con operadores unarios se agrupan de derecha a
izquierda.
</p>

<pre class="example">
expresion-unaria:
  expresion-posfija
  ++expresion-unaria
  --expresion-unaria
  operador-unario expresion-cast
  sizeof expresion-unaria
  sizeof (nombre-de-tipo)

operador-unario: uno de
  &amp; * + - ~ !
</pre>
</div>

<div id="outline-container-org6a7a7fe" class="outline-5">
<h5 id="org6a7a7fe">A7.4.1 Operadores prefijos de incremento                         <a id="orgf1ce8e6"></a></h5>
<div class="outline-text-5" id="text-org6a7a7fe">
<p>
Una expresion unaria precedida por un operador <code>++</code> o <code>--</code> es una
expresion unaria.  El operando se incrementa (<code>++</code>) o decrementa
(<code>--</code>) en <code>1</code>. El valor de la expresion es el valor despues del
incremento (decremento). El operando debe ser un valor-l; vease
la discusion de operadores aditivos (<a href="#org3e54edb">A7.7</a>) y de asignacion
(<a href="#org985740a">A7.17</a>) para posteriores restricciones en el operando y detalles
de la operacion. El resultado no es un valor-l.
</p>
</div>
</div>

<div id="outline-container-orgb0f6155" class="outline-5">
<h5 id="orgb0f6155">A7.4.2 Operador de dreccion                                      <a id="org771ee27"></a></h5>
<div class="outline-text-5" id="text-orgb0f6155">
<p>
El operador unario <code>&amp;</code> toma la direccion de su operando. El
operando debe ser el valor-l que no se refiera a un campo de bits
ni a un objeto declarado como <code>register</code>, o debe ser de tipo
funcion. El resultado es un apuntador al objeto o funcion al que
se refiere el valor-l. Si el tipo del operando es T, el tipo del
resultado es "apuntador a T".
</p>
</div>
</div>

<div id="outline-container-org11490be" class="outline-5">
<h5 id="org11490be">A7.4.3 Operador de irtfireccion                                  <a id="orge2a2ea3"></a></h5>
<div class="outline-text-5" id="text-org11490be">
<p>
El operador unario <code>*</code> denota indireccion y regresa el objeto o
funcion a que apunta su operando. Es un valor-l si el operando es
un apuntador a un objeto de tipo aritmetico, estructura, union o
apunador. Si el tipo de la expresion es un "apuntador a T" el
tipo del resultado es T.
</p>
</div>
</div>

<div id="outline-container-orgccc7ffd" class="outline-5">
<h5 id="orgccc7ffd">A7.4.4 Operador mas unario                                       <a id="org04b93c0"></a></h5>
<div class="outline-text-5" id="text-orgccc7ffd">
<p>
El operando del operador unario <code>+</code> debe tener tipo aritmetico o
apuntador y el resultado es el valor del operando. Un operando
entero sufre promocion entera. EL tipo del resultado es el tipo
del operando promovido.
</p>

<div class="BLOOD">
<p>
El <code>+</code> unario es nuevo en el estandar ANSI. Se agrego por
simetria con el <code>-</code> unario.
</p>

</div>
</div>
</div>

<div id="outline-container-org0c42656" class="outline-5">
<h5 id="org0c42656">A7.4.5 Operador menos unario                                     <a id="org448e4f0"></a></h5>
<div class="outline-text-5" id="text-org0c42656">
<p>
El operador del <code>-</code> unario debe tener tipo aritmetico y el
resultado es el negativo de su operando. Un operando entero sufre
promocion entera. El negativo de una cantidad sin signo se
calcula restando el valor promovido del mayor valor del tipo
promovido y agregandole uno; pero el cero negativo es cero. El
tipo del resultado es el tipo del operando promovido.
</p>
</div>
</div>

<div id="outline-container-org3962a6d" class="outline-5">
<h5 id="org3962a6d">A7.4.6 Operador compemento a uno                                 <a id="org734caac"></a></h5>
<div class="outline-text-5" id="text-org3962a6d">
<p>
El operando del operador unario <code>~</code> debe tener tipo entero y el
resultado es el complemento a uno de su operando. Se realiza
promocion entera. Si el operando es sin signo, el resultado se
calcula restando el valor del mayor valor del tipo promovido. Si
el operando es con signo, el resultado se calcula convirtiendo el
operando promovido al tipo sin signo correspondiente, apicando
<code>~</code> y regresando al tipo con signo. El tipo del resultado es el
tipo del operando promovido.
</p>
</div>
</div>

<div id="outline-container-orga21f3ca" class="outline-5">
<h5 id="orga21f3ca">A7.4.7 Operador de negacion logica                               <a id="orgbcf14ce"></a></h5>
<div class="outline-text-5" id="text-orga21f3ca">
<p>
El operando del operaoor <code>!</code> debe tener tipo aritmetico o ser un
apuntador, y el resultado es <code>1</code> si el valor de su operando se
compara igual a <code>0</code> , y <code>0</code> en caso contrario. El tipo del
resultado es <code>int</code>.
</p>
</div>
</div>

<div id="outline-container-org96ac14c" class="outline-5">
<h5 id="org96ac14c">A7.4.8 Operador sizeol                                           <a id="org4f5a9fa"></a></h5>
<div class="outline-text-5" id="text-org96ac14c">
<p>
El operador <code>sizeof</code> produce el numero de bytes requeridos para
almacenar un objeto del tipo de su operando. El operando es una
expresion, que no es evaluada, o un nombre de tipo entre
parentesis. Cuando <code>sizeof</code> se aplica a <code>char</code>, el resultado es
<code>1</code>; cuando se aplica a un arreglo, el resultado es el numero
total de bytes en el arreglo. Cuando se aplica a una estructura o
union, el resultado es el numero de bytes en el objeto,
incluyendo cualquier relleno requerido para completar a un
arreglo: el tamaño de un arreglo de <code>n</code> elementos es <code>n</code> veces el
tamaño de un elemento. El operador no se puede aplicar a un
operando de tipo funcion o de tipo incompleto, o a un campo de
bits. El resultado es un entero constante sin signo; el tipo
particular se define por la implantacion. El header estandar
<code>&lt;stddef.h&gt;</code> (vease el <a href="#org89d4232">apendice B</a>) define este tipo como
<code>size_t</code>.
</p>
</div>
</div>
</div>

<div id="outline-container-org6f3b9ae" class="outline-4">
<h4 id="org6f3b9ae">A7.5 Cast                                                         <a id="orge7874e6"></a></h4>
<div class="outline-text-4" id="text-org6f3b9ae">
<p>
Una expresion unaria precedida por el nombre entre parentesis de
un tipo provoca la conversion del valor de la expresion al tipo
nombrado.
</p>

<pre class="example">
expresion-cast:
  expresion-unaria
  (nombre-de-tipo) expresion-cast
</pre>

<p>
Esta construccion se llama <i>cast</i> (conversion forzada). Los
nombres de tipo se describen en <a href="#orgfab544e">A8.8</a>. Los efectos de conversion
son descritos en <a href="#orgb740b71">A6</a>. Una expresion con un cast no es un valor-l.
</p>
</div>
</div>

<div id="outline-container-org1eb2fe9" class="outline-4">
<h4 id="org1eb2fe9">A7.6 Operadores multiplicativos                                   <a id="orgc233c52"></a></h4>
<div class="outline-text-4" id="text-org1eb2fe9">
<p>
Los operadores multiplicativos <code>*</code>, <code>/</code>, y <code>%</code> se agrupan de
izquierda a derecha.
</p>

<pre class="example">
expresion-multiplicativa:
  expresion-cast
  expresion-multiplicativa * expresion-cast
  expresion-multiplicativa / expresion-cast
  expresion-multiplicativa % expresion-cast
</pre>

<p>
Los operandos de <code>*</code> y <code>/</code> deben tener tipo aritmetico; los
operandos de <code>%</code> deben tener tipo entero. Las conversiones
aritmeticas usuales se realizan sobre los operandos, y predicen el
tipo del resultado.
</p>

<p>
El operador binario <code>*</code> denota multiplicacion.
</p>

<p>
El operador binario <code>/</code> produce el cociente y el operador <code>%</code> el
residuo de la division de primer operando entre el segundo; si el
segundo operando es <code>0</code>, el resultado esta indefinido. De otra
manera, siempre es cierto que <code>(a/b)*b + a%b</code> es igual que <code>a</code>. Si
ninguno de los operandos es negativo, entonces el residuo es no
negativo y menor que el divisor; si no lo son, se garantiza solo
que el valor absoluto del residuo es menor que el valor absoluto
del divisor.
</p>
</div>
</div>

<div id="outline-container-org99d2b5e" class="outline-4">
<h4 id="org99d2b5e">A7.7 Operadores aditivos                                          <a id="org3e54edb"></a></h4>
<div class="outline-text-4" id="text-org99d2b5e">
<p>
Los operadores aditivos <code>+</code> y <code>-</code> se agrupan de izquierda a
derecha. Si los operandos tienen tipo aritmetico, se realizan las
conversiones aritmeticas usuales. Existen algunas posibilidades
adicionales de tipos para cada operador.
</p>

<pre class="example">
expresion-aditiva:
  expresion-multiplicativa
  expresion-aditiva + expresion-multiplicativa
  expresion-aditiva - expresion-multiplicativa
</pre>

<p>
El resultado del operador <code>+</code> es la suma de los operandos. Un
apuntador a un objeto que este en un arreglo y un valor de
cualquier tipo entero se pueden sumar. Lo ultimo se convierte a
una direccion de desplazamiento, multiplicandolo por el tamaño del
objeto al que el apuntador apunta. La suma es un apuntador del
mismo tipo que el apuntador original y apunta a otro objeto dentro
del mismo arreglo, desplazado apropiadamente del objeto
original. Asi, si <code>P</code> es un apuntador a un objeto en un arreglo,
la expresion <code>P+1</code> en un apuntador al siguiente objeto en el
arreglo. Si el apuntador de la suma apunta fuera de los limites
del arreglo, excepto a la primera localidad mas alla del final, el
resultado es indefinido.
</p>

<div class="BLOOD">
<p>
La posibilidad de apuntadores mas alla del final del arreglo es
nueva. Esto legitimiza una expresion idiomatica comun para
iterar sobre los elementos de un arreglo.
</p>

</div>

<p>
El resultado del operador <code>-</code> es la diferencia de los operandos.
Un valor de cualquier tipo entero se puede restar de un apuntador,
y se aplican las mismas conversiones y condiciones que para la
adicion.
</p>

<p>
Si se restan dos apuntadores a objetos del mismo tipo, el
resultado es un valor entero con signo que representa el
desplazamiento entre los objetos apuntados; los apuntadores a
objetos sucesivos difieren en <code>1</code>. El tipo del resultado depende
de la implantacion, pero esta definido como <code>ptrdiff_t</code> en el
<i>header</i> estandar <code>&lt;stddef.h&gt;</code>. El valor esta indefinido a menos
de que los apuntadores apunten a objetos dentro del mismo arreglo;
sin embargo, si <code>P</code> apunta al ultimo miembro de un arreglo,
entonces <code>(P+1)-P</code> tiene valor <code>1</code>.
</p>
</div>
</div>

<div id="outline-container-org0e17b45" class="outline-4">
<h4 id="org0e17b45">A7.8 Operadores de corrimiento                                    <a id="org680c1fc"></a></h4>
<div class="outline-text-4" id="text-org0e17b45">
<p>
Los operadores de corrimiento <code>&gt;&gt;</code> y <code>&lt;&lt;</code> se agrupan de izquierda a
derecha. Para ambos operadores, cada operando debe ser entero y
esta sujeto a las promociones enteras. El tipo del resultado es
el del operando promovido de la izquierda. El resultado esta
indefinido si el operando de la derecha es negativo, mayor o igual
al numero de bits del tipo de la expresion de la izquierda.
</p>

<pre class="example">
expresion-de-corrimiento:
  expresion-aditiva
  expresion-de-corrimiento &lt;&lt; expresion-aditiva
  expresion-de-corrimiento &gt;&gt; expresion-aditiva
</pre>

<p>
El valor de <code>E1&lt;&lt;E2</code> es <code>E1</code> (interpretado como un patron de bits)
recorrido a la izquierda <code>E2</code> bits; en ausencia de desbordamiento,
esto es equivalente a la multiplicacion por 2<sup>E2</sup>.  El valor de
<code>E1&gt;&gt;E2</code> es El recorrido a la derecha <code>E2</code> posiciones de bits. El
corrimiento a la derecha es equivalente a la division entre 2<sup>E2</sup>
si <code>E1</code> es <code>unsigned</code> o si tiene un valor no negativo; de otra
forma el resultado esta definido por la implantacion.
</p>
</div>
</div>

<div id="outline-container-orgf9423be" class="outline-4">
<h4 id="orgf9423be">A7.9 Operadores de relacion                                       <a id="orgd2832e6"></a></h4>
<div class="outline-text-4" id="text-orgf9423be">
<p>
Los operadores de relacion se agrupan de izquierda a derecha, pero
esto no es de utilidad, <code>a&lt;b&lt;c</code> se analiza como <code>(a&lt;b)&lt;c</code>, y <code>a&lt;b</code>
se evalua como <code>0</code> o como <code>1</code>.
</p>

<pre class="example">
expresion-relacional:
  expresion-de-corrimiento
  expresion-relacional &lt;  expresion-de-corrimiento
  expresion-relacional &gt;  expresion-de-corrimiento
  expresion-relacional &lt;= expresion-de-corrimiento
  expresion-relacional &gt;= expresion-de-corrimiento
</pre>

<p>
Los operadores <code>&lt;</code> (menor que), <code>&gt;</code> (mayor que), <code>&lt;=</code> (menor o
igual a) y <code>&gt;=</code> (mayor o igual a) dan todos <code>0</code> si la relacion
especificada es falsa, y <code>1</code> si es verdadera. El tipo del
resultado es <code>int</code>. Las conversiones aritmeticas usuales se
realizan sobre los operandos aritmeticos. Pueden compararse los
apuntadores a objetos del mismo tipo; el resultado depende de las
localidades relativas en el espacio de direccionamiento de los
objetos apuntados. La comparacion de apuntadores esta definida
solo para partes del mismo objeto: si dos apuntadores apuntan al
mismo objeto simple, se comparan como iguales; si los apuntadores
lo hacen a miembros de la misma estructura, los apuntadores a
objetos declarados mas adelante en la estructura se comparan como
mayores; si los apuntadores son a miembros de la misma union, se
comparan como iguales; si los apuntadores hacen referencia a
miembros de un arreglo, la comparacion es equivalente a la
comparacion de los correspondientes subindices. Si <code>P</code> apunta al
ultimo miembro de un arreglo, entonces <code>P+1</code> se compara como mayor
que <code>P</code>, incluso aunque <code>P+1</code> apunte fuera del arreglo. De otra
manera, la comparacion de apuntadores esta indefinida.
</p>

<div class="BLOOD">
<p>
Estas reglas liberan algo las restricciones establecidas en la
primera edicion, permitiendo la comparacion de apuntadores a
diferentes miembros de una estructura o union. Tambien legalizan
la comparacion con un apuntador justo mas alla del final de un
arreglo.
</p>

</div>
</div>
</div>

<div id="outline-container-orgda6f092" class="outline-4">
<h4 id="orgda6f092">A7.10 Operadores de igualdad                                      <a id="org71b6d56"></a></h4>
<div class="outline-text-4" id="text-orgda6f092">
<pre class="example">
expresion-de-igualdad:
  expresion-relacional
  expresion-de-igualdad == expresion-relacional
  expresion-de-igualdad != expresion-relacional
</pre>

<p>
Los operadores <code>==</code> (igual a) y <code>!=</code> (no igual a) son analogos a
los operadores de relacion excepto por su menor precedencia. (Asi
<code>a&lt;b == c&lt;d</code> es <code>1</code> cuando <code>a&lt;b</code> y <code>c&lt;d</code> tengan los mismos valores
de verdad).
</p>

<p>
Los operadores de igualdad siguen las mismas reglas que los
operadores de relacion, pero permiten posibilidades adicionales:
un apuntador puede ser comparado con una expresion constante
entera con valor <code>0</code>, o con un apuntador a <code>void</code>. Vease <a href="#orga91bc61">A6.6</a>.
</p>
</div>
</div>

<div id="outline-container-org43fde4c" class="outline-4">
<h4 id="org43fde4c">A7.11 Operador AND para bits                                      <a id="org08b815f"></a></h4>
<div class="outline-text-4" id="text-org43fde4c">
<pre class="example">
expresion-AND:
  expresion-de-igualdad
  expresion-AND &amp; expresion-de-igualdad
</pre>

<p>
Se realizan las conversiones aritmeticas usuales; el resultado es
la funcion AND de bits de los operandos. El operador se aplica
solo a operandos enteros.
</p>
</div>
</div>

<div id="outline-container-org5db16b1" class="outline-4">
<h4 id="org5db16b1">A7.12 Operador OR exclusivo para bits                             <a id="org7ea722e"></a></h4>
<div class="outline-text-4" id="text-org5db16b1">
<pre class="example">
expresion-OR-exclusivo:
  expresion-AND
  expresion-OR-exclusivo ^ expresion-AND
</pre>

<p>
Se realizan las conversiones aritmeticas usuales; el resultado es
la funcion OR exclusivo de los operandos. El operador se aplica
solo a operandos enteros.
</p>
</div>
</div>

<div id="outline-container-orgd1d3d1d" class="outline-4">
<h4 id="orgd1d3d1d">A7.13 Operador OR inclusivo para bits                             <a id="orgd0af3ce"></a></h4>
<div class="outline-text-4" id="text-orgd1d3d1d">
<pre class="example">
expresion-OR-inclusivo:
  expresion-OR-exclusivo
  expresion-OR-inclusivo | expresion-OR-exclusivo
</pre>

<p>
Se realizan las conversiones aritmeticas usuales; el resultado es
la funcion OR inclusivo de sus operandos. El operador se aplica
solo a operandos enteros.
</p>
</div>
</div>

<div id="outline-container-org4e0e8d3" class="outline-4">
<h4 id="org4e0e8d3">A7.14 Operador logico AND                                         <a id="org01a6536"></a></h4>
<div class="outline-text-4" id="text-org4e0e8d3">
<pre class="example">
expresion-logica-AND:
  expresion-OR-inclusivo
  expresion-logica-AND &amp;&amp; expresion-OR-inclusivo
</pre>

<p>
El operador <code>&amp;&amp;</code> se agrupa de izquierda a derecha. Regresa <code>1</code> si
ambos operandos se comparan como diferentes de cero; de otra
manera, regresa <code>0</code>. A diferencia de <code>&amp;</code>, <code>&amp;&amp;</code> garantiza la
evaluacion de izquierda a derecha: el primer operando es evaluado,
incluyendo todos los efectos colaterales; si es igual a <code>0</code>, el
valor de la expresion es <code>0</code>. De otra manera, el operando derecho
es evaluado, y si es igual a <code>0</code>, el valor de la expresion es <code>0</code>;
de otra manera es <code>1</code>.
</p>

<p>
Los operandos no requieren de tener el mismo tipo, pero cada uno
debe tener tipo aritmetico o ser un apuntador. El resultado es
<code>int</code>.
</p>
</div>
</div>

<div id="outline-container-org8196249" class="outline-4">
<h4 id="org8196249">A7.15 Operador logico OR                                          <a id="org68f91bd"></a></h4>
<div class="outline-text-4" id="text-org8196249">
<pre class="example">
expresion-logica-OR:
  expresion-logica-AND
  expresion-logica-OR || expresion-logica-AND
</pre>

<p>
El operador <code>||</code> se agrupa de izquiera a derecha. Regresa <code>1</code> si
alguno de sus operandos no se compara como cero, y <code>0</code> en caso
contrario. A diferencia de <code>|</code>, <code>||</code> garantiza la evaluacion de
izquierda a derecha: el primer operando es evaluado, incluyendo
los efectos colaterales; si es diferente de <code>0</code>, el valor de la
expresion es <code>1</code>. De otra manera, es evaluado el operando derecho
y, si es diferente de <code>0</code>, el valor de la expresion es <code>1</code>; de
otra manera es cero.
</p>

<p>
Los operandos no requieren tener el mismo tipo, pero cada uno de
ellos debe tener numerico o ser apuntador. El resultado es <code>int</code>.
</p>
</div>
</div>

<div id="outline-container-orgf2b929c" class="outline-4">
<h4 id="orgf2b929c">A7.16 Operador condicional                                        <a id="orgf8fe40c"></a></h4>
<div class="outline-text-4" id="text-orgf2b929c">
<pre class="example">
expresion condicional:
  expresion-logica-OR
  expresion-logica-OR ? expresion : expresion-condicional
</pre>

<p>
La primera expresion se evalua, incluyendo todos los efectos
colaterales; si se compara como diferente de <code>0</code>, el resultado es
el valor de la segunda expresion; de otra manera, es el de la
tercera expresion. Solo se evalua uno de los operadores segundo o
tercero. Si el segundo y el tercer operandos son aritmeticos, se
realizan las conversiones aritmetica usuales para hacerlos de
algun tipo comun y ese es el tipo del resultado. Si ambos son
void, estructuras o uniones del mismo tipo, o apuntadores a
objetos del mismo tipo, el resulta tiene el tipo comun. Si uno es
un apuntador y el otro la constante <code>0</code>, el <code>0</code> es convertido a
tipo apuntador y el resultado tiene ese tipo. Si uno es un
apuntador a <code>void</code> y el otro es otro apuntador, el otro apuntador
es convertido a apuntador a <code>void</code> y ese es el tipo del resultado.
</p>

<p>
En la comparacion de tipos para apuntadores, los calificadores de
tipo (<a href="#org963fdbc">A8.2</a>) en el tipo al que apunta el apuntador no importan,
pero el resultado hereda los calificadores de ambas ramas de la
condicional.
</p>
</div>
</div>

<div id="outline-container-org9de8d8c" class="outline-4">
<h4 id="org9de8d8c">A7.17 Expresiones de asignacion                                   <a id="org985740a"></a></h4>
<div class="outline-text-4" id="text-org9de8d8c">
<p>
Existen varios operadores de asignacion; todos se agrupan de
derecha a izquierda.
</p>

<pre class="example">
expresion-de-asignacion:
  expresion-condicional
  expresion-unaria operador-de-asignacion expresion-de-asignacion

operador-de-asignacion: uno de
  = *= /= %= += -= &lt;&lt;= &gt;&gt;= &amp;= ^= |=
</pre>

<p>
Todos requieren de un valor-l como operando izquierdo y este debe
ser modificable: no debe ser un arreglo y no debe tener un tipo
incompleto ni ser una funcion. Tampoco debe ser calificado con
<code>const</code>; si es una estructura o union, no debe tener ningun
miembro o, recursivamente ningun submiembro calificado con
<code>const</code>. El tipo de una expresion de asignacion es el de su
operando izquierdo, y el valor es el almacenado en el operando
izquierdo despues de que ha tenido lugar la asignacion.
</p>

<p>
En la asignacion simple con <code>=</code>, el valor de la expresion
reemplaza al del objeto al que se hace referencia con el
valor-l. Uno de los siguientes debe ser verdadero: ambos operandos
tienen tipo aritmetico, en tal caso, el operando de la derecha es
convertido al tipo del operando izquierdo por la asignacion; o
ambos operandos son estructuras o uniones mismo tipo; o un
operando es un apuntador y el otro es un apuntador a <code>void</code>; o el
operando izquierdo es un apuntador y el operando derecho es una
expresion constante con valor <code>0</code>; o ambos operandos son
apuntadores a funciones u objetos cuyos tipos son los mismo
excepto por la posible ausencia de <code>const</code> o <code>volatile</code> en el
operando derecho.
</p>

<p>
Una expresion de la forma <code>E1 op= E2</code> es equivalente a <code>E1 = E1 op
    (E2)</code> excepto que <code>E1</code> es evaluado solo una vez.
</p>

<div class="BLOOD">
<p>
De acuerdo con las restricciones anteriores, es ilegal asignar
apuntadores cuando el lado derecho apunta a un objeto de algun
tipo y el lado izquierdo apunta a un objeto con una version
calificada con <code>const</code> de ese tipo. Una lectura estricta de esta
regla y su analoga para <i>cast</i> causa dificultades al implantar
ciertas funciones de biblioteca; seria bueno que fuera menos
restricta.
</p>

</div>
</div>
</div>

<div id="outline-container-org59a1d22" class="outline-4">
<h4 id="org59a1d22">A7.18 Operador coma                                               <a id="org523ac57"></a></h4>
<div class="outline-text-4" id="text-org59a1d22">
<pre class="example">
expresion:
  expresion-de-asignacion
  expresion , expresion-de-asignacion
</pre>

<p>
Un par de expresiones separadas por una coma se evalua de
izquierda a derecha y el valor de la expresion izquierda se
descarta. El tipo y valor del resultado son el tipo y valor del
operando de la derecha. Todos los efectos colaterales de la
evaluacion del operando izquierdo se completan antes de comenzar
la evaluacion del operando derecho. En contextos donde a la coma
se le da un significado especial, por ejemplo en listas de
argumentos para funciones (<a href="#org2308e57">A7.3.2</a>) y listas de inicializadores
(<a href="#orgbe0450e">A8.7</a>), la unidad sintactica requerida es una expresion de
asignacion, de modo que el operador coma solo aparece en una
agrupacion limitada por parentesis; por ejemplo,
</p>

<div class="org-src-container">
<pre class="src src-c"><span style="color: #87cefa;">f</span>(a, (t=3, t+2), c)
</pre>
</div>

<p>
tiene tres argumentos, el segundo de los cuales tiene el valor
<code>5</code>.
</p>
</div>
</div>

<div id="outline-container-org5e40114" class="outline-4">
<h4 id="org5e40114">A7.19 Expresiones constantes                                      <a id="org9718d2e"></a></h4>
<div class="outline-text-4" id="text-org5e40114">
<p>
Sintacticamente, una expresion constante es una expresion
restringida a un subconjunto de operadores:
</p>

<pre class="example">
expresion-constante:
  expresion-condicional
</pre>

<p>
Las expresiones que evaluan a una constante se requieren en varios
contextos: despues de <code>case</code>, como limites de un arreglo y
longitudes de campos de bits, como valor de una constante de
enumeracion, en inicializadores y dentro de ciertas expresiones
del preprocesador.
</p>

<p>
Las expresiones constantes no pueden contener asignaciones,
operadores de incremento o decremento, llamadas a funciones ni
operadores coma, excepto en un operando de <code>sizeof</code>. Si se
requiere que la expresion constante sea entera, sus operandos
deben consistir en constantes enteras, de enumeracion, de
caracteres y flotantes; los <i>cast</i> deben estipular un tipo entero
y cualquier constante flotante debe ser convertida a entero. Esto
necesariamente excluye operaciones sobre arreglos, indireccion,
direccion-de y miembros de estructura.  (Sin embargo, se permite
cualquier operando para <code>sizeof</code>.)
</p>

<p>
Hay mas libertad para las expresiones constantes de
inicializadores; los operandos pueden ser de cualquier tipo de
constante y el operando unario <code>&amp;</code> puede ser aplicado a objetos
externos o estaticos, y a arreglos externos o estaticos, indexados
con una expresion constante. El operador unario <code>&amp;</code> tambien se
puede aplicar implicitamente por la aparicion de arreglos no
indexados y funciones. Los inicializadores deben evaluarse a una
constante o a la direccion de un objeto externo o estatico
previamente declarado mas o menos una constante.
</p>

<p>
Se permite menos libertad para las expresiones enteras constantes
despues de <code>#if</code>; no se perniten expresiones <code>sizeof</code>, constantes
de enumeracion ni <i>cast</i>. Vease <a href="#org3126499">A12.5</a>.
</p>
</div>
</div>
</div>

<div id="outline-container-orgbe16103" class="outline-3">
<h3 id="orgbe16103">A8   Declaraciones                                                 <a id="orga8dfc2a"></a></h3>
<div class="outline-text-3" id="text-orgbe16103">
<p>
Las declaraciones especifican la interpretacion dada a cada
identificador; no necesariamente reservan espacio de almacenamiento
asociado con el identificador. Las declaraciones que reservan
almacenamiento se llaman definiciones. Las declaraciones tienen la
forma:
</p>

<div class="BLOCK">
<p>
especificadores-de-declaracion lista-de-declaradores-init<sub>opt</sub>;
</p>

</div>

<p>
Los declaradores que estan en la lista-de-declaradores-init
contienen la lista de identificadores que estan siendo declarados;
los especificadores-de-declaracion consisten en una secuencia de
especificadores de tipo y categoria de almacenamiento.
</p>

<div class="BLOCK">
<p>
especificadores-declaracion:
  especificador-categoria-almacenamiento especificadores-de-declaracion<sub>opt</sub>
  especificador-de-tipo especificadores-de-declaracion<sub>opt</sub>
  cualificador-de-tipo especificadores-de-declaracion<sub>opt</sub>
</p>

<p>
lista-declaradores-init:
  declarador-init
  lista-declaradores-init , declarador-init
</p>

<p>
declarador-init:
  declarador
  declarador = inicializador
</p>

</div>

<p>
Los declaradores se discutiran posteriormente (<a href="#orged01b58">A8.5</a>), y contienen
los nombres que estan siendo declarados. Una declaracion debe tener
al menos un declarador o su especificador de tipo debe declarar la
etiqueta de una estructura, una etiqueta de union o los miembros de
una enumeracion; no se permiten declaraciones vacias.
</p>
</div>

<div id="outline-container-orgfa62e75" class="outline-4">
<h4 id="orgfa62e75">A8.1 Especificadores de categoria de almacenamiento               <a id="org53ffc22"></a></h4>
<div class="outline-text-4" id="text-orgfa62e75">
<p>
Los especificadores de categoria de almacenamiento son:
</p>

<dl class="org-dl">
<dt>especificador-categoria-almacenamiento</dt><dd><div class="org-src-container">
<pre class="src src-c"><span style="color: #00ffff;">auto</span>
<span style="color: #00ffff;">register</span>
<span style="color: #00ffff;">static</span>
<span style="color: #00ffff;">extern</span>
<span style="color: #00ffff;">typedef</span>
</pre>
</div></dd>
</dl>


<p>
Los significados de las categorias de almacenamiento se
discutieron en <a href="#org672e151">A4</a>.
</p>

<p>
Los especificadores <code>auto</code> y <code>register</code> dan a los objetos
declarados categoria de almacenamiento automatico y solo se pueden
usar dentro de funciones. Tales declaraciones tambien sirven como
definiciones y provocan que se reserve almacenamiento. Una
declaracion <code>register</code> es equivalente a una declaracion <code>auto</code>,
pero sugiere que se hara acceso frecuente a los objetos
declarados. Pocos objetos son realmente localizados en registros y
solo ciertos tipos son elegibles; las restricciones son
dependientes de la implantacion. Sin embargo, si un objeto es
declarado <code>register</code>, el operador unario <code>&amp;</code> no se le puede
aplicar, explicita o implicitamente.
</p>

<div class="BLOOD">
<p>
La regla de que es ilegal calcular la direccion de un objeto
declarado <code>register</code>, pero que realmente se tomara como <code>auto</code>,
es nueva.
</p>

</div>

<p>
El especificador <code>static</code> da a los objetos declarados categoria de
almacenamiento estatica, y se puede emplear dentro o fuera de las
funciones. Dentro de una funcion, este especificador provoca que
se asigne almacenamiento y sirve como definicion; para sus efectos
fuera de una funcion, vease <a href="#orgde38dea">A11.2</a>.
</p>

<p>
Una declaracion con <code>extern</code>, utilizada dentro de una funcion,
especifica que el almacenamiento para los objetos declarados esta
definido en algun otro lugar; para sus efectos fuera de una
funcion, vease <a href="#orgde38dea">A11.2</a>.
</p>

<p>
El especificador <code>typedef</code> no reserva almacenamiento y se llama
especificador de categoria de almacenamiento solo por conveniencia
sintactica; se discute en <a href="#orgd1558a8">A8.9</a>.
</p>

<p>
Cuando mas se puede dar un especificador de categoria de
almacenamiento dentro de una declaracion. Si no se da ninguno, se
utilizan estas reglas: los objetos declarados dentro de una
funcion se toman como <code>auto</code>; las funciones declaradas dentro de
una funcion se toman como <code>extern</code>; los objetos y funciones
declarados fuera de una funcion se toman como estaticos, con
enlace externo. Vease <a href="#org2ee5a92">A10</a>-<a href="#org73717e3">A11</a>.
</p>
</div>
</div>

<div id="outline-container-orga1c1af9" class="outline-4">
<h4 id="orga1c1af9">A8.2 Especificadores de tipo                                      <a id="org963fdbc"></a></h4>
<div class="outline-text-4" id="text-orga1c1af9">
<p>
Los especificadores de tipo son
</p>

<pre class="example">
especificador-de-tipo:
  void
  char
  short
  int
  long
  float
  double
  signed
  unsigned
  especificador-estructura-o-union
  especificador-enum
  nombre-typedef
</pre>

<p>
Cuando mas se puede especificar una de las palabras <code>long</code> o
<code>short</code> junto con <code>int</code>; el significado es el mismo si no se
menciona <code>int</code>. La palabra <code>long</code> se puede especificar junto con
<code>double</code>. Cuando mas se puede especificar una de las palabras
<code>signed</code> o <code>unsigned</code> junto con <code>int</code> o cualquiera de sus
variantes, <code>short</code>, <code>long</code> o con <code>char</code>. Cualquiera de las dos
puede aparecer sola; en tal caso se entiende como <code>int</code>. El
especificador <code>signed</code> es util para forzar a los objetos <code>char</code> a
tener signo; es permisible pero redundante dentro de otros tipos
enteros.
</p>

<p>
De otra manera, cuando mas se puede dar un especificador de tipo
en un declaracion. Si el especificador de tipo se omite de una
declaracion, se toma como <code>int</code>.
</p>

<p>
Los tipos tambien se pueden calificar, para indicar propiedades
especiales de los objetos que estan siendo declarados.
</p>

<pre class="example">
calificador-de-tipo
  const
  volatile
</pre>

<p>
Los calificadores de tipo pueden aparecer con cualquier
especificador de tipo. Un objeto <code>const</code> se puede inicializar,
pero despues no se le puede asignar nada. No hay semantica
independiente de la implantacion para objetos <code>volatile</code>.
</p>

<div class="BLOOD">
<p>
Las propiedades <code>const</code> y <code>volatile</code> son nuevas dentro del
estandar ANSI. El proposito de <code>const</code> es anunciar objetos que
pueden ser localizados en memoria de solo lectura y tal vez
incrementar las oportunidades para optimizacion. El proposito de
<code>volatile</code> es forzar a la implantacion a suprimir la
optimizacion que, de otra manera, podria ocurrir. Por ejemplo,
para una maquina con entrada/salida asignado a memoria, el
apuntador a un registro de dispositivo se podria declarar como
un apuntador a <code>volatile</code> para prevenir que el compilador
remueva las referencias aparentemente redundantes a traves del
apuntador. Excepto que debe diagnosticar explicitamente los
intentos de cambiar objetos <code>const</code>, el compilador puede ignorar
estos calificadores.
</p>

<p>
Un tercer calificador, <code>noalias</code>, permanece bajo consideracion
por el comite de estandarizacion.
</p>

</div>
</div>
</div>

<div id="outline-container-org660d855" class="outline-4">
<h4 id="org660d855">A8.3 Declaraciones de estructura y union                          <a id="org8d2fe4a"></a></h4>
<div class="outline-text-4" id="text-org660d855">
<p>
Una estructura es un objeto que consta de una secuencia de
miembros nombrados de varios lipos. Una union en un objeto que
contiene, en momentos distintos, cualquiera de algunos miembros de
varios tipos. Los especificadores de estructura y union tienen la
misma forma.
</p>

<div class="BLOCK">
<p>
especificador-estructura-o-union:
  estructura-o-union identificador<sub>opt</sub> { lista-declaraciones-struct }
  estructura-o-union identificador
</p>

<p>
estructura-o-union:
  struct
  union
</p>

</div>

<p>
Una lista-de-declaraciones-struct es una secuencia de
declaraciones para los miembros de la estructura o union:
</p>

<div class="BLOCK">
<p>
lista- declaraciones-struct:
  declaracion-struct
  lista-declaraciones-struct declaracion-struct
</p>

<p>
declaracion-struct:
  lista-calificador-especificador lista-de-declaradores-struct;
</p>

<p>
lista-cualificador-especificador:
  especificador-de-tipo lista-calificador-especificador<sub>opt</sub>
  calificador-de-tipo lista-calificador-especificador<sub>opt</sub>
</p>

<p>
lista-declaradores-struct:
  declarador-struct
  lista-declaradores-struct , declarador-struct
</p>

</div>

<p>
Por lo general, un declarador-struct es solo un declarador para un
miembro de estructura o union: Un miembro de estructura tambien
puede constar de un numero especificado de bits. Tal miembro
tambien se llama <i>campo de bits</i>, o simplemente <i>campo</i>, un
caracter dos puntos marca el inicio de su longitud despues del
nombre del campo.
</p>

<pre class="example">
declarador-struct:
  declarador
  declarador_opt : expresion-constante
</pre>

<p>
Un especificador de tipo de la forma
</p>

<pre class="example">
estructura-o-union identificador { lista-declaraciones-struct }
</pre>

<p>
declara que el identificador sera la etiqueta de la estructura o
union especificado por la lista.  Una declaracion posterior en el
mismo alcance o mas interno se puede referir al mismo tipo
utilizando la etiqueta dentro de un especificador sin la lista:
</p>

<pre class="example">
estructura-o-union identificador
</pre>

<p>
Si aparece un especificador con idenficador pero sin lista cuando
el identificador no esta declarada, se especifica un <i>tipo
incompleto</i>.  Los objetos con tipo incompleto de estructura o
union se pueden mencionar en contextos donde no sea necesario su
tamaño, por ejemplo, en declaraciones (no definiciones), para
estipular un apuntador o para crear un <code>typedef</code>, pero no de otra
manera. El tipo se completa al presentarse un especificador
subsecuente con ese identificador que contenga una lista de
declaraciones. Incluso en especificadores con una lista, el tipo
de la estructura o union que esta siendo declarado es incompleto
dentro de la lista, y se completa solo en el que termina el
especificador.
</p>

<p>
Una estructura no puede contener un miembro de tipo incompleto.
Por lo tanto, es imposible declarar una estructura o union que
contenga una instancia de ella misma. Sin embargo, ademas de dar
un nombre al tipo de estructura o union, las etiquetas permiten la
definicion de estructuras autorreferenciadas; una estructura o
union puede contener un apuntador a una instancia de ella misma,
debido a que pueden ser declarados apuntadores a tipos
incompletos.
</p>

<p>
Una regla muy especial se aplica a declaraciones de la forma
</p>

<pre class="example">
estructura-o-union identificador;
</pre>

<p>
que declara una estructura o union, pero no tiene lista de
declaraciones ni declaradores.  Aun si el identificador es una
etiqueta de estructura o union ya declarado en un alcance mas
externo (<a href="#org5acc4e3">A11.1</a>), esta declaracion hace al identificador la
etiqueta de una nueva estructura o union, de tipo incompleto, en
el alcance actual.
</p>

<div class="BLOOD">
<p>
Esta regla es nueva bajo ANSI. Su funcion es tratar con
estructuras mutuamente recursivas declaradas en un alcance mas
interno, pero cuyos identificadores podrian haber sido ya
declarados en el alcance mas externo.
</p>

</div>

<p>
Un especificador de estructura o union con una lista sin
identificador crea un tipo unico; se le puede hacer referencia
directamente solo en la declaracion de la que es parte.
</p>

<p>
Los nombres de miembros y etiquetas no entran en conflicto entre
ellos o con variables ordinarias. Un nombre de miembro no puede
aparecer dos veces en la misma estructura o union, pero el mismo
nombre de miembro se puede emplear en diferentes estructuras o
uniones.
</p>

<div class="BLOOD">
<p>
En la primera edicion de este libro, los nombres de miembros de
estructuras y uniones no estaban asociados con su padre. Sin
embargo, esta asociacion se hizo comun en compiladores mucho
antes del estandar ANSI.
</p>

</div>

<p>
Un miembro que no sea campo de una estructura o union puede tener
cualquier tipo de objeto. Un miembro campo (que no requiere tener
un declarador y, por tanto, puede no tener nombre) tiene tipo
<code>int</code>, <code>unsigned int</code>, o <code>signed int</code>, y es interpretado como un
objeto de tipo entero de la longitud en bits especificada; el que
un campo <code>int</code> se trate como con signo depende de la implantacion.
Los campos adyacentes que son miembros de estructuras se
empaquetan en unidades de almacenamiento dependientes de la
implantacion en una direccion tambien dependiente. Cuando hay la
posibilidad de que un campo que sigue a otro no entre en una
unidad de almacenamiento parcialmente llena, se puede separar en
unidades, o la unidad se puede rellenar. Un campo sin nombre con
amplitud <code>0</code> fuerza a este rellenado, de modo que el siguiente
campo comenzara en la orilla de la siguiente unidad de asignacion.
</p>

<div class="BLOOD">
<p>
El estandar ANSI hace que los campos sean aun mas dependientes
de la implantacion que la primera edicion. Es recomendable leer
las reglas del lenguaje para almacenar campos de bits como
"dependientes de la implantacion" sin limitaciones. Las
estructuras con campos de bits se pueden emplear como una forma
transportable de intentar reducir el almacenamiento requerido
para una estructura (con el costo probable de incrementar el
espacio de instrucciones y tiempo para tener acceso a los
campos), o como una forma no transportable de describir una
plantilla de almacenamiento conocida al nivel de bits. En el
segundo caso, es necesario entender las reglas de la
implantacion local.
</p>

</div>

<p>
Los miembros de una estructura tienen direcciones ascendentes en
el orden de sus declaraciones. De una estructura un miembro que no
sea campo se alinea con un limite de direccionamiento dependiendo
de su tipo; por tanto, puede haber huecos sin nombre dentro de una
estructura. Si un apuntador a una estructura es convertido al tipo
de un apuntador a su primer miembro, el resultado se refiere al
primer miembro.
</p>

<p>
Se puede pensar en una union como una estructura donde todos sus
miembros inician en el desplazamiento <code>0</code> y cuyo tamaño es
suficiente para contener a cualquiera de miembros. Cuando mas, uno
de los miembros puede ser almacenado dentro de una union a la
vez. Si un apuntador a union es convertido al tipo de un apuntador
a un miembro, el resultado se refiere a ese miembro.
</p>

<p>
Un ejemplo simple de declaracion de estructura es
</p>

<div class="org-src-container">
<pre class="src src-c"><span style="color: #00ffff;">struct</span> <span style="color: #98fb98;">tnode</span> {
  <span style="color: #98fb98;">char</span> <span style="color: #eedd82;">tword</span>[20];
  <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">count</span>;
  <span style="color: #00ffff;">struct</span> <span style="color: #98fb98;">tnode</span> *<span style="color: #eedd82;">left</span>;
  <span style="color: #00ffff;">struct</span> <span style="color: #98fb98;">tnode</span> *<span style="color: #eedd82;">right</span>;
};
</pre>
</div>

<p>
que contiene un arreglo de 20 caracteres, un entero y dos
apuntadores a estructuras semejantes. Una vez que se ha dado esta
declaracion, la declaracion
</p>

<div class="org-src-container">
<pre class="src src-c"><span style="color: #00ffff;">struct</span> <span style="color: #98fb98;">tnode</span> <span style="color: #eedd82;">s</span>, *<span style="color: #eedd82;">sp</span>;
</pre>
</div>

<p>
declara <code>s</code> como una estructura de la variedad dada y <code>sp</code> como
apuntador a una estructura de ese tipo. Con estas declaraciones,
la expresion
</p>

<div class="org-src-container">
<pre class="src src-c">sp-&gt;count
</pre>
</div>

<p>
se refiere al campo <code>count</code> de la estructura a la que apunta <code>sp</code>;
</p>

<div class="org-src-container">
<pre class="src src-c">s.left
</pre>
</div>

<p>
se refiere al apuntador al subarbol izquierdo de la estructura
<code>s</code>; y
</p>

<div class="org-src-container">
<pre class="src src-c">s.right-&gt;tword[0]
</pre>
</div>

<p>
se refiere al primer caracter del miembro <code>tword</code> del subarbol
derecho de <code>s</code>.
</p>

<p>
En general, un miembro de una union no puede ser inspeccionado a
menos de que el valor de la union haya sido asignado utilizando
ese miembro. Sin embargo, una consideracion especial simplifica el
uso de uniones: si una union contiene varias estructuras que
comparten una secuencia inicial comun, y si la union actualmente
contiene una de esas estructuras, se permite hacer referencia a la
parte inicial comun de cualesquiera de las estructuras
contenidas. Por ejemplo, el siguiente fragmento es legitimo:
</p>

<div class="org-src-container">
<pre class="src src-c"><span style="color: #00ffff;">union</span> {
  <span style="color: #00ffff;">struct</span> {
    <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">type</span>;
  } <span style="color: #eedd82;">n</span>;
  <span style="color: #00ffff;">struct</span> {
    <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">type</span>;
    <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">intnode</span>;
  } <span style="color: #eedd82;">ni</span>;
  <span style="color: #00ffff;">struct</span> {
    <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">type</span>;
    <span style="color: #98fb98;">float</span> <span style="color: #eedd82;">floatnode</span>;
  } <span style="color: #eedd82;">nf</span>;
} <span style="color: #eedd82;">u</span>;
...
u.nf.type = FLOAT;
u.nf.floatnode = 3.14;
...
<span style="color: #00ffff;">if</span> (u.n.type == FLOAT)
  ... sin(u.nf.floatnode) ...
</pre>
</div>
</div>
</div>

<div id="outline-container-org65d5166" class="outline-4">
<h4 id="org65d5166">A8.4 Enumeraciones                                                <a id="org4b53932"></a></h4>
<div class="outline-text-4" id="text-org65d5166">
<p>
Las enumeraciones son tipos con valores que fluctuan entre un
conjunto de constantes nombradas que se llaman enumeradores. La
forma de un especificador de enumeracion se toma de la de las
estructuras y uniones.
</p>

<pre class="example">
especificador-enum:
  enum identificador_opt { lista-de-enumerador }
  enum identificador

lista-de-enumerador:
  enumerador
  lista-de-enumerador , enumerador

enumerador:
  identificador
  identificador = expresion-constante
</pre>

<p>
Los identificadores dentro de una lista de enumerador se declaran
como constantes de tipo <code>int</code> y pueden aparecer en cualquier lugar
donde se requiera una constante. Si no aparecen enumeradores con
<code>=</code>, entonces los valores de las correspondientes constantes
inician en <code>0</code> y se incrementan en <code>1</code> al leer la declaracion de
izquierda a derecha. Un enumerador con <code>=</code> da al identificador
asociado el valor especificado; los identificadores subsecuentes
continuan la progresion del valor asignado.
</p>

<p>
Los nombres de enumeradores en el mismo alcance deben ser
distintos entre si y de los nombres de variables ordinarias, pero
no es necesario que los valores sean distintos.
</p>

<p>
El papel del identificador en el especificador-enum es analogo al
de la etiqueta de las estructuras en un
especificador-de-estructura; nombra una enumeracion particular.
Las reglas para especificadores-enum con y sin etiquetas y listas
son las mismas que para especificadores de estructuras y uniones,
excepto que los tipos de enumeracion incompleta no existen; la
etiqueta de un especificador-enum sin una lista de enumeradores
debe referirse a un especificador en el alcance dentro de la
lista.
</p>

<div class="BLOOD">
<p>
Las enumeraciones son nuevas desde la primera edicion de este
libro, pero han sido parte del lenguaje por algunos años.
</p>

</div>
</div>
</div>

<div id="outline-container-org9fadbe1" class="outline-4">
<h4 id="org9fadbe1">A8.5 Declaradores                                                 <a id="orged01b58"></a></h4>
<div class="outline-text-4" id="text-org9fadbe1">
<p>
Los declaradores tienen la sintaxis:
</p>

<div class="BLOCK">
<p>
declarador
  apuntador<sub>opt</sub> declarador-directo
</p>

<p>
declarador-directo:
  identificador
  ( declarador )
  declarador-directo [ expresion-constante<sub>opt</sub> ]
  declarador-directo ( lista-tipos-de-parametro )
  declarador-directo ( lista-de-identificadores<sub>opt</sub> )
</p>

<p>
apuntador:
</p>
<ul class="org-ul">
<li>lista-calificadores-de-tipo<sub>opt</sub></li>
<li>lista-calificadores-de-tipo<sub>opt</sub> apuntador</li>
</ul>

<p>
lista-calificadores-de-tipo:
  calificador-de-tipo
  lista-calificadores-de-tipo calificador-de-tipo
</p>

</div>

<p>
La estructura de los declaradores es semejante a la de las
expresiones de indireccion, funciones y arreglos; el agrupamiento
es el mismo.
</p>
</div>
</div>

<div id="outline-container-orgc65b74e" class="outline-4">
<h4 id="orgc65b74e">A8.6 Significado de los declaradores                              <a id="org90b2ecc"></a></h4>
<div class="outline-text-4" id="text-orgc65b74e">
<p>
La lista de declaradores aparece despues de una secuencia de
especificadores de categoria de tipo y almacenamiento. Cada
declarador declara un identificador principal unico, que aparece
como la primera alternativa de la produccion para
<i>declarador-directo</i>. Los especificadores de categoria de
almacenamiento se aplican directamente a este identificador, pero
su tipo depende de la forma de su declarador. Un declarador es
leido como la afirmacion de que cuando su identificador aparece en
una expresion de la misma forma que el declarador, produce un
objeto del tipo especificado.
</p>

<p>
Considerando solo las partes de tipo de los especificadores de
declaracion (<a href="#org963fdbc">A8.2</a>) y un declarador particular, una declaracion
tiene la forma "T D", donde <code>T</code> es un tipo y <code>D</code> es un
declarador. El tipo atribuido al identificador en las varias
formas del declarador se describe inductivamente empleando esta
notacion.
</p>

<p>
En una declaracion <code>T D</code> donde <code>D</code> es un identificador solo, el
tipo del ideniificador es <code>T</code>.
</p>

<p>
En una declaracion <code>T D</code> donde <code>D</code> tiene la forma
</p>

<div class="org-src-container">
<pre class="src src-c">( D1 )
</pre>
</div>

<p>
el tipo del identificador en <code>D1</code> es el mismo que el de <code>D</code>. Los
parentesis no alteran el tipo, pero pueden cambiar la asociacion
de declaradores complejos.
</p>
</div>

<div id="outline-container-orgbc85c78" class="outline-5">
<h5 id="orgbc85c78">A8.6.1 Declaradores de apuntadores                               <a id="orgf99e5cb"></a></h5>
<div class="outline-text-5" id="text-orgbc85c78">
<p>
Es una declaracion <code>T D</code> en donde <code>D</code> tiene la forma
</p>

<div class="BLOCK">
<ul class="org-ul">
<li>lista-calificadores-de-tipo<sub>opt</sub> D1</li>
</ul>

</div>

<p>
y el tipo del identificador que esta en la declaracion <code>T D1</code> es
"modificador-de-lipo T", el tipo del identificador de <code>D</code> es
"modificador-de-tipo lista-calificadores-de-tipo apuntador a
T". Los calificadores que siguen al <code>*</code> se aplican al apuntador
en si, no al objeto al que apunta.
</p>

<p>
Por ejemplo, considere la declaracion,
</p>

<div class="org-src-container">
<pre class="src src-c"><span style="color: #98fb98;">int</span> *<span style="color: #eedd82;">ap</span>[];
</pre>
</div>

<p>
Aqui <code>ap[]</code> juega el papel de <code>D1</code>; una declaracion <code>int ap[]</code>
(mas abajo) dara a <code>ap</code> el tipo "arreglo de int", la lista
calificador-de-tipo esta vacia, y el modificador-de-lipo es
"arreglo de". Por consiguiente la declaracion da a <code>ap</code> el tipo
"arreglo de apuntadores a int".
</p>

<p>
Como otros ejemplos, las declaraciones
</p>

<div class="org-src-container">
<pre class="src src-c"><span style="color: #98fb98;">int</span> <span style="color: #eedd82;">i</span>, *<span style="color: #eedd82;">pi</span>, *<span style="color: #00ffff;">const</span> <span style="color: #eedd82;">cpi</span> = &amp;i;
<span style="color: #00ffff;">const</span> <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">ci</span> = 3, *<span style="color: #eedd82;">pci</span>;
</pre>
</div>

<p>
declaran un entero <code>i</code> y un apuntador a un entero <code>pi</code>. El valor
del apuntador constante <code>cpi</code> no puede ser cambiado; siempre
apunta a la misma localidad, aunque el valor al que se refiere
puede ser alterado. El entero <code>ci</code> es constante, y no se puede
cambiar (aunque si se puede inicializar, como aqui). El tipo de
<code>pci</code> es "apuntador a const int", y <code>pci</code> en si puede ser
modificada para apuntar a otro lugar, pero el valor al que apunta
no se puede alterar por asignacion a traves de <code>pci</code>.
</p>
</div>
</div>

<div id="outline-container-org0de1d95" class="outline-5">
<h5 id="org0de1d95">A8.6.2 Declaradores de arreglos                                  <a id="org5559ce9"></a></h5>
<div class="outline-text-5" id="text-org0de1d95">
<p>
En una declaracion <code>T D</code> donde <code>D</code> tiene la forma
</p>

<div class="BLOCK">
<p>
D1 [expresion-constante<sub>opt</sub>]
</p>

</div>

<p>
y el tipo del identificador en la declaracion <code>T D1</code> es
"modificador-de-tipo T", el tipo del identificador <code>D</code> es
"modificador-de-tipo arreglo de T". Si la expresion-constante
esta presente, debe ser de lipo entero, y con valor mayor que
<code>0</code>. Si se omite la expresion consianie que especifica el limite,
el arreglo tiene tipo incompleto.
</p>

<p>
Un arreglo se puede construir a partir de un tipo aritmetico, de
un apuntador, de una estructura o union o de otro arreglo (para
generar un arreglo de varias dimensiones). Cualquier tipo del
que se construya un arreglo debe ser completo; no debe ser un
arreglo o estructura de tipo incompleto. Esto implica que para
un arreglo multidimensional, solo se puede omitir la primera
dimension. El tipo de un objeto de tipo arreglo incompleto se
completa con otra declaracion para el objeto (<a href="#org4dc3299">A10.2</a>), completa
o por su inicializacion (<a href="#orgbe0450e">A8.7</a>). Por ejemplo,
</p>

<div class="org-src-container">
<pre class="src src-c"><span style="color: #98fb98;">float</span> <span style="color: #eedd82;">fa</span>[17], *<span style="color: #eedd82;">afp</span>[17];
</pre>
</div>

<p>
declara un arreglo de <code>float</code> y un arreglo de apuntadores a
<code>float</code>. Por otro lado,
</p>

<div class="org-src-container">
<pre class="src src-c"><span style="color: #00ffff;">static</span> <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">x3d</span>[3][5][7];
</pre>
</div>

<p>
declara un arreglo tridimensional estatico de enteros, con rango
<code>3 x 5 x 7</code> . Con todo detalle, <code>x3d</code> es un arreglo de tres
elementos; cada elemento es un arreglo de cinco arreglos; cada
uno de los ultimos arreglos es un arreglo de siete
enteros. Cualquiera de las expresiones <code>x3d</code>, <code>x3d[i]</code>,
<code>x3d[i][j]</code>, <code>x3d[i][j][k]</code> pueden aparecer razonablemente dentro
de una expresion. Los primeros tres tienen tipo "arreglo" y el
ultimo tiene tipo <code>int</code>. Mas especificamente, <code>x3d[i][j]</code> es un
arreglo de 7 enteros, y <code>x3d[i]</code> es un arreglo de 5 arreglos de 7
enteros.
</p>

<p>
La operacion de indexado de un arreglo esta definida de modo que
<code>E1[E2]</code> es identica a <code>*(E1+E2)</code>. Por lo tanto, fuera de su
apariencia asimetrica, la indexacion es una operacion
conmutativa. Debido a las reglas de conversion que se aplican a
<code>+</code> y a los arreglos (<a href="#orga91bc61">A6.6</a>, <a href="#orgd8413a7">A7.1</a>, <a href="#org3e54edb">A7.7</a>), si <code>E1</code> es un arreglo
y <code>E2</code> un entero, entonces <code>E1[E2]</code> se refiere al E2-esimo
miembro de <code>E1</code>.
</p>

<p>
En el ejemplo, <code>x3d[i][j][k]</code> es equivalente a <code>*(x3d[i][j] +
     k)</code>. La primera subexpresion <code>x3d[i][j]</code> se convierte (<a href="#orgd8413a7">A7.1</a>) al
tipo "apuntador a arreglo de enteros"; la adicion (<a href="#org3e54edb">A7.7</a>)
involucra multiplicacion por el tamaño de un entero. De las
reglas se sigue que los arreglos se almacenan por renglones (el
ultimo subindice varia mas rapido), y que el primer subindice
dentro de la declaracion ayuda a determinar la cantidad de
almacenamiento consumido por un arreglo, pero no tiene mas
utilidad en el calculo de subindices.
</p>
</div>
</div>

<div id="outline-container-org949d756" class="outline-5">
<h5 id="org949d756">A8.6.3 Declaracion de funciones                                  <a id="org0d15d1b"></a></h5>
<div class="outline-text-5" id="text-org949d756">
<p>
En una declaracion del nuevo estilo <code>T D</code>, donde <code>D</code> tiene la
forma
</p>

<pre class="example">
D1 (lista-tipos-de-parametro)
</pre>

<p>
y el tipo del identificador dentro de la declaracion <code>T D1</code> es
"modificador-de-tipo T", el tipo del identificador de <code>D</code> es
"modificador-de-tipo funcion con argumento
lista-tipos-de-parametros que regresa T".
</p>

<p>
La sintaxis de los parametros es
</p>

<div class="BLOCK">
<p>
lista-tipos-de-parametro:
  lista-de-parametros
  lista-de-parametros , &#x2026;
</p>

<p>
lista-de-parametros:
  declaracion-parametro
  lista-de-parametros , declaracion-parametro
</p>

<p>
declaracion-parametro:
  especificadores-de-declaracion declarador
  especificadores-de-declaracion declarador-abstracto-opt
</p>

</div>

<p>
En la declaracion del nuevo estilo, la lista de parametros
estipula los tipos de los parametros. Como un caso especial, el
declarador para una funcion del nuevo estilo sin parametros tiene
una lista de tipos de parametros consistente unicamente en la
palabra reservada <code>void</code>. Si la lista de tipos de parametros
finaliza con puntos suspensivos ", &#x2026;", entonces la funcion
puede aceptar mas argumentos que el numero de parametros
descritos explicitamente; ver <a href="#org2308e57">A7.3.2</a>.
</p>

<p>
Los tipos de parametros que son arreglos o funciones se alteran y
quedan como apuntadores, de acuerdo con las reglas para
conversiones de parametros; ver <a href="#orgd45046b">A10.1</a>. El unico especificador de
categoria de almacenamiento permitido dentro de un especificador
de declaracion de parametros es <code>register</code>, y este especificador
es ignorado a menos que el declarador de funcion encabece una
definicion de funcion. De modo semejante, si los declaradores que
estan en las declaraciones de parametros contienen
identificadores, y el declarador de funcion no encabeza una
definicion de funcion, los identificadores salen inmediatamente
del alcance. Los declaradores abstractos, que no mencionan a los
identificadores, se discuten en <a href="#orgfab544e">A8.8</a>.
</p>

<p>
En una declaracion de funcion del estilo anterior <code>T D</code>, donde
<code>D</code> tiene la forma
</p>

<div class="BLOCK">
<p>
D1(lista-de-identificadores<sub>opt</sub>)
</p>

</div>

<p>
y el tipo del identificador dentro de la declaracion <code>T D1</code> es
"modificador-de-tipo T", el tipo del identificador de <code>D</code> es
"modificador-de-tipo funcion de argumentos no especificados que
regresa T". Los parametros (si estan presentes) tienen la forma
</p>

<pre class="example">
lista-de-identificadores:
  identificador
  lista-de-identificadores , identificador
</pre>

<p>
En el declarador del estilo anterior, la lista de identificadores
debe estar ausente a menos de que el declarador se utilice en el
encabezador de una definicion de funcion (<a href="#orgd45046b">A10.1</a>). La declaracion
no proporciona ninguna informacion acerca de los tipos de los
parametros.
</p>

<p>
Por ejemplo, la declaracion
</p>

<div class="org-src-container">
<pre class="src src-c"><span style="color: #98fb98;">int</span> <span style="color: #87cefa;">f</span>(), *<span style="color: #87cefa;">fpi</span>(), (*<span style="color: #87cefa;">pfi</span>)();
</pre>
</div>

<p>
declara una funcion <code>f</code> que regresa un entero, una funcion <code>fpi</code>
que regresa un apuntador a un entero, y un apuntador <code>pfi</code> a una
funcion que regresa un entero. En ninguna de estas se especifica
la lista de parametros; estan en estilo anterior.
</p>

<p>
En una declaracion del nuevo estilo
</p>

<div class="org-src-container">
<pre class="src src-c"><span style="color: #98fb98;">int</span> <span style="color: #87cefa;">strcpy</span>(<span style="color: #98fb98;">char</span> *<span style="color: #eedd82;">dest</span>, <span style="color: #00ffff;">const</span> <span style="color: #98fb98;">char</span> *<span style="color: #eedd82;">source</span>), <span style="color: #87cefa;">rand</span>(<span style="color: #98fb98;">void</span>);
</pre>
</div>

<p>
<code>strcpy</code> es una funcion que regresa un <code>int</code>, con dos argumentos,
el primero es un apuntador a caracter y el segundo un apuntador a
caracteres constantes. Los nombres de los parametros son
realmente comentarios. La segunda funcion <code>rand</code> no emplea
argumentos y regresa <code>int</code>.
</p>

<div class="BLOOD">
<p>
Los declaradores de funciones con prototipos de parametros son,
con mucho, el cambio mas importante introducido al lenguaje por
el estandar ANSI. Ofrecen una ventaja sobre los declaradores
"del estilo anterior" de la primera edicion, proporcionando
deteccion de errores y conversion de argumentos entre llamadas
a funciones, pero a un costo; desorden y confusion durante su
introduccion, y la necesidad de permitir ambas formas. Se
requirieron algunas aberraciones sintacticas para
compatibilidad, como <code>void</code>, usado como una marca explicita de
las funciones sin parametros del nuevo estilo.
</p>

<p>
La notacion de puntos suspensivos ", &#x2026;" para funciones con
numero variable de argumentos tambien es nueva y, junto con las
macros en el header estandar <code>&lt;stdarg.h&gt;</code>, formaliza un
mecanismo que estuvo oficialmente prohibido pero
extraoficialmente permitido en la primera edicion.
</p>

<p>
Esas notaciones fueron adaptadas del lenguaje C++.
</p>

</div>
</div>
</div>
</div>

<div id="outline-container-org41627ce" class="outline-4">
<h4 id="org41627ce">A8.7 Inicializacion                                               <a id="orgbe0450e"></a></h4>
<div class="outline-text-4" id="text-org41627ce">
<p>
Cuando se declara un objeto, su declarador-init puede especificar
un valor inicial para el identificador que esta siendo
declarado. El inicializador es precedido por <code>=</code>, y es una
expresion o una lista de inicializadores anidados entre
llaves. Una lista puede terminar con coma, un buen detalle para un
formato claro.
</p>

<pre class="example">
inicializador:
  expresion-asignacion
  { lista-de-inicializadores }
  { lista-de-inicializadores ,}

lista-de-inicializadores:
  inicializador
  lista-de-inicializadores , inicializador
</pre>

<p>
Todas las expresiones del inicializador para un objeto o arreglo
estatico deben ser expresiones constantes tal como se describe en
<a href="#org9718d2e">A7.19</a>. Las expresiones en el inicializador para un objeto o
arreglo <code>auto</code> o <code>register</code> deben igualmente ser expresiones
constantes si el inicializador es una lista encerrada entre
llaves. Sin embargo, si el inicializador para un objeto automatico
es una expresion simple, no requiere ser una expresion constante,
sino que debe tener simplemente el tipo apropiado para la
asignacion al objeto.
</p>

<div class="BLOOD">
<p>
La primera edicion no aprobaba la inicializacion de estructuras
automaticas, uniones o arreglos. El estandar ANSI lo permite,
pero solo para construcciones constantes a menos de que el
inicializador se pueda expresar con una expresion simple.
</p>

</div>

<p>
Un objeto estatico no inicializado explicitamente se inicializa
como si a el (o a sus miembros) se le asigna la constante <code>0</code>. El
valor inicial de un objeto automatico que no este explicitamente
inicializado es indefinido.
</p>

<p>
El inicializador para un puntero o un objeto de tipo aritmetico es
un expresion simple, tal vez entre llaves. La expresion se asigna
al objeto.
</p>

<p>
El inicializador para un estructura es una expresion del mismo
tipo o una lista entre llaves de inicializadores para sus miembros
en orden.  Los miebros de campo de bits sin nombre se ignoran y no
se inicializan.  Si hay menos inicializadores que los miembros de
la estructura, los ultimos miembros son inicializados con <code>0</code>. No
puede haber mas inicializadores que miembros.
</p>

<p>
El inicializador para un arreglo es una lista de inicializadores
entre llaves para sus miembros. Si el arreglo tiene tamaño
desconocido, el numero de inicializadores determina el tamaño del
arreglo y su tipo se completa. Si el arreglo tiene tamaño fijo, el
numero de inicializadores no puede exceder al numero de miembros
del arreglo; si hay menos, los ultimos miembros son inicializados
con <code>0</code>.
</p>

<p>
Como caso especial, un arreglo de caracteres se puede inicializar
con una cadena literal; los caracteres sucesivos de la cadena
inicializan miembros sucesivos del arreglo. De modo semejante, una
literal de caracteres amplios (<a href="#org3acb960">A2.6</a>) puede inicializar un arreglo
de tipo <code>wchar_t</code>. Si el arreglo tiene tamaño desconocido, el
numero de caracteres en la cadena, incluyendo el caracter nulo de
terminacion, determina su tamaño; si su tamaño es fijo, el numero
de caracteres de la cadena, sin contar el caracter nulo de
terminacion, no debe exceder al tamaño del arreglo.
</p>

<p>
El inicializador para una union es una expresion simple del mismo
tipo o un inicializador entre llaves para el primer miembro de la
union.
</p>

<div class="BLOOD">
<p>
La primera edicion no permitia la inicializacion para
uniones. La regla del "primer miembro" es confusa, pero es
dificil generalizar sin la nueva sintaxis. Ademas de permitir
que las uniones sean inicializadas explicitamente, al menos en
una forma primitiva, esta regla ANSI vuelve definitiva la
semantica de uniones estaticas no inicializadas explicitamente.
</p>

</div>

<p>
Un <i>agregado</i> es una estructura o un arreglo. Si un agregado
contiene miembros de tipo agregado, las reglas de inicializacion
se aplican en forma recursiva. Las llaves pueden desaparecer de la
inicializacion como sigue: si el inicializador para un miembro
agregado que en si es un agregado inicia con una llave izquierda,
entonces la lisia de inicializadores separados por coma que sigue
inicializa los miembros del subagregado; es erroneo que haya mas
inicializadores que miembros. Sin embargo, si el inicializador
para un subagregado no inicia con una llave izquierda, entonces
solo se toman de la lista los elementos suficientes para los
miembros del subagregado; cualesquiera miembros restantes se dejan
para inicializar el siguiente miembro del agregado del cual el
subagregado es parte.
</p>

<p>
Por ejemplo,
</p>

<div class="org-src-container">
<pre class="src src-c"><span style="color: #98fb98;">int</span> <span style="color: #eedd82;">x</span>[] = { 1, 3, 5 };
</pre>
</div>

<p>
declara e inicializa <code>x</code> como un arreglo de una dimension con tres
miembros, puesto que no se ha especificado tamaño y existen tres
inicializadores.
</p>

<div class="org-src-container">
<pre class="src src-c"><span style="color: #98fb98;">float</span> <span style="color: #eedd82;">y</span>[4][3] = {
  { 1, 3, 5 },
  { 2, 4, 6 },
  { 3, 5, 7 },
};
</pre>
</div>

<p>
es una inicializacion completamente entre llaves: <code>1</code>, <code>3</code>, y <code>5</code>
inicializan la primera fila del arreglo <code>y[0]</code>, es decir
<code>y[0][0]</code>, <code>y[0][1]</code>, y <code>y[0][2]</code>. En igual forma, las siguientes
dos lineas inicializan <code>y[1]</code> y <code>y[2]</code>. El inicializador termina
antes y, por lo tanto, los elementos de <code>y[3]</code> son inicializados
con <code>0</code>. Precisamente el mismo efecto se puede obtener con
</p>

<div class="org-src-container">
<pre class="src src-c"><span style="color: #98fb98;">float</span> <span style="color: #eedd82;">y</span>[4][3] = {
  1, 3, 5, 2, 4, 6, 3, 5, 7
};
</pre>
</div>

<p>
El inicializador para <code>y</code> inicia con una llave izquierda, pero el
de <code>y[0]</code> no, por lo que se utilizan tres elementos de la
lista. De la misma forma los siguientes tres elementos de la lista
se toman sucesivamente para <code>y[1]</code> y despues <code>y[2]</code>. Tambien,
</p>

<div class="org-src-container">
<pre class="src src-c"><span style="color: #98fb98;">float</span> <span style="color: #eedd82;">y</span>[4][3] = {
  { 1 }, { 2 }, { 3 }, { 4 }
};
</pre>
</div>

<p>
inicializa la primera columna de <code>y</code> (considerado como un arreglo
bidimensional) y deja al resto en <code>0</code>.
</p>

<p>
Finalmente,
</p>

<div class="org-src-container">
<pre class="src src-c"><span style="color: #98fb98;">char</span> <span style="color: #eedd82;">msg</span>[ ] = <span style="color: #ffa07a;">"Error de sintaxis en linea %s\n"</span>;
</pre>
</div>

<p>
muestra un arreglo de caracteres cuyos miembros son inicializados
con una cadena; su tamaño incluye el caracter nulo de terminacion.
</p>
</div>
</div>

<div id="outline-container-org53c8312" class="outline-4">
<h4 id="org53c8312">A8.8 Nombres de tipos                                             <a id="orgfab544e"></a></h4>
<div class="outline-text-4" id="text-org53c8312">
<p>
Dentro de muchos contextos (para especificar las conversiones de
tipo explicitamente con un <i>cast</i>, para declarar tipos de
parametros en declaradores de funcion, y como un argumento de
<code>sizeof</code>) es necesario proporcionar el nombre de un tipo de
dato. Esto se logra utilizando un nombre de tipo, que
sintacticamente es una declaracion para un objeto de ese tipo,
omitiendo el nombre del objeto.
</p>

<div class="BLOCK">
<p>
nombre-de-tipo:
  lista-calificador-especificador declarador-abstracto<sub>opt</sub>
</p>

<p>
declarador-abstracto:
  apuntador
  apuntador<sub>opt</sub> declarador-abstracto-directo
</p>

<p>
declarador-abstracto-directo:
  ( declarador-abstracto )
  declarador-abstracto-directo<sub>opt</sub> [expresion-constante<sub>opt</sub>]
  declarador-abstracto-directo<sub>opt</sub> (lista-tipos-de-parametro<sub>opt</sub>)
</p>

</div>

<p>
Es posible identificar univocamente el lugar dentro del declarador
abstracto en donde podria aparecer el identificador si la
construccion fuera un declarador en una declaracion.  El tipo
nombrado es entonces el mismo que el tipo del identificador
hipotetico. Por ejemplo,
</p>

<div class="org-src-container">
<pre class="src src-c"><span style="color: #98fb98;">int</span>
<span style="color: #98fb98;">int</span>  *
<span style="color: #98fb98;">int</span>  *[3]
<span style="color: #98fb98;">int</span>  (*)[]
<span style="color: #98fb98;">int</span>  *()
<span style="color: #98fb98;">int</span>  (*[])(<span style="color: #98fb98;">void</span>)
</pre>
</div>

<p>
nombra respectivamente los tipos "entero", "apuntador a entero",
"arreglo de 3 apuntadores a enteros", "apuntador a un arreglo de
un numero no especificado de enteros", "funcion de parametros no
especificados que regresa un apuntador a entero" y "arreglo, de
tamaño no especificado, de apuntadores a funciones sin parametros
que regresa cada una un entero".
</p>
</div>
</div>

<div id="outline-container-orgdc2e07a" class="outline-4">
<h4 id="orgdc2e07a">A8.9 Typedef                                                      <a id="orgd1558a8"></a></h4>
<div class="outline-text-4" id="text-orgdc2e07a">
<p>
Las declaraciones cuyo especificador de categoria de
almacenamiento es <code>typedef</code> no declaran objetos; en lugar de ello
definen identificadores que nombran tipos. Esos identificadores se
llaman nombres <code>typedef</code>.
</p>

<pre class="example">
nombre-typedef:
  identificador
</pre>

<p>
Una declaracion <code>typedef</code> atribuye un tipo a cada nombre entre sus
declaradores en la forma usual (ver <a href="#org90b2ecc">A8.6</a> ). Luego de eso, cada
nombre <code>typedef</code> es sintacticamente equivalente a una palabra
reservada para especificador de tipo para el tipo asociado.
</p>

<p>
Por ejemplo, despues de
</p>

<div class="org-src-container">
<pre class="src src-c"><span style="color: #00ffff;">typedef</span> <span style="color: #98fb98;">long</span> <span style="color: #98fb98;">Blockno</span>, *<span style="color: #98fb98;">Blockptr</span>;
<span style="color: #00ffff;">typedef</span> <span style="color: #00ffff;">struct</span> { <span style="color: #98fb98;">double</span> <span style="color: #eedd82;">r</span>, <span style="color: #eedd82;">theta</span>; } <span style="color: #98fb98;">Complex</span>;
</pre>
</div>

<p>
las construcciones
</p>

<div class="org-src-container">
<pre class="src src-c"><span style="color: #98fb98;">Blockno</span> <span style="color: #eedd82;">b</span>;
<span style="color: #00ffff;">extern</span> <span style="color: #98fb98;">Blockptr</span> <span style="color: #eedd82;">bp</span>;
<span style="color: #98fb98;">Complex</span> <span style="color: #eedd82;">z</span>, *<span style="color: #eedd82;">zp</span>;
</pre>
</div>

<p>
son declaraciones legitimas. El tipo de <code>b</code> es <code>long</code>, el de <code>bp</code>
es "apuntador a long", y el de <code>z</code> es la estructura especificada;
<code>zp</code> es un apuntador a tal estructura.
</p>

<p>
<code>typedef</code> no introduce nuevos tipos, solo formas sinonimas para
tipos que se podrian mencionar en otra forma. En el ejemplo, <code>b</code>
tiene el mismo tipo que cualquier otro objeto <code>long</code>.
</p>

<p>
Los nombres <code>typedef</code> se pueden redeclarar dentro de un alcance
mas interno, pero se debe dar un conjunto no vacio de
especificadores de tipo. Por ejemplo,
</p>

<div class="org-src-container">
<pre class="src src-c"><span style="color: #00ffff;">extern</span> <span style="color: #98fb98;">Blockno</span>;
</pre>
</div>

<p>
no redeclara a <code>Blockno</code>, pero
</p>

<div class="org-src-container">
<pre class="src src-c"><span style="color: #00ffff;">extern</span> <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">Blockno</span>;
</pre>
</div>

<p>
si lo hace.
</p>
</div>
</div>

<div id="outline-container-orgf49346e" class="outline-4">
<h4 id="orgf49346e">A8.10 Equivalencia de tipo                                        <a id="org7b06413"></a></h4>
<div class="outline-text-4" id="text-orgf49346e">
<p>
Dos listas de especificadores de tipo son equivalentes si
contienen el mismo conjunto de especificadores de tipo, tomando en
cuenta que algunos especificadores pueden implicar otros (por
ejemplo, <code>long</code> solo implica <code>long int</code>). Estructuras, uniones, y
enumeraciones con etiquetas diferentes son distintas, y una union,
estructura, o enumeracion sin etiqueta estipula un tipo unico.
</p>

<p>
Dos tipos son el mismo si sus declaradores abstractos (<a href="#orgfab544e">A8.8</a>),
despues de expandir cualesquiera tipos <code>typedef</code> y de eliminar
cualesquiera identificadores de parametros de funcion, son las
mismas o equivalentes listas de especificadores de tipo. Los
tamaños de los arreglos y los parametros de las funciones son
significativos.
</p>
</div>
</div>
</div>

<div id="outline-container-orga3b0830" class="outline-3">
<h3 id="orga3b0830">A9   Proposiciones                                                 <a id="org05b632f"></a></h3>
<div class="outline-text-3" id="text-orga3b0830">
<p>
Excepto en donde asi se describe, las proposiciones se ejecutan en
secuencia. Las proposiciones que se ejecutan por sus efectos y no
tienen valores. Entran en varios grupos.
</p>

<pre class="example">
proposicion:
  proposicion-etiquetada
  proposicion-expresion
  proposicion-compuesta
  proposicion-de-seleccion
  proposicion-de-iteracion
  proposicion-de-salto
</pre>
</div>

<div id="outline-container-orgfec7bf8" class="outline-4">
<h4 id="orgfec7bf8">A9.1 Proposiciones etiquetadas                                    <a id="orgdc9fa98"></a></h4>
<div class="outline-text-4" id="text-orgfec7bf8">
<p>
Las proposiciones pueden tener etiquetas como prefijos.
</p>

<pre class="example">
proposicion-etiquetada:
  identificador: proposicion
  case expresion-constante : proposicion
  default : proposicion
</pre>

<p>
Una etiqueta consistente en un identificador declara al
identificador. El unico uso de una etiqueta identificadora es como
destino de un <code>goto</code>. El alcance del identificador esta dentro de
la funcion actual. Debido a que las etiquetas tienen su propio
espacio de nombre, no interfieren con otros identificadores y no
se pueden redeclarar. Vease <a href="#org5acc4e3">A11.1</a>.
</p>

<p>
Las etiquetas <code>case</code> y <code>default</code> se aplican con la proposicion
<code>switch</code> (<a href="#org84f90ed">A9.4</a>). La expresion constante del <code>case</code> debe tener
tipo entero.
</p>

<p>
Las etiquetas por si mismas no alteran el flujo de control.
</p>
</div>
</div>

<div id="outline-container-org53fd7c4" class="outline-4">
<h4 id="org53fd7c4">A9.2 Proposicion de expresion                                     <a id="org85bdff4"></a></h4>
<div class="outline-text-4" id="text-org53fd7c4">
<p>
La mayoria de las proposiciones son proposiciones de expresion,
que tienen la forma
</p>

<div class="BLOCK">
<p>
proposicion-expresion:
  expresion<sub>opt</sub>;
</p>

</div>

<p>
La mayoria de las proposiciones de expresion son asignaciones o
llamadas a funcion. Todos los efectos colaterales de la expresion
son completados antes de ejecutar la siguiente proposicion. Si la
expresion se omite, la construccion se llama proposicion nula; a
menudo se emplea para proporcionar un cuerpo vacio a una
proposicion de iteracion o para situar una etiqueta.
</p>
</div>
</div>

<div id="outline-container-org5fc4dce" class="outline-4">
<h4 id="org5fc4dce">A9.3 Proposicion compuesta                                        <a id="org8ed9206"></a></h4>
<div class="outline-text-4" id="text-org5fc4dce">
<p>
Para que se puedan utilizar varias proposiciones donde se espera
una, se proporciona la proposicion compuesta (tambien llamada
"bloque"). El cuerpo de una definicion de funcion es una
proposicion compuesta.
</p>

<div class="BLOCK">
<p>
proposicion-compuesta:
  { lista-declaracion<sub>opt</sub> lista-de-proposiciones<sub>opt</sub> }
</p>

<p>
lista-de-declaraciones:
  declaracion
  lista-de-declaraciones declaracion
</p>

<p>
lista-de-proposiciones:
  proposicion
  lista-de-proposiciones proposicion
</p>

</div>

<p>
Si un identificador dentro de la lista-de-declaraciones estuvo en
un alcance exterior al bloque, la declaracion mas externa se
suspende dentro del bloque (vease <a href="#org5acc4e3">A11.1</a>), despues de lo cual
continua. Un identificador se puede declarar solo una vez dentro
del mismo bloque. Estas reglas se aplican a identificadores dentro
del mismo espacio de nombre (<a href="#org73717e3">A11</a>); los identificadores dentro de
espacios de nombre diferentes son tratados como distintos.
</p>

<p>
La inicializacion de objetos automaticos se realiza cada vez que
se entra al bloque por la parte superior, y procede en el orden de
los declaradores. Si se ejecuta un salto dentro del bloque, estas
inicializaciones no se realizan. Las inicializaciones de objetos
<code>static</code> se realizan solo una vez, antes de que el programa comience
su ejecucion.
</p>
</div>
</div>

<div id="outline-container-orgc8462ca" class="outline-4">
<h4 id="orgc8462ca">A9.4 Proposiciones de seleccion                                   <a id="org84f90ed"></a></h4>
<div class="outline-text-4" id="text-orgc8462ca">
<p>
Las proposiciones de seleccion eligen uno de varios flujos de
control.
</p>

<div class="BLOCK">
<p>
proposicion-de-seleccion:
  <code>if</code> ( expresion ) proposicion
  <code>if</code> ( expresion ) proposicion <code>else</code> proposicion
  <code>switch</code> ( expresion ) proposicion
</p>

</div>

<p>
En ambas formas de la proposicion <code>if</code>, la expresion, que debe ser
aritmetica o de tipo apuntador, es evaluada, incluyendo todos los
efectos colaterales, y si se compara como diferente de <code>0</code>, se
ejecuta la primera subproposicion. En la segunda forma, la segunda
subproposicion se ejecuta si la expresion es <code>0</code>. La ambigüedad
del <code>else</code> se resuelve conectando un <code>else</code> con el ultimo <code>if</code> sin
<code>else</code> encontrado en el mismo nivel de anidamiento del bloque.
</p>

<p>
La proposicion <code>switch</code> provoca que el control sea transferido a
una de varias proposiciones, dependiendo del valor de una
expresion, que debe tener tipo entero. La subproposicion
controlada por un <code>switch</code> usualmente es compuesta. Cualquier
proposicion dentro de la subproposicion se puede etiquetar con una
o mas etiquetas <code>case</code> (<a href="#orgdc9fa98">A9.1</a>). La expresion de control tiene
promocion integral (<a href="#org68f9d95">A6.1</a>), y las constantes de los <code>case</code> son
convertidas al tipo promovido. No se permite que dos de las
expresiones <code>case</code> asociadas con el mismo <code>switch</code> puedan tener el
mismo valor despues de la conversion. Cuando mas puede haber una
etiqueta <code>default</code> asociada con un <code>switch</code>. Las proposiciones
<code>switch</code> pueden estar anidadas; una etiqueta <code>case</code> o <code>default</code>
esta asociada con el <code>switch</code> mas anidado que la contiene.
</p>

<p>
Cuando se ejecuta la proposicion <code>switch</code>, su expresion se evalua
incluyendo todos los efectos colaterales y es comparada con cada
constante del <code>case</code>. Si una de las constantes <code>case</code> es igual al
valor de la expresion, el control pasa a la proposicion de la
etiqueta <code>case</code> coincidente. Si ninguna-constante <code>case</code> coincide
con la expresion y si existe una etiqueta <code>default</code>, el control
pasa a la proposicion etiquetada. Si ningun caso coincide y no hay
<code>default</code>, entonces no se ejecuta ninguna de las subproposiciones
del <code>switch</code>.
</p>

<div class="BLOOD">
<p>
En la primera edicion de este libro, se requeria que la
expresion de control del <code>switch</code> y las constantes <code>case</code>
tuvieran tipo <code>int</code>.
</p>

</div>
</div>
</div>

<div id="outline-container-orgb22e815" class="outline-4">
<h4 id="orgb22e815">A9.5 Proposiciones de iteracion                                   <a id="org72104a1"></a></h4>
<div class="outline-text-4" id="text-orgb22e815">
<p>
Las proposiciones de iteracion especifican la ejecucion de un
ciclo.
</p>

<div class="BLOCK">
<p>
proposicion-de-iteracion:
  <code>while</code> ( expresion ) proposicion
  <code>do</code> proposicion <code>while</code> ( expresion ) ;
  <code>for</code> ( expresion<sub>opt</sub>; expresion<sub>opt</sub>; expresion<sub>opt</sub> ) proposicion
</p>

</div>

<p>
En las proposiciones <code>while</code> y <code>do</code>, la subproposicion se ejecuta
en forma repetida mientras que el valor de la expresion permanezca
diferente de <code>0</code>; la expresion debe tener tipo aritmetico o
apuntador. Con <code>while</code>, la prueba, incluyendo todos los efectos
colaterales de la expresion, ocurre antes de cada ejecucion de la
proposicion; con <code>do</code>, la prueba viene despues de cada iteracion.
</p>

<p>
En la proposicion <code>for</code>, la primera expresion se evalua una vez y
especifica la inicializacion para el ciclo. No hay restriccion en
cuanto a su tipo. La segunda expresion debe tener tipo aritmetico
o apuntador; se evalua antes de cada iteracion y, si es igual a
<code>0</code>, el <code>for</code> termina. La tercera expresion se evalua despues de
cada iteracion y especifica una reinicializacion para el ciclo. No
hay restriccion en cuanto a su tipo. Los efectos colaterales de
cada expresion se completan inmediatamente despues de su
evaluacion. Si la subproposicion no contiene <code>continue</code>, una
proposicion
</p>

<div class="BLOCK">
<p>
<code>for</code> ( expresion1; expresion2 ; expresion3 ) proposicion
</p>

</div>

<p>
es equivalente a
</p>

<div class="org-src-container">
<pre class="src src-c">expresion1;
<span style="color: #00ffff;">while</span> ( expresion2 ) {
  <span style="color: #98fb98;">proposicion</span>
  <span style="color: #eedd82;">expresion3</span> ;
}
</pre>
</div>

<p>
Cualquiera de las tres expresiones se puede descartar. La falta de
una segunda expresion hace que la prueba implicada sea equivalente
a probar una constante diferente de cero.
</p>
</div>
</div>

<div id="outline-container-org30500fb" class="outline-4">
<h4 id="org30500fb">A9.6 Proposiciones de salto                                       <a id="org6b6ca1a"></a></h4>
<div class="outline-text-4" id="text-org30500fb">
<p>
Las proposiciones de salto transfieren el control
incondicionalmente.
</p>

<div class="BLOCK">
<p>
proposicion-de-salto:
  <code>goto</code> identificador ;
  <code>continue</code>;
  <code>break</code>;
  <code>return</code> expresion<sub>opt</sub>;
</p>

</div>

<p>
En la proposicion <code>goto</code>, el identificador debe ser una etiqueta
(<a href="#orgdc9fa98">A9.1</a>) localizada en la funcion actual. El control se transfiere
a la proposicion etiquetada.
</p>

<p>
Una proposicion <code>continue</code> solo puede aparecer dentro de una
proposicion de iteracion, y ocasiona que el control pase a la
porcion de continuacion del ciclo mas anidado que encierra a tal
proposicion. En forma mas precisa, dentro de cada una de las
proposiciones
</p>

<pre class="example">
while (...) {       do {                    for (...) {
  ...                 ...                     ...
contin: ;           contin: ;               contin: ;
}                   } while ( ... ) ;       }
</pre>

<p>
un <code>continue</code> que no este contenido dentro de una proposicion de
iteracion mas anidada es lo mismo que <code>goto contin</code>.
</p>

<p>
Una proposicion <code>break</code> puede aparecer solo dentro de una
proposicion de iteracion o de una proposicion <code>switch</code>, y termina
la ejecucion de lo mas anidado que encierre tal proposicion; el
control pasa a la proposicion que sigue a la proposicion
terminada.
</p>

<p>
Una funcion regresa a quien la invoco con la proposicion
<code>return</code>. Cuando <code>return</code> es seguido por una expresion, el valor
se regresa al invocador de la funcion. La expresion se convierte,
como si se asignara, al tipo regresado por la funcion en la que
aparece.
</p>

<p>
Que el flujo llegue hasta el final de la funcion es equivalente a
un <code>return</code> sin expresion.  En cualquier caso, el valor regresado
esta indefinido.
</p>
</div>
</div>
</div>

<div id="outline-container-orgae35f9a" class="outline-3">
<h3 id="orgae35f9a">A10  Declaraciones externas                                        <a id="org2ee5a92"></a></h3>
<div class="outline-text-3" id="text-orgae35f9a">
<p>
La unidad de entrada proporcionada al compilador de C se llama
unidad de traduccion; consiste en una secuencia de declaraciones
externas, que son declaraciones o definiciones de funcion.
</p>

<pre class="example">
unidad-de-traduccion:
  declaracion-externa
  unidad-de-traduccion declaracion-externa

declaracion-externa:
  definicion-de-funcion
  declaracion
</pre>

<p>
El alcance de las declaraciones externas persiste hasta el final de
la unidad de traduccion en la que son declaradas, precisamente como
el efecto de las declaraciones dentro de los bloques persiste hasta
el final del bloque. La sintaxis de las declaraciones externas es
la misma que para todas las declaraciones, excepto que el codigo de
las funciones solo se puede dar en este nivel.
</p>
</div>

<div id="outline-container-org4ee0f62" class="outline-4">
<h4 id="org4ee0f62">A10.1 Definicion de funciones                                     <a id="orgd45046b"></a></h4>
<div class="outline-text-4" id="text-org4ee0f62">
<p>
Las definiciones de funciones tienen la forma
</p>

<div class="BLOCK">
<p>
definicion-de-funcion:
  especificadores-de-declaracion<sub>opt</sub> declarador lista-de-declaraciones<sub>opt</sub> proposicion-compuesta
</p>

</div>

<p>
Los unicos especificadores de categoria de almacenamiento
permitidos entre los especificadores de declaracion son <code>extern</code> o
<code>static</code>; vease <a href="#orgde38dea">A11.2</a> para la distincion entre ellos.
</p>

<p>
Una funcion puede regresar un tipo aritmetico, una estructura, una
union, un apuntador o <code>void</code>, pero no una funcion o un arreglo. El
declarador en la declaracion de una funcion debe especificar
explicitamente que el identificador declarado tiene tipo funcion;
esto es, debe contener una de las formas (vease <a href="#org0d15d1b">A8.6.3</a>)
</p>

<div class="BLOCK">
<p>
declarador-directo ( lista-tipos-de-parametros )
declarador-directo ( lista-de-identificadores<sub>opt</sub> )
</p>

</div>

<p>
donde el declarador-directo es un identificador o un identificador
con parentesis. En particular, no debe adquirir el tipo de funcion
por medio de un <code>typedef</code>.
</p>

<p>
En la primera forma, la definicion es una funcion en el estilo
nuevo, y sus parametros, junto con sus tipos, son declarados
dentro de su lista de tipos de parametros; la
lista-de-declaraciones que sigue al declarador de la funcion debe
estar ausente. Salvo que la lista de tipos de parametros consista
solamente en <code>void</code>, mostrando que la funcion no tiene parametros,
cada declarador que este en la lista de tipos de parametros debe
contener un identificador. Si la lista de tipos de parametros
termina con ", &#x2026;" entonces la funcion se puede llamar con mas
argumentos que parametros; para hacer referencia a los argumentos
extra se debe utilizar el mecanismo de la macro <code>va_arg</code> definido
en el header estandar <code>&lt;stdarg.h&gt;</code> y descrito en el <a href="#org89d4232">apendice B</a>.
Las funciones con numero variable de argumentos deben tener al
menos un parametro nombrado.
</p>

<p>
En la segunda forma, la definicion esta en el estilo anterior: la
lista de identificadores nombra los parametros, en tanto que la
lista de declaraciones les atribuye tipos. Si no se da ninguna
declaracion para un parametro, su tipo se toma como <code>int</code>. La
lista de declaraciones debe declarar solamente parametros
nombrados en la lista; no esta permitida la inicializacion y el
unico especificador de categoria de almacenamiento posible es
<code>register</code>.
</p>

<p>
En ambos estilos de definicion de funciones, se entiende que los
parametros seran declarados precisamente despues del principio de
la proposicion compuesta que constituye el cuerpo de la funcion y
no pueden ser redeclarados alli los mismos identificadores (aunque
podrian, como otros identificadores, ser redeclarados en bloques
mas internos). Si se declara que un parametro tendra tipo "arreglo
de tipo", la declaracion se ajusta para ser "apuntador a tipo"; de
manera semejante, si un parametro es declarado con tipo "funcion
que regresa tipo", la declaracion se ajusta como "apuntador a
funcion que regresa tipo".  Durante la llamada a una funcion, los
argumentos se convierten de acuerdo con las necesidades y son
asignados a los parametros; vease <a href="#org2308e57">A7.3.2</a>.
</p>

<div class="BLOOD">
<p>
La definicion de funciones en el nuevo estilo es nueva en el
estandar ANSI. Tambien hay un pequeño cambio en los detalles de
la promocion; la primera edicion estipula que las declaraciones
de parametros <code>float</code> se ajustaron para leerse <code>double</code>. La
diferencia es notoria cuando dentro de una funcion se genera un
apuntador a un parametro.
</p>

</div>

<p>
Un ejemplo completo de una funcion en el estilo nuevo es
</p>

<div class="org-src-container">
<pre class="src src-c"><span style="color: #98fb98;">int</span> <span style="color: #87cefa;">max</span>(<span style="color: #98fb98;">int</span> <span style="color: #eedd82;">a</span>, <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">b</span>, <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">c</span>)
{
  <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">m</span>;

  m = (a &gt; b) ? a : b;
  <span style="color: #00ffff;">return</span> (m &gt; c) ? m : c;
}
</pre>
</div>

<p>
Aqui <code>int</code> es el especificador de la declaracion; <code>max(int a, int
    b, int c)</code> es el declarador de la funcion, y <code>{ ... }</code> es el
bloque con el codigo para la funcion. La correspondiente
definicion en el estilo anterior seria
</p>

<div class="org-src-container">
<pre class="src src-c"><span style="color: #98fb98;">int</span> <span style="color: #87cefa;">max</span>(a, b, c)
<span style="color: #98fb98;">int</span> <span style="color: #eedd82;">a</span>, <span style="color: #eedd82;">b</span>, <span style="color: #eedd82;">c</span>;
{
  <span style="color: #ff4500;">/* </span><span style="color: #ff4500;">... </span><span style="color: #ff4500;">*/</span>
}
</pre>
</div>

<p>
donde ahora <code>int max(a, b, c)</code> es el declarador, e <code>int a, b, c;</code>
es la lista de declaraciones para los parametros.
</p>
</div>
</div>

<div id="outline-container-org9e89747" class="outline-4">
<h4 id="org9e89747">A10.2 Declaraciones externas                                      <a id="org4dc3299"></a></h4>
<div class="outline-text-4" id="text-org9e89747">
<p>
Las declaraciones externas estipulan las caracteristicas de
objetos, funciones y otros identificadores. El termino "externa"
se refiere a su localizacion fuera de las funciones, y no esta
directamente conectado con la palabra reservada <code>extern</code>; la
categoria de almacenamiento para un objeto declarado externamente
puede dejarse vacia, o se puede especificar como <code>extern</code> o
<code>static</code>.
</p>

<p>
Pueden existir muchas declaraciones externas para el mismo
identificador dentro de la misma unidad de traduccion si
corresponden con su tipo y enlazado, y si hay cuando mas una
definicion para el identificador.
</p>

<p>
Dos declaraciones para un objeto o funcion se hacen coincidir en
tipo bajo las reglas discutidas en <a href="#org7b06413">A8.10</a>. Ademas, si las
declaraciones difieren debido a que un tipo es una estructura,
union o enumeracion incompleta (<a href="#org8d2fe4a">A8.3</a>) y el otro es el tipo
completo correspondiente con la misma etiqueta, se considera que
los tipos coinciden. Mas aun, si uno es un tipo de arreglo
incompleto (<a href="#org5559ce9">A8.6.2</a>) y el otro es un tipo de arreglo completo, los
tipos, si por lo demas son identicos, tambien se consideran
coincidentes. Finalmente, si un tipo estipula una funcion en el
estilo anterior y el otro una funcion en el nuevo y por lo demas
identica, con declaracion de parametros, los tipos se toman como
coincidentes.
</p>

<p>
Si la primera declaracion externa para una funcion u objeto
incluye el especificador <code>static</code>, este tiene <i>enlazado interno</i>;
de otra manera tiene <i>enlazado externo</i>. El enlazado se discute en
<a href="#orgde38dea">A11.2</a>.
</p>

<p>
Una declaracion externa para un objeto es una definicion si tiene
inicializador. La declaracion de un objeto externo que no tiene
inicializador y no contiene el especificador declaracion de objeto
externo que no tiene un inicializador y no contiene al
especificador <code>extern</code>, es una <i>definicion tentativa</i>. Si en una
unidad de traduccion aparece una definicion para un objeto,
cualesquiera declaraciones tentativas se tratan simplemente como
declaraciones redundantes. Si no aparece ninguna definicion para
el objeto dentro de la unidad de traduccion, todas sus
definiciones tentativas se convierten en una sola definicion con
inicializador <code>0</code>.
</p>

<p>
Cada objeto debe tener exactamente una definicion. Para objetos
con enlace interno, esta regla se aplica en forma separada para
cada unidad de traduccion, debido a que los objetos ligados
internamente son unicos para una unidad de traduccion. Para
objetos con enlace externo se aplica al programa completo.
</p>

<div class="BLOOD">
<p>
Aunque la regla de una sola definicion esta formulada algo
diferente en la primera edicion de este libro, es en efecto
igual a la que se establece aqui. Algunas implantaciones la
aligeran, generalizando la idea de definicion tentativa. En la
formulacion alterna, que es comun en sistemas UNIX y reconocida
como una extension comun por el estandar, todas las definiciones
tentativas para un objeto ligado externamente, a traves de todas
las unidades de traduccion de un programa, se consideran juntas
en lugar de separadamente en cada unidad de traduccion. Si en
algun lugar del programa ocurre una definicion, entonces las
definiciones tentativas son simples declaraciones, pero si no
aparece ninguna definicion, entonces todas sus definiciones
tentativas se hacen definiciones con inicializador <code>0</code>.
</p>

</div>
</div>
</div>
</div>

<div id="outline-container-orgde37996" class="outline-3">
<h3 id="orgde37996">A11  Alcance y enlace                                              <a id="org73717e3"></a></h3>
<div class="outline-text-3" id="text-orgde37996">
<p>
No es necesario que un programa se compile todo a la vez: el texto
fuente se puede mantener en varios archivos con unidades de
traduccion, y se pueden cargar rutinas precompiladas de
bibliotecas. La comunicacion entre las funciones de un programa
puede llevarse a cabo tanto a traves de llamadas como a traves de
la manipulacion de datos externos.
</p>

<p>
Por tanto, existen dos clases de alcance a considerar: primera, el
<i>alcance lexico</i> de un identificador, que es la region del texto
del programa dentro de la que se entienden las caracteristicas del
identificador; y segunda, el alcance asociado con objetos y
funciones con liga externa, que determina la conexion entre
identificadores en unidades de traduccion compiladas por separado.
</p>
</div>

<div id="outline-container-org908a650" class="outline-4">
<h4 id="org908a650">A11.1 Alcance lexico                                              <a id="org5acc4e3"></a></h4>
<div class="outline-text-4" id="text-org908a650">
<p>
Los identificadores se dividen en varios espacios de nombre que no
interfieren entre si; el mismo identificador se puede utilizar
para diferentes propositos, incluso dentro del mismo alcance, si
los usos son en diferentes espacios de nombre. Estas categorias
son: objetos, funciones, nombres <code>typedef</code> y constantes <code>enum</code>;
etiquetas; rotulos de estructura, uniones y enumeraciones; y
miembros de cada estructura o union individualmente.
</p>

<div class="BLOOD">
<p>
Estas reglas difieren en varias formas de las descritas en la
primera edicion de este manual. Las etiquetas no tenian
anteriormente su propio espacio de nombre; los identificadores
de estructuras y de uniones tenian cada uno su espacio separado,
y en algunas implantaciones tambien lo teman los identificadores
de enumeraciones; colocar las diferentes clases de
identificadores en el mismo espacio es una nueva restriccion. El
mas importante alejamiento de la primera edicion es que cada
estructura o union crea un espacio de nombre separado para sus
miembros, de modo que en varias estructuras puede aparecer el
mismo nombre. Esta regla ha sido una practica comun por muchos
años.
</p>

</div>

<p>
El alcance lexico del identificador de un objeto o funcion dentro
de una declaracion externa inicia al final de su declarador y
persiste hasta el final de la unidad de traduccion en la que
aparece. El alcance del parametro de una definicion de funcion
comienza al inicio del bloque que define la funcion, y persiste a
traves de la funcion; el alcance de un parametro en la declarcion
de la funcion termina al final del declarador. El alcance de un
identificador declarado a la cabeza de un bloque inicia al final
de su declarador y persiste hasta el final del bloque. El alcance
de una etiqueta es la totalidad de la funcion en la cual
aparece. El alcance del identificador de una estructura, union o
enumeracion, o de una constante de enumeracion, inicia al aparecer
en un especificador de tipo y persiste hasta el final de la unidad
de traduccion (para declaraciones en el nivel externo) o hasta el
final del bloque (para declaraciones dentro de una funcion).
</p>

<p>
Si un identificador se declara explicitamente a la cabeza de un
bloque, incluyendo el que constituye a la funcion, cualquier
declaracion del identificador fuera del mismo bloque se suspende
hasta el final.
</p>
</div>
</div>

<div id="outline-container-orgf703a82" class="outline-4">
<h4 id="orgf703a82">A11.2 Enlace                                                      <a id="orgde38dea"></a></h4>
<div class="outline-text-4" id="text-orgf703a82">
<p>
Dentro de una unidad de traduccion, todas las declaraciones del
mismo identificador de objeto o funcion con enlace interno se
refieren a la misma cosa, y el objeto o funcion es unico para esa
unidad de traduccion. Todas las declaraciones para el mismo
identificador de objeto o funcion con enlace externo se refieren a
la misma cosa, y el objeto o funcion es compartido por todo el
programa.
</p>

<p>
Como se discutio en <a href="#org4dc3299">A10.2</a>, la primera declaracion externa para un
identificador da al identificador enlace inierno si se usa el
especificador <code>static</code>, de otra manera, le da enlace externo. Si
la declaracion para un identificador dentro de un bloque no
incluye el especificador <code>extern</code>, el identificador no tiene
enlace y es unico para la funcion. Si incluye <code>extern</code> y hay una
declaracion externa activa para el identificador dentro del
alcance que rodea al bloque, entonces el identificador tiene el
mismo enlace que la declaracion externa y se refiere al mismo
objeto o funcion; pero si no hay ninguna declaracion externa
visible, su enlace es externo.
</p>
</div>
</div>
</div>

<div id="outline-container-org32f3838" class="outline-3">
<h3 id="org32f3838">A12  Preprocesamiento                                              <a id="orgc912dbd"></a></h3>
<div class="outline-text-3" id="text-org32f3838">
<p>
Un preprocesador realiza macrosubstituciones, compilacion
condicional e inclusion de archivos nombrados. Las lineas que
inician con <code>#</code>, aunque esten precedidas por espacios en blanco, se
comunican con este preprocesador. La sintaxis de estas lineas es
independiente del resto del lenguaje; pueden aparecer en cualquier
lugar y su efecto termina (independientemente del alcance) hasta el
final de la unidad de traduccion. Los limites de las lineas son
significativos; cada linea se analiza individualmente (pero vease
<a href="#org1d3073b">A12.2</a> como unir lineas). Para el preprocesador, un <i>token</i> es un
<i>token</i> del lenguaje o una secuencia de caracteres que da un nombre
de archivo como en la directiva <code>#include</code> (<a href="#orge08afd9">A12.4</a>); ademas,
cualquier caracter que no este definido de otra manera se toma como
token. Sin embargo, el efecto de los caracteres espacio en blanco
que no sean espacio y tabulador horizontal esta definido dentro de
las lineas del preprocesador.
</p>

<p>
El preprocesamiento sucede en varias fases logicamente sucesivas
que, en una implantacion en particular, se pueden condensar.
</p>

<ol class="org-ol">
<li>Primero, las secuencias trigraficas que se describen en <a href="#org3e9aa75">A12.1</a>
son reemplazadas por sus equivalentes. De requerirlo el medio
ambiente del sistema operativo, se introducen caracteres nueva
linea entre las lineas del archivo fuente.</li>

<li>Cada ocurrencia de un caracter diagonal inversa <code>/</code> seguido por
una nueva linea se elimina, uniendo asi lineas (<a href="#org1d3073b">A12.2</a>).</li>

<li>El programa se divide en <i>tokens</i> separados por caracteres
espacio en blanco; los comentarios se reemplazan por un solo
espacio. Despues se obedecen las directivas de preprocesamiento,
y las macros (<a href="#org773f30e">A12.3</a>-<a href="#orgc86716a">A12.10</a>) se expanden.</li>

<li>Las secuencias de escape que estan dentro de caracteres y
cadenas literales constantes (<a href="#org4b66d10">A2.5.2</a>,<a href="#org3acb960">A2.6</a>) se reemplazan por sus
equivalentes; despues se concatenan las cadenas literales
adyacentes.</li>

<li>El resultado se traduce, despues se enlaza junto con otros
programas y bibliotecas, recolectando los programas y datos
necesarios y conectando las funciones y objetos externos con sus
definiciones.</li>
</ol>
</div>

<div id="outline-container-orge25fecd" class="outline-4">
<h4 id="orge25fecd">A12.1 Secuencias trigraficas                                      <a id="org3e9aa75"></a></h4>
<div class="outline-text-4" id="text-orge25fecd">
<p>
El conjunto de caracteres de los programas fuente de C esta
contenido dentro del codigo ASCII de siete bits, pero es un
superconjunto del <i>ISO 646-1983 Invariant Code Set</i>. Para poder
representar a los programas en el conjunto reducido, todas las
ocurrencias de las siguientes secuencias trigraficas se reemplazan
por el caracter simple correspondiente. Este reemplazo ocurre
antes de cualquier otro procesamiento.
</p>

<pre class="example">
??=   #         ??(   [         ??&lt;   {
??/   \         ??)   ]         ??&gt;   }
??'   ^         ??!   |         ??-   ~
</pre>

<p>
No ocurre ningun otro reemplazo.
</p>

<div class="BLOOD">
<p>
Las secuencias trigraficas son nuevas en el estandar ANSI.
</p>

</div>
</div>
</div>

<div id="outline-container-org9fa7879" class="outline-4">
<h4 id="org9fa7879">A12.2 Union de lineas                                             <a id="org1d3073b"></a></h4>
<div class="outline-text-4" id="text-org9fa7879">
<p>
Las lineas que terminan con el caracter diagonal invertida <code>/</code> se
empalman eliminando la diagonal inversa y el siguiente caracter
nueva linea. Esto ocurre antes de hacer la division en <i>tokens</i>.
</p>
</div>
</div>

<div id="outline-container-orge236d94" class="outline-4">
<h4 id="orge236d94">A12.3 Definicion y expansion de macros                            <a id="org773f30e"></a></h4>
<div class="outline-text-4" id="text-orge236d94">
<p>
Una linea de control de la forma
</p>

<div class="BLOCK">
<p>
<code># define</code> identificador secuencia-de-tokens
</p>

</div>

<p>
hace que el preprocesador reemplace las instancias subsecuentes
del identificador con la secuencia de <i>tokens</i> dada; se descartan
los espacios en blanco que se encuentran alrededor de la secuencia
de <i>tokens</i>. Un segundo <code># define</code> para el mismo identificador es
erroneo a menos que la segunda secuencia de <i>tokens</i> sea identica
a la primera, en donde todos los espacios en blanco se consideran
equivalentes.
</p>

<p>
Una linea de la forma
</p>

<div class="BLOCK">
<p>
<code># define</code> identificador( lista-de-identificadores ) secuencia-de-tokens
</p>

</div>

<p>
donde no hay espacio en blanco entre el primer identificador y el
<code>(</code>, es una macrodefinicion con parametros dados por la lista de
identificadores. Tal como la primera forma, los espacios en blanco
alrededor de la secuencia de <i>tokens</i> se descartan, y la macro
puede redefinirse solo con una definicion en la que el numero y
descripcion de parametros y la secuencia de <i>tokens</i> sea identica.
</p>

<p>
Una linea de control de la forma
</p>

<div class="BLOCK">
<p>
<code># undef</code> identificador
</p>

</div>

<p>
hace que el preprocesador olvide la definicion del identificador.
No es erroneo aplicar <code>#undef</code> a un identificador desconocido.
</p>

<p>
Cuando una macro se ha definido en la segunda forma, las
instancias textuales posteriores del identificador de la macro
seguidas por espacio en blanco optativo, y despues por <code>(</code>, una
secuencia de <i>tokens</i> separados por comas y un <code>)</code>, constituyen
una llamada a la macro.  Los argumentos de la llamada son las
secuencias de <i>tokens</i> separados por comas; las comas que se
encuentran entre comillas o protegidas por parentesis anidados no
separan argumentos. Durante la recoleccion los argumentos no son
macroexpandidos. El numero de argumentos en la llamada debe
coincidir con el numero de parametros en la definicion.  Despues
de que los argumentos se aislan, se remueven los espacios en
blanco que los inician y finalizan. Despues se substituye la
secuencia de <i>tokens</i> resultante de cada argumento por cada
ocurrencia no entrecomillada del identificador del parametro
correspondiente en la secuencia de reemplazo de <i>tokens</i> de la
macro. A menos de que el parametro en la secuencia de reemplazo
este precedido por <code>#</code>, o precedido o seguido por <code>##</code>, los
<i>tokens</i> argumentos se examinan para macro llamadas y se expanden
como sea necesario, justo antes de la insercion.
</p>

<p>
Dos operadores especiales influyen sobre el proceso de reemplazo.
Primero, si la ocurrencia de un parametro en la secuencia de
<i>tokens</i> de reemplazo esta precedida inmediatamente por <code>#</code>, se
colocan comillas (") alrededor del parametro correspondiente y
despues, tanto el <code>#</code> como el identificador del parametro, se
reemplazan por el argumento entrecomillado. Antes de cada caracter
<code>"</code> o <code>\</code> que aparezca alrededor o dentro de una cadena literal o
constante de caracter en el argumento, se inserta un caracter <code>\</code>.
</p>

<p>
Segundo, si la secuencia de definicion de <i>tokens</i> para cualquier
clase de macro contiene un operador <code>##</code>, entonces justo despues
del reemplazo de los parametros, se elimina cada <code>##</code>, junto con
cualquier espacio en blanco de ambos lados, para concatenar los
<i>tokens</i> adyacentes y formar uno nuevo. El efecto esta indefinido
si se producen <i>tokens</i> invalidos, o si el resultado depende del
orden de procesamiento de los operadores <code>##</code>. Ademas, <code>##</code> no
puede aparecer al principio o fin de una secuencia de <i>tokens</i> de
reemplazo.
</p>

<p>
En ambas clases de macro, la secuencia de reemplazo de <i>tokens</i> se
rastrea nuevamente en forma repetida, buscando mas definiciones de
identificadores. Sin embargo, una vez que un identificador dado ha
sido reemplazo en una expansion dada, no se reemplaza si se
encuentra nuevamente durante la busqueda, sino que permanece sin
cambio.
</p>

<p>
Aun cuando el valor final de una macroexpansion inicie con <code>#</code>, no
se toma como una directiva de preprocesamiento.
</p>

<div class="BLOOD">
<p>
Los detalles del proceso de la macroexpansion se describen en
forma mas precisa en el estandar ANSI que en la primera
edicion. El cambio mas importante es la adicion de los
operadores <code>#</code> y <code>##</code>, que hacen admisible el entrecomillado y
la concatenacion. Algunas de las nuevas reglas, especialmente
las que involucran concatenacion, son muy extrañas. (Veanse los
ejemplos siguientes.)
</p>

</div>

<p>
Por ejemplo, esto se puede utilizar para "constantes manifiestas",
como en
</p>

<div class="org-src-container">
<pre class="src src-c"><span style="color: #b0c4de;">#define</span> <span style="color: #eedd82;">TABSIZE</span> 100
<span style="color: #98fb98;">int</span> <span style="color: #eedd82;">table</span>[TABSIZE];
</pre>
</div>

<p>
La definicion
</p>

<div class="org-src-container">
<pre class="src src-c"><span style="color: #b0c4de;">#define</span> <span style="color: #eedd82;">ABSDIFF</span> (a, b) ((a)&gt;(b) ? (a)-(b) : (b)-(a))
</pre>
</div>

<p>
define una macro que regresa el valor absoluto de la diferencia
entre sus argumentos. A diferencia de la funcion que hace la misma
actividad, los argumentos y el tipo regresado pueden tener
cualquier tipo aritmetico o incluso ser apuntadores. Los
argumentos que pueden tener efectos colaterales son evaluados dos
veces, una para la prueba y otra para producir el valor.
</p>

<p>
Dada la definicion
</p>

<div class="org-src-container">
<pre class="src src-c"><span style="color: #b0c4de;">#define</span> <span style="color: #87cefa;">tempfile</span>(<span style="color: #eedd82;">dir</span>)     #dir <span style="color: #ffa07a;">"/%s"</span>
</pre>
</div>

<p>
la macro llamada <code>tempfile(/usr/tmp)</code> entrega
</p>

<div class="org-src-container">
<pre class="src src-c"><span style="color: #ffa07a;">"/usr/tmp"</span> <span style="color: #ffa07a;">"/%s"</span>
</pre>
</div>

<p>
que posteriormente se concatenara como una cadena
sencilla. Despues de
</p>

<div class="org-src-container">
<pre class="src src-c"><span style="color: #b0c4de;">#define</span> <span style="color: #87cefa;">cat</span>(<span style="color: #eedd82;">x</span>, <span style="color: #eedd82;">y</span>)   x ## y
</pre>
</div>

<p>
la llamada <code>cat(var, 123)</code> produce <code>varl23</code>. Sin embargo, la
llamada <code>cat(cat(1,2), 3))</code> esta indefinida: la presencia de <code>##</code>
impide que los argumentos de la llamada mas externa sean
expandidos. Asi se produce la cadena de <i>tokens</i>.
</p>

<div class="org-src-container">
<pre class="src src-c">cat ( 1 , 2 ) 3
</pre>
</div>

<p>
y <code>)3</code> (la union del ultimo <i>token</i> del primer argumento con el
primer <i>token</i> del segundo) no es un <i>token</i> legal. Si se
introduce un segundo nivel de macrodefinicion,
</p>

<div class="org-src-container">
<pre class="src src-c"><span style="color: #b0c4de;">#define</span> <span style="color: #87cefa;">xcat</span>(<span style="color: #eedd82;">x</span>, <span style="color: #eedd82;">y</span>)     cat(x,y)
</pre>
</div>

<p>
las cosas trabajan mas suavemente; <code>xcat(xcat(1, 2), 3)</code> produce
<code>123</code>, debido a que la expansion de <code>xcat</code> en si no involucra al
operador <code>##</code>.
</p>

<p>
En la misma forma, <code>ABSDIFF(ABSDIFF(a,b),c)</code> produce lo esperado,
un resultado completamente expandido.
</p>
</div>
</div>

<div id="outline-container-org5c48a81" class="outline-4">
<h4 id="org5c48a81">A12.4 Inclusion de archivos                                       <a id="orge08afd9"></a></h4>
<div class="outline-text-4" id="text-org5c48a81">
<p>
Una linea de control de la forma
</p>

<div class="org-src-container">
<pre class="src src-c"><span style="color: #b0c4de;"># include</span> <span style="color: #ffa07a;">&lt;nombre-de-archivo&gt;</span>
</pre>
</div>

<p>
ocasiona el reemplazo de esa linea por el contenido completo del
archivo <i>nombre-de-archivo</i>. Los caracteres del nombre
<i>nombre-de-archivo</i> no deben incluir <code>&gt;</code> o nueva linea y esta
indefinido el efecto si contiene <code>"</code>, <code>'</code>, <code>\</code> o <code>/*</code>. El archivo
nombrado se busca en una secuencia de lugares dependiendo de la
implantacion.
</p>

<p>
De modo semejante, una linea de control de la forma
</p>

<div class="org-src-container">
<pre class="src src-c"><span style="color: #b0c4de;"># include</span> <span style="color: #ffa07a;">"nombre-de-archivo"</span>
</pre>
</div>

<p>
busca primero en asociacion con el archivo fuente original (fase
deliberadamente dependiente de la implantacion), y si tal busqueda
falla, entonces lo hace como en la primera forma. El efecto de
usar <code>'</code>, <code>\</code>, o <code>/*</code> en el nombre del archivo permanece
indefinido, pero esta permitido <code>&gt;</code>.
</p>

<p>
Finalmente, una directiva de la forma
</p>

<div class="org-src-container">
<pre class="src src-c"><span style="color: #b0c4de;"># include</span> secuencia-de-tokens
</pre>
</div>

<p>
que no coincida con una de las formas previas se interpreta
expandiendo la secuencia de <i>tokens</i> como texto normal; debe
resultar una de las dos formas con <code>&lt;...&gt;</code> o <code>"..."</code>, y entonces
se trata como se describio anteriormente.
</p>

<p>
Los archivos <code>#include</code> pueden estar anidados.
</p>
</div>
</div>

<div id="outline-container-org46c0294" class="outline-4">
<h4 id="org46c0294">A12.5 Compilacion condicional                                     <a id="org3126499"></a></h4>
<div class="outline-text-4" id="text-org46c0294">
<p>
Parte de un programa se pueden compilar condicionalmente, de
acuerdo con la siguiente sintaxis esquematica.
</p>

<div class="BLOCK">
<p>
preprocesador-condicional:
  linea-if texto partes-elif parte-else<sub>opt</sub> #endif
</p>

<p>
linea-if:
</p>

<p>
partes-elif:
  linea-elif texto
  partes-elif<sub>opt</sub>
</p>

<p>
linea-elif:
</p>

<p>
parte-else:
  linea-else texto
</p>

<p>
linea-else:
  <code>#else</code>
</p>

</div>

<p>
Cada una de las directivas (linea-if, linea-elif, linea-else, y
<code>#endif</code>) aparece sola en una linea. Las expresiones constantes
que estan en <code>#if</code> y posteriores lineas <code>#elif</code> se evaluan en
orden hasta que se encuentra una expresion con valor diferente de
cero; el texto que sigue a una linea con valor cero se
descarta. El texto que sigue a una linea de directiva con exito se
trata normalmente. Aqui "texto" se refiere a cualquier material,
incluyendo lineas del preprocesador, que no es parte de la
estructura condicional; puede estar vacio. Una vez que se ha
encontrado una linca <code>#if</code> o <code>#elif</code> con exito y se ha procesado
su texto, las lineas <code>#elif</code> y <code>#else</code> que le siguen, junto con su
texto, se descartan. Si todas las expresiones son cero y hay un
<code>#else</code>, el texto que sigue al <code>#else</code> se trata normalmente. El
texto controlado por ramificaciones inactivas de la condicional se
ignora, excepto para verificar el anidamiento de condicionales.
</p>

<p>
La expresion constante en <code>#if</code> y <code>#elif</code> esta sujeta a
macroreemplazo ordinario. Ademas, cualesquier expresiones de la
forma
</p>

<div class="BLOCK">
<p>
<code>defined</code> identificador
</p>

</div>

<p>
o
</p>

<div class="BLOCK">
<p>
<code>defined</code> ( identificador )
</p>

</div>

<p>
se reemplazan, antes de buscar macros, por <code>1L</code> si el
identificador esta definido en el preprocesador y por <code>0L</code> si no
lo esta. Cualesquiera identificadores restantes despues de la
macroexpansion se reemplazan por <code>0L</code>. Finalmente, cada constante
entera se considera como con sufijo <code>L</code>, de modo que toda la
aritmetica se forma como <code>long</code> o <code>unsigned long</code>.
</p>

<p>
La expresion constante que resulta (<a href="#org9718d2e">A7.19</a>) esta restringida: debe
ser entera y no debe contener <code>sizeof</code>, o una constante de
enumeracion.
</p>

<p>
Las lineas de control
</p>

<div class="BLOCK">
<p>
<code>#ifdef</code> identificador
<code>#ifndef</code> identificador
</p>

</div>

<p>
son equivalentes a
</p>

<div class="BLOCK">
<p>
<code># if defined</code> identificador
<code># if ! defined</code> identificador
</p>

</div>

<p>
respectivamente.
</p>

<div class="BLOOD">
<p>
<code>#elif</code> es nueva desde la primera edicion aunque ha estado
disponible en algunos preprocesadores. El operador <code>defined</code> del
preprocesador tambien es nuevo.
</p>

</div>
</div>
</div>

<div id="outline-container-orgd738ab2" class="outline-4">
<h4 id="orgd738ab2">A12.6 Control de linea                                            <a id="org12c106e"></a></h4>
<div class="outline-text-4" id="text-orgd738ab2">
<p>
Para beneficio de otros preprocesadores que generan programas en
C, una linea en una de las formas
</p>

<div class="BLOCK">
<p>
<code># line</code> constante "nombre-de-archivo"
<code># line</code> constante
</p>

</div>

<p>
ocasiona que el compilador suponga, para propositos de diagnostico
de errores, que el numero de linea de la siguiente linea fuente
esta dado por la constante entera decimal, y que el archivo actual
de entrada esta nombrado por el ideniificador. Si el nombre de
archivo entrecomillado esta ausente, el nombre recordado no
cambia. Las macros de la linea son expandidas antes de ser
interpretadas.
</p>
</div>
</div>

<div id="outline-container-orgd547bc3" class="outline-4">
<h4 id="orgd547bc3">A12.7 Generacion de errores                                       <a id="org6ada54f"></a></h4>
<div class="outline-text-4" id="text-orgd547bc3">
<p>
Una linea del preprocesador de la forma
</p>

<div class="BLOCK">
<p>
<code># error</code> secuencia-de-tokens<sub>opt</sub>
</p>

</div>

<p>
ocasiona que el preprocesador escriba un mensaje de diagnostico
que incluye la secuencia de <i>tokens</i>.
</p>
</div>
</div>

<div id="outline-container-orgb514431" class="outline-4">
<h4 id="orgb514431">A12.8 Pragmas                                                     <a id="org557f44b"></a></h4>
<div class="outline-text-4" id="text-orgb514431">
<p>
Una linea de control de la forma
</p>

<div class="BLOCK">
<p>
<code># pragma</code> secuencia-de-tokens<sub>opt</sub>
</p>

</div>

<p>
ocasiona que el preprocesador realice una accion que depende de
la implantacion. Un <code>pragma</code> no reconocido es ignorado.
</p>
</div>
</div>

<div id="outline-container-orgfbc4db2" class="outline-4">
<h4 id="orgfbc4db2">A12.9 Directiva nula                                              <a id="orgcc34ab7"></a></h4>
<div class="outline-text-4" id="text-orgfbc4db2">
<p>
Una linea del preprocesador de la forma
</p>

<pre class="example">
#
</pre>

<p>
no tiene efecto.
</p>
</div>
</div>

<div id="outline-container-orga0fd96d" class="outline-4">
<h4 id="orga0fd96d">A12.10 Nombres predefinidos                                       <a id="orgc86716a"></a></h4>
<div class="outline-text-4" id="text-orga0fd96d">
<p>
Varios identificadores estan predefinidos, y se expanden para
producir informacion especial, ni ellos ni el operador de
expresion del preprocesador <code>defined</code>, pueden estar sin definicion
o redefinidos.
</p>

<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-left" />

<col  class="org-left" />
</colgroup>
<tbody>
<tr>
<td class="org-left"><code>__LINE__</code></td>
<td class="org-left">Constante decimal que contiene el numero de linea actual.</td>
</tr>

<tr>
<td class="org-left"><code>__FILE__</code></td>
<td class="org-left">Cadena literal que contiene el nombre del archivo que se esta compilando.</td>
</tr>

<tr>
<td class="org-left"><code>__DATE__</code></td>
<td class="org-left">Cadena literal que contiene la fecha de la compilacion, en la forma "Mmm dd yyyy".</td>
</tr>

<tr>
<td class="org-left"><code>__TIME__</code></td>
<td class="org-left">Cadena literal que contiene la hora de la compilacion, en la forma "hh:mm:ss".</td>
</tr>

<tr>
<td class="org-left"><code>__STDC__</code></td>
<td class="org-left">La constante <code>1</code>. Este identificador sera definido como <code>1</code> solo en implantaciones que conforman el estandar.</td>
</tr>
</tbody>
</table>

<div class="BLOOD">
<p>
<code>#error</code> y <code>#pragma</code> son nuevos con el estandar ANSI; las macros
predefinidas del preprocesador son nuevas, pero algunas de ellas
han estado disponibles en algunas implantaciones.
</p>

</div>
</div>
</div>
</div>

<div id="outline-container-org0b71afb" class="outline-3">
<h3 id="org0b71afb">A13  Gramatica                                                     <a id="orgbe6bcf9"></a></h3>
<div class="outline-text-3" id="text-org0b71afb">
<p>
A continuacion se encuentra una recapitulacion de la gramatica
expuesta a lo largo de la primera parte de este apendice. Tiene
exactamente el mismo contenido, pero se encuentra en diferente
orden.
</p>

<p>
La gramatica ha retirado la definicion a los simbolos terminales
<i>constante-entera</i>, <i>constante-de-caracter</i>, <i>constante-flotante</i>,
<i>identificador</i>, <i>cadena</i>, y <i>constante-enumeracion</i>; las palabras
en estilo <code>mecanografico</code> y los simbolos son terminales dadas
literalmente. La gramatica se puede transformar mecanicamente en
una entrada aceptable por un generador de parsers
automatico. Ademas de agregar alguna marca sintactica para indicar
alternativas en las producciones, es necesario expandir las
construcciones "uno de" y (dependiendo de las reglas del generador
de parsers) duplicar cada produccion con simbolo <i>opt</i>, una vez con
el simbolo y otra sin el. Con un cambio adicional, borrar la
produccion <i>nombre-typedef: identificador</i> y hacer a
<i>nombre-typedef</i> simbolo terminal, esta gramatica es aceptable para
el generador de parsers YACC . Solo tiene un conflicto, generado
por la ambigüedad del <code>if-else</code>.
</p>

<div class="BLOCK">
<p>
unidad-de-traduccion:
  declaracion-externa
  unidad-de-traduccion declaracion-externa
</p>

<p>
declaracion-externa:
  definicion-de-funcion
  declaracion
</p>

<p>
definicion-de-funcion:
  especificadores-de-declaracion<sub>opt</sub> declarador lista-de-declaraciones<sub>opt</sub> proposicion-compuesta
</p>

<p>
declaracion:
  especificadores-de-declaracion lista-declaradores-init<sub>opt</sub>;
</p>

<p>
lista-de-declaraciones:
  declaracion
  lista-de-declaraciones declaracion
</p>

<p>
especificadores-de-declaracion:
  especificador-categoria-almacenamiento especificadores-de-declaracion<sub>opt</sub>
  especificador-de-tipo especificadores-de-declaracion<sub>opt</sub>
  calificador-de-tipo especificadores-de-declaracion<sub>opt</sub>
</p>

<p>
especificador-categoria-almacenamiento: uno de
  <code>auto</code> <code>register</code> <code>static</code> <code>extern</code> <code>typedef</code>
</p>

<p>
especificador-de-tipo: uno de
  <code>void</code> <code>char</code> <code>short</code> <code>int</code> <code>long</code> <code>float</code> <code>double</code> <code>signed</code>
  <code>unsigned</code> especificador-estructura-union
  especificador-enum nombre-typedef
</p>

<p>
calificador-de-tipo: uno de
  <code>const</code> <code>volatile</code>
</p>

<p>
especificador-estructura-o-union:
  estructura-o-union identificador<sub>opt</sub> { lista-declaraciones-struct}
  estructura-o-union identificador
</p>

<p>
estructura-o-union: uno de
  <code>struct</code> <code>union</code>
</p>

<p>
lista-declaraciones-struct:
  declaracion-struct
  lista-declaraciones-struct declaracion-struct
</p>

<p>
lista-declaradores-init:
  declarador-init
  lista-declaradores-init , declarador-init
</p>

<p>
declarador-init:
  declarador
  declarador = inicializador
</p>

<p>
declaracion-struct:
  lista-calificador-especificador lista-declaradores-struct;
</p>

<p>
lista-calificador-especificador:
  especificador-de-tipo lista-calificador-especificador<sub>opt</sub>
  calificador-de-tipo lista-calificador-especificador<sub>opt</sub>
</p>

<p>
lista-declaradores-struct:
  declarador-struct
  lista-declaradores-struct , declarador-struct
</p>

<p>
declarador-struct:
  declarador
  declarador<sub>opt</sub> : expresion-constante
</p>

<p>
especificador-enum:
  <code>enum</code> identificador<sub>opt</sub> { lista-de-enumerador }
  <code>enum</code> identificador
</p>

<p>
lista-de-enumerador:
  enumerador
  lista-de-enumerador , enumerador
</p>

<p>
enumerador:
  identificador
  identificador = expresion-constante
</p>

<p>
declarador:
  apuntador<sub>opt</sub> declarador-directo
</p>

<p>
declarador-directo:
  identificador
  ( declarador )
  declarador-directo [ expresion-constante<sub>opt</sub> ]
  declarador-directo ( lista-tipos-de-parametro )
  declarador-directo ( lista-de-identificadores<sub>opt</sub> )
</p>

<p>
apuntador:
</p>
<ul class="org-ul">
<li>lista-calificadores-de-tipo<sub>opt</sub></li>
<li>lista-calificadores-de-tipo<sub>opt</sub> apuntador</li>
</ul>

<p>
lista-calificadores-de-tipo:
  calificador-de-tipo
  lista-calificadores-de-tipo calificador-de-tipo
</p>

<p>
lista-tipos-de-parametro:
  lista-de-parametros
  lista-de-parametros , &#x2026;
</p>

<p>
lista-de-parametros:
  declaracion-parametro
  lista-de-parametros , declaracion-parametro
</p>

<p>
declaracion-parametro:
  especificadores-de-declaracion declarador
  especificadores-de-declaracion declarador-abstracto<sub>opt</sub>
</p>

<p>
lista-de-identificadores:
  identificador
  lista-de-identificadores , identificador
</p>

<p>
inicializador:
  expresion-asignacion
  { lista-de-inicializadores }
  { lista-de-inicializadores , }
</p>

<p>
lista-de-inicializadores:
  inicializador
  lista-de-inicializadores , inicializador
</p>

<p>
nombre-de-tipo:
  lista-calificador-especificador declarador-abstracto<sub>opt</sub>
</p>

<p>
declarador-abstracto:
  apuntador
  apuntador<sub>opt</sub> declarador-abstracto-directo
</p>

<p>
declarador-abstracto-directo:
  ( declarador-abstracto )
  declarador-abstracto-directo<sub>opt</sub> [ expresion-constante<sub>opt</sub> ]
  declarador-abstracto-directo<sub>opt</sub> ( lista-tipos-de-parametro<sub>opt</sub> )
</p>

<p>
nombre-typedef:
  identificador
</p>

<p>
proposicion:
  proposicion-etiquetada
  proposicion-expresion
  proposicion-compuesta
  proposicion-de-seleccion
  proposicion-de-iteracion
  proposicion-de-salto
</p>

<p>
proposicion-etiquetada:
  identificador : proposicion
  <code>case</code> expresion-constante : proposicion
  <code>default</code> : proposicion
</p>

<p>
proposicion-expresion:
  expresion<sub>opt</sub>;
</p>

<p>
proposicion-compuesta:
  { lista-declaracion<sub>opt</sub> lista-de-proposiciones<sub>opt</sub> }
</p>

<p>
lista-de-proposiciones:
  proposicion
  lista-de-proposiciones proposicion
</p>

<p>
proposicion-de-seleccion:
  <code>if</code> ( expresion ) proposicion
  <code>if</code> ( expresion ) proposicion <code>else</code> proposicion
  <code>switch</code> ( expresion ) proposicion
</p>

<p>
proposicion-de-iteracion:
  <code>while</code> ( expresion ) proposicion
  <code>do</code> proposicion <code>while</code> ( expresion ) ;
  <code>for</code> ( expresion<sub>opt</sub>; expresion<sub>opt</sub>; expresion<sub>opt</sub> ) proposicion
</p>

<p>
proposicion-de-salto:
  <code>goto</code> identificador ;
  <code>continue</code>;
  <code>break</code>;
  <code>return</code> expresion<sub>opt</sub>;
</p>

<p>
expresion:
  expresion-de-asignacion
  expresion , expresion-de-asignacion
</p>

<p>
expresion-de-asignacion:
  expresion-condicional
  expresion-unaria operador-de-asignacion expresion-de-asignacion
</p>

<p>
operador-de-asignacion: uno de
  <code>=</code> <code>*=</code> <code>/=</code> <code>%=</code> <code>+=</code> <code>-=</code> <code>&gt;&gt;=</code> <code>&lt;&lt;=</code> <code>&amp;=</code> <code>^=</code>  <code>!=</code>
</p>

<p>
expresion-condicional:
  expresion-logica-OR
  expresion-logica-OR <code>?</code> expresion : expresion-condicional
</p>

<p>
expresion-constante:
  expresion-condicional
</p>

<p>
expresion-logica-OR:
  expresion-logica-AND
  expresion-logica-OR <code>||</code> expresion-logica-AND
</p>

<p>
expresion-logica-A ND:
  expresion-OR-inclusivo
  expresion-logica-AND <code>&amp;&amp;</code> expresion-OR-inclusivo
</p>

<p>
expresion-OR-inclusivo:
  expresion-OR-exclusivo
  expresion-OR-inclusivo <code>|</code> expresion-OR-exclusivo
</p>

<p>
expresion-OR-exclusivo:
  expresion-AND
  expresion-OR-exclusivo <code>^</code> expresion-AND
</p>

<p>
expresion-AND:
  expresion-de-igualdad
  expresion-AND <code>&amp;</code> expresion-de-igualdad
</p>

<p>
expresion-de-igualdad:
  expresion-relacional
  expresion-de-igualdad <code>==</code> expresion-relacional
  expresion-de-igualdad <code>!=</code> expresion-relacional
</p>

<p>
expresion-relacional:
  expresion-de-corrimiento
  expresion-relacional <code>&lt;</code> expresion-de-corrimiento
  expresion-relacional <code>&gt;</code> expresion-de-corrimiento
  expresion-relacional <code>&lt;=</code> expresion-de-corrimiento
  expresion-relacional <code>&gt;=</code> expresion-de-corrimiento
</p>

<p>
expresion-de-corrimiento:
  expresion-aditiva
  expresion-de-corrimiento <code>&lt;&lt;</code> expresion-aditiva
  expresion-de-corrimiento <code>&gt;&gt;</code> expresion-aditiva
</p>

<p>
expresion-aditiva:
  expresion-multiplicativa
  expresion-aditiva <code>+</code> expresion-multiplicativa
  expresion-aditiva <code>-</code> expresion-multiplicativa
</p>

<p>
expresion-multiplicativa:
  expresion-cast
  expresion-multiplicativa <code>*</code> expresion-cast
  expresion-multiplicativa <code>/</code> expresion-cast
  expresion multiplicativa <code>%</code> expresion-cast
</p>

<p>
expresion-cast:
  expresion-unaria
  ( nombre-de-tipo ) expresion-cast
</p>

<p>
expresion-unaria:
  expresion-posfija
  <code>++</code> expresion-unaria
  <code>--</code> expresion-unaria
  operador-unario expresion-cast
  <code>sizeof</code> expresion-unaria
  <code>sizeof</code> ( nombre-de-tipo )
</p>

<p>
operador-unario: uno de
  <code>&amp;</code> <code>*</code> <code>+</code> <code>-</code> <code>~</code> <code>!</code>
</p>

<p>
expresion-posfija:
  expresion-primaria
  expresion-posfija [ expresion ]
  expresion-posfija ( lista-de-expresiones-argumento<sub>opt</sub> )
  expresion-posfija . identificador
  expresion-posfija <code>-&gt;</code> identificador
  expresion-posfija <code>++</code>
  expresion-posfija <code>--</code>
</p>

<p>
expresion-primaria:
  identificador
  constante
  cadena
  ( expresion )
</p>

<p>
lista-expresiones-argumento:
  expresion-de-asignacion
  lista-expresiones-argumento , expresion-de-asignacion
</p>

<p>
constante:
  constante-entera
  constan te-de-caracter
  constante-flotante
  constante-enumeracion
</p>

</div>

<p>
La siguiente gramatica para el preprocesador resume la estructura
de las lineas de control, pero no es adecuada para un parser
mecanizado. Incluye el simbolo <i>text</i>, que es texto ordinario de
programa, lineas de control no condicionales del preprocesador, o
construcciones condicionales completas del preprocesador.
</p>

<div class="BLOCK">
<p>
linea de control:
</p>

<p>
preprocesador-condicional
</p>

<p>
preprocesador-condicional:
  linea-if texto partes-elif parte-else<sub>opt</sub> <code>#endif</code>
</p>

<p>
linea-if:
</p>

<p>
partes-elif:
  linea-elif texto
  partes-elif<sub>opt</sub>
</p>

<p>
linea-elif:
</p>

<p>
parte-else:
  linea-else texto
</p>

<p>
linea-else:
  <code>#else</code>
</p>

</div>
</div>
</div>
</div>

<div id="outline-container-org9270bdb" class="outline-2">
<h2 id="org9270bdb">Apendice B: Biblioteca estandar                                     <a id="org89d4232"></a></h2>
<div class="outline-text-2" id="text-org9270bdb">
<p>
Este apendice es un resumen de la biblioteca definida por el
estandar ANSI. La biblioteca estandar no es propiamente parte del
lenguaje C, pero un entorno que opere con C estandar proporcionara
las declaraciones y tipos de funciones y las macrodefiniciones de
esta biblioteca. Hemos omitido algunas funciones que son de utilidad
limitada o facilmente sintetizadas a partir de otras; tambien hemos
omitido caracteres de bytes multiples asi como la discusion de
cuestiones locales, esto es, propiedades que dependen del lenguaje
local, la nacionalidad o la cultura.
</p>

<p>
Las funciones, tipos y macros de la biblioteca estandar estan
declarados en <i>headers</i> estandar:
</p>

<div class="org-center">
<p>
&lt;assert.h&gt;    &lt;float.h&gt;     &lt;math.h&gt;      &lt;stdarg.h&gt;    &lt;stdlib.h&gt;
&lt;ctype.h&gt;     &lt;limits.h&gt;    &lt;setjmp.h&gt;    &lt;stddef.h&gt;    &lt;string.h&gt;
&lt;errno.h&gt;     &lt;locale.h&gt;    &lt;signal.h&gt;    &lt;stdio.h&gt;     &lt;time.h&gt;
</p>
</div>

<p>
Se puede tener acceso a un header por medio de
</p>

<div class="org-src-container">
<pre class="src src-c"><span style="color: #b0c4de;">#include</span> <span style="color: #ffa07a;">&lt;header&gt;</span>
</pre>
</div>

<p>
Los headers se pueden incluir en cualquier orden y numero de veces,
un header se debe incluir fuera de cualquier declaracion o
definicion externa y antes de cualquier uso de cualquier cosa que
declare. No es necesario que un header sea un archivo fuente.
</p>

<p>
Los identificadores externos que inician con subguion estan
reservados para uso de la biblioteca, como lo estan todos los otros
identificadores que inician con un subguion y una letra mayuscula u
otro subguion.
</p>
</div>

<div id="outline-container-org1189a3b" class="outline-3">
<h3 id="org1189a3b">B1   Entrada y salida: <code>&lt;stdio.h&gt;</code>                                 <a id="org89f43a0"></a></h3>
<div class="outline-text-3" id="text-org1189a3b">
<p>
Las funciones, tipos y macros de entrada y salida, definidos en
<code>&lt;stdio.h&gt;</code>, representan cerca de la tercera parte de la
biblioteca.
</p>

<p>
Un flujo (<i>stream</i>) es una fuente o destino de datos que puede
estar asociada con un disco u otro periferico. La biblioteca maneja
flujos de texto y flujos binarios, aunque en algunos sistemas,
notablemente UNIX, son identicos. Un flujo de texto es una
secuencia de lineas; cada linea tiene cero o mas caracteres y esta
terminada por '\n'. Un entorno puede necesitar convertir un flujo
de texto a alguna representacion, o de alguna otra representacion
(tal como la asociacion de '\n' a retorno de carro y avance de
linea). Un flujo binario es una secuencia de bytes no procesados
que representan datos internos, con la propiedad de que si es
escrito y despues leido de nuevo en el mismo sistema, sera
comparado como igual.
</p>

<p>
Un flujo se conecta a un archivo o dispositivo al <i>abrirlo</i>, la
conexion se rompe <i>cerrando</i> el flujo. El abrir un archivo regresa
un apuntador a un objeto de tipo <code>FILE</code>, que registra cualquier
informacion necesaria para controlar el flujo. Usaremos "apuntador
de archivo" y "flujo" indistintamente cuando no haya ambigüedad.
</p>

<p>
Cuando un programa inicia su ejecucion, los flujos <code>stdin</code>,
<code>stdout</code>, y <code>stderr</code> ya estan abiertos.
</p>
</div>

<div id="outline-container-orgada7b94" class="outline-4">
<h4 id="orgada7b94">B1.1 Operaciones sobre archivos                                   <a id="org18f477e"></a></h4>
<div class="outline-text-4" id="text-orgada7b94">
<p>
Las siguientes funciones tratan con operaciones sobre archivos. El
tipo <code>size_t</code> es el tipo entero sin signo producido por el
operador <code>sizeof</code>.
</p>
</div>

<div id="outline-container-org78288ea" class="outline-5">
<h5 id="org78288ea"><a id="orgd6dbcbe">=fopen=</a></h5>
<div class="outline-text-5" id="text-org78288ea">
<div class="org-src-container">
<pre class="src src-c"><span style="color: #98fb98;">FILE</span> *<span style="color: #87cefa;">fopen</span>(<span style="color: #00ffff;">const</span> <span style="color: #98fb98;">char</span> *<span style="color: #eedd82;">filename</span>, <span style="color: #00ffff;">const</span> <span style="color: #98fb98;">char</span> *<span style="color: #eedd82;">mode</span>)
</pre>
</div>

<p>
<a href="#orgd6dbcbe"><code>fopen</code></a> abre el archivo nombrado, y regresa un flujo, o <code>NULL</code> si
falla el intento. Los valores legitimos de <code>mode</code> incluyen:
</p>

<dl class="org-dl">
<dt>"r" </dt><dd>abre archivo de texto para lectura</dd>

<dt>"w" </dt><dd>crea archivo de texto para escritura; descarta el
contenido previo si existe</dd>

<dt>"a" </dt><dd>agrega; abre o crea un archivo para escribir al final</dd>

<dt>"r+"</dt><dd>abre archivo para actualizacion (esto es, lectura o
escritura)</dd>

<dt>"w+"</dt><dd>crea archivo de texto para actualizacion; descarta
cualquier contenido previo si existe</dd>

<dt>"a+"</dt><dd>agrega; abre o crea archivo de texto para
actualizacion, escribiendo al final</dd>
</dl>


<p>
El modo de actualizacion permite la lectura y escritura del mismo
archivo; entre una lectura y una escritura debe llamarse a
<a href="#orgd4f97b8"><code>fflush</code></a> o a una funcion de posicion o viceversa.  Si el modo
incluye <code>b</code> despues de la letra inicial, como en "rb" o "w+b",
indica que el archivo es binario. Los nombres de archivo estan
limitados a <code>FILENAME_MAX</code> caracteres. Cuando mas pueden ser
abiertos <code>FOPEN_MAX</code> archivos a la vez.
</p>
</div>
</div>

<div id="outline-container-org0bbbe2b" class="outline-5">
<h5 id="org0bbbe2b"><a id="orgc1d8ed1">=freopen=</a></h5>
<div class="outline-text-5" id="text-org0bbbe2b">
<div class="org-src-container">
<pre class="src src-c"><span style="color: #98fb98;">FILE</span> *<span style="color: #87cefa;">freopen</span>(<span style="color: #00ffff;">const</span> <span style="color: #98fb98;">char</span> *<span style="color: #eedd82;">filename</span>, <span style="color: #00ffff;">const</span> <span style="color: #98fb98;">char</span> *<span style="color: #eedd82;">mode</span>, <span style="color: #98fb98;">FILE</span> *<span style="color: #eedd82;">stream</span>)
</pre>
</div>

<p>
<a href="#orgc1d8ed1"><code>freopen</code></a> abre el archivo con el modo estipulado y asocia al
flujo con el. Regresa <code>stream</code>, o <code>NULL</code> si ocurre un error,
<a href="#orgc1d8ed1"><code>freopen</code></a> normalmete se usa para cambiar los archivos asociados
con <code>stdin</code>, <code>stdout</code> o <code>stderr</code>.
</p>
</div>
</div>

<div id="outline-container-orgd9ee5d7" class="outline-5">
<h5 id="orgd9ee5d7"><a id="orgd4f97b8">=fflush=</a></h5>
<div class="outline-text-5" id="text-orgd9ee5d7">
<div class="org-src-container">
<pre class="src src-c"><span style="color: #98fb98;">int</span> <span style="color: #87cefa;">fflush</span>(<span style="color: #98fb98;">FILE</span> *<span style="color: #eedd82;">stream</span>)
</pre>
</div>

<p>
Para un flujo de salida, <a href="#orgd4f97b8"><code>fflush</code></a> ocasiona que sea escrito
cualquier dato con uso de buffer que hasta ese momento no haya
sido escrito; para un flujo de entrada, el efecto esta
indefinido. Regresa <code>EOF</code> en caso de un error de escritura, y
cero en caso contrario. <code>fflush(NULL)</code> despeja todas las
corrientes de salida.
</p>
</div>
</div>

<div id="outline-container-org55e44e8" class="outline-5">
<h5 id="org55e44e8"><a id="orge0fc4f1">=fclose=</a></h5>
<div class="outline-text-5" id="text-org55e44e8">
<div class="org-src-container">
<pre class="src src-c"><span style="color: #98fb98;">int</span> <span style="color: #87cefa;">fclose</span>(<span style="color: #98fb98;">FILE</span> *<span style="color: #eedd82;">stream</span>)
</pre>
</div>

<p>
<a href="#orge0fc4f1"><code>fclose</code></a> descarga cualquier dato no escrito de <code>stream</code>, descarta
cualquier buffer de entrada no leido, libera cualquier buffer
asignado automaticamente, despues cierra el flujo. Regresa <code>EOF</code>
si ocurre cualquier error y cero en caso contrario.
</p>
</div>
</div>

<div id="outline-container-orgf182144" class="outline-5">
<h5 id="orgf182144"><a id="org7d045ee">=remove=</a></h5>
<div class="outline-text-5" id="text-orgf182144">
<div class="org-src-container">
<pre class="src src-c"><span style="color: #98fb98;">int</span> <span style="color: #87cefa;">remove</span>(<span style="color: #00ffff;">const</span> <span style="color: #98fb98;">char</span> *<span style="color: #eedd82;">filename</span>)
</pre>
</div>

<p>
<a href="#org7d045ee"><code>remove</code></a> remueve el archivo nombrado, de modo que un intento
posterior de abrirlo fallara. Regresa un valor diferente de cero
si el intento falla.
</p>
</div>
</div>

<div id="outline-container-org9d60bb3" class="outline-5">
<h5 id="org9d60bb3"><a id="org25254d1">=rename=</a></h5>
<div class="outline-text-5" id="text-org9d60bb3">
<div class="org-src-container">
<pre class="src src-c"><span style="color: #98fb98;">int</span> <span style="color: #87cefa;">rename</span>(<span style="color: #00ffff;">const</span> <span style="color: #98fb98;">char</span> *<span style="color: #eedd82;">oldname</span>, <span style="color: #00ffff;">const</span> <span style="color: #98fb98;">char</span> *<span style="color: #eedd82;">newname</span>)
</pre>
</div>

<p>
<a href="#org25254d1"><code>rename</code></a> cambia el nombre de un archivo; regresa un valor
diferente de cero si el intento falla.
</p>
</div>
</div>

<div id="outline-container-org840bbbe" class="outline-5">
<h5 id="org840bbbe"><a id="org7b256eb">=tmpfile=</a></h5>
<div class="outline-text-5" id="text-org840bbbe">
<div class="org-src-container">
<pre class="src src-c"><span style="color: #98fb98;">FILE</span> *<span style="color: #87cefa;">tmpfile</span>(<span style="color: #98fb98;">void</span>)
</pre>
</div>

<p>
<a href="#org7b256eb"><code>tmpfile</code></a> crea un archivo temporal con modo "wb+" que sera
removido automaticamente cuando se cierre o cuando el programa
termine normalmente. <a href="#org7b256eb"><code>tmpfile</code></a> regresa un flujo, o <code>NULL</code> si no
puede crear el archivo.
</p>
</div>
</div>

<div id="outline-container-org0f2df97" class="outline-5">
<h5 id="org0f2df97"><a id="orgd31135b">=tmpnam=</a></h5>
<div class="outline-text-5" id="text-org0f2df97">
<div class="org-src-container">
<pre class="src src-c"><span style="color: #98fb98;">char</span> *<span style="color: #87cefa;">tmpnam</span>(<span style="color: #98fb98;">char</span> <span style="color: #eedd82;">s</span>[L_tmpnam])
</pre>
</div>

<p>
<code>tmpnam(NULL)</code> crea una cadena que no es el nombre de un archivo
existente y regresa un apuntador a un arreglo estatico interno.
<code>tmpname(s)</code> almacena la cadena en <code>s</code> y tambien la regresa como
el valor de la funcion; <code>s</code> debe tener espacio suficiente para al
menos <code>L_tmpnam</code> caracteres, <a href="#orgd31135b"><code>tmpnam</code></a> genera un nombre diferente
cada vez que se invoca; cuando mas estan garantizados <code>TMP_MAX</code>
diferentes nombres durante la ejecucion del programa. Notese que
<a href="#orgd31135b"><code>tmpnam</code></a> crea un nombre, no un archivo.
</p>
</div>
</div>

<div id="outline-container-org6dc1748" class="outline-5">
<h5 id="org6dc1748"><a id="orgd4f3152">=setvbuf=</a></h5>
<div class="outline-text-5" id="text-org6dc1748">
<div class="org-src-container">
<pre class="src src-c"><span style="color: #98fb98;">int</span> <span style="color: #87cefa;">setvbuf</span>(<span style="color: #98fb98;">FILE</span> *<span style="color: #eedd82;">stream</span>, <span style="color: #98fb98;">char</span> *<span style="color: #eedd82;">buf</span>, <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">mode</span>, <span style="color: #98fb98;">size_t</span> <span style="color: #eedd82;">size</span>)
</pre>
</div>

<p>
<a href="#orgd4f3152"><code>setvbuf</code></a> controla el uso de buffer para el flujo; se debe
invocar antes de leer o escribir.  Un modo <code>_IOFBF</code> ocasiona uso
completo de buffers, <code>_IOLBF</code> uso de buffers por linea de archivo
de texto, e <code>_IONBF</code> ningun uso de buffer. Si <code>buf</code> no es <code>NULL</code>,
se empleara como el buffer, de otra manera sera asignado un
buffer. <code>size</code> determina su tamaño, <a href="#orgd4f3152"><code>setvbuf</code></a> regresa un valor
diferente de cero en caso de cualquier error.
</p>
</div>
</div>

<div id="outline-container-orgca68d5f" class="outline-5">
<h5 id="orgca68d5f"><a id="org819710d">=setbuf=</a></h5>
<div class="outline-text-5" id="text-orgca68d5f">
<div class="org-src-container">
<pre class="src src-c"><span style="color: #98fb98;">void</span> <span style="color: #87cefa;">setbuf</span>(<span style="color: #98fb98;">FILE</span> *<span style="color: #eedd82;">stream</span>, <span style="color: #98fb98;">char</span> *<span style="color: #eedd82;">buf</span>)
</pre>
</div>

<p>
Si <code>buf</code> es <code>NULL</code>, se suspende el uso de buffer para el
flujo. De otra manera, <a href="#org819710d"><code>setbuf</code></a> es equivalente a
</p>

<div class="org-src-container">
<pre class="src src-c">(<span style="color: #98fb98;">void</span>) <span style="color: #87cefa;">setvbuf</span>(stream, buf, _IOFBF, BUFSIZ);
</pre>
</div>
</div>
</div>
</div>

<div id="outline-container-org85879ae" class="outline-4">
<h4 id="org85879ae">B1.2 Salida con formato                                           <a id="org0c48ba3"></a></h4>
<div class="outline-text-4" id="text-org85879ae">
<p>
Las funciones <a href="#org0458a76"><code>printf</code></a> proporcionan conversiones de salida con
formato.
</p>
</div>

<div id="outline-container-org0240597" class="outline-5">
<h5 id="org0240597"><a id="org74b2389">=fprintf=</a></h5>
<div class="outline-text-5" id="text-org0240597">
<div class="org-src-container">
<pre class="src src-c"><span style="color: #98fb98;">int</span> <span style="color: #87cefa;">fprintf</span>(<span style="color: #98fb98;">FILE</span> *<span style="color: #eedd82;">stream</span>, <span style="color: #00ffff;">const</span> <span style="color: #98fb98;">char</span> *<span style="color: #eedd82;">format</span>, ...)
</pre>
</div>

<p>
<a href="#org74b2389"><code>fprintf</code></a> toma una salida y la convierte y escribe hacia el
<code>stream</code> bajo el control de <code>format</code>. El valor regresado es el
numero de caracteres escritos, o un valor negativo si ocurrio
algun error.
</p>

<p>
La cadena de formato contiene dos tipos de objetos: caracteres
ordinarios, que son copiados al flujo de salida, y
especificaciones de conversion, cada uno de los cuales provoca la
conversion e impresion de los siguientes argumentos sucesivos de
<a href="#org74b2389"><code>fprintf</code></a>. Cada especificacion de conversion inicia con el
caracter <code>%</code> y termina con un caracter de conversion. Entre el
<code>%</code> y el caracter de conversion puede haber, en orden:
</p>

<ul class="org-ul">
<li>Banderas (en cualquier orden), que modifican la
especificacion:

<ul class="org-ul">
<li><code>-</code>, que especifica ajuste del argumento convertido hacia
la izquierda dentro de su campo.</li>

<li><code>+</code>, que estipula que el numero siempre sera impreso con
signo.</li>

<li><i>espacio</i>: si el primer caracter no es un signo, se
prefijara un espacio.</li>

<li><code>0</code>: para conversion numerica, estipula rellenado con ceros
iniciales de la totalidad del campo.</li>

<li><code>#</code>, que estipula una forma alterna de salida. Para <code>o</code>, el
primer digito sera cero. Para <code>x</code> o <code>X</code>, cualquier resultado
diferente de cero sera prefijado con <code>0x</code> o <code>0X</code>. Para <code>e</code>,
<code>E</code>, <code>i</code>, <code>g</code>, y <code>G</code>, la salida siempre tendra un punto
decimal; para <code>g</code> y <code>G</code>, los ceros acarreados no seran
removidos.</li>
</ul></li>

<li>Un numero que estipula un ancho minimo de campo. El argumento
convertido sera impreso en un campo de por lo menos esta
amplitud, y en una mayor si es necesario. Si el argumento
convertido tiene menos caracteres que el ancho de campo, sera
rellenado a la izquierda (o derecha, si se ha requerido
justificacion a la izquierda) para completar el ancho de
campo. El caracter de relleno normalmente es espacio, pero es
<code>0</code> si esta presente la bandera de relleno con ceros.</li>

<li>Un punto, que separa el ancho de campo de la precision.</li>

<li>Un numero, la precision, que estipula el numero maximo de
caracteres de una cadena que seran impresos, o el numero de
digitos que seran impresos despues del punto decimal para
converciones <code>e</code>, <code>E</code>, o <code>i</code>, o el numero de digitos
significativos para conversiones <code>g</code> o <code>G</code>, o el numero minimo
digitos que seran impresos para un entero (seran agregados
ceros al principio para completar el ancho de campo necesario).</li>

<li>Un modificador de longitud <code>h</code>, <code>l</code> (letra ele), o <code>L</code>. "h"
indica que el argumento correspondiente va a ser impreso como
<code>short</code> o <code>unsigned short</code>; "l" indica que el argumento es
<code>long</code> o <code>unsigned long</code>; "L" indica que el argumento es <code>long
       double</code>.</li>
</ul>


<p>
Con <code>*</code> se puede especificar la amplitud o precision, o ambas, en
tal caso el valor se calcula convirtiendo el (los) siguiente(s)
argumento(s), que debe(n) ser <code>int</code>.
</p>

<p>
Los caracteres de conversion y sus significados se muestran en la
<a href="#org2d234b2">tabla B-1</a>. Si el caracter que esta despues del <code>%</code> no es un
caracter de conversion, el comportamiento esta indefinido.
</p>


<dl class="org-dl">
<dt><a id="org2d234b2">TABLA B-1</a></dt><dd><p>
CONVERSIONES DE PRINTF
</p>

<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-left" />

<col  class="org-left" />
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">CARACTER</th>
<th scope="col" class="org-left">TIPO DE ARGUMENTO; CONVERTIDO A</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left">d, i</td>
<td class="org-left"><code>int</code>; notacion decimal con signo,</td>
</tr>

<tr>
<td class="org-left">o</td>
<td class="org-left"><code>int</code>; notacion octal sin signo (sin ceros al principio)</td>
</tr>

<tr>
<td class="org-left">x, X</td>
<td class="org-left"><code>int</code>; notacion hexadecimal sin signo (sin <code>0x</code> o <code>0X</code> al principio), utilizando <code>abcdef</code> para <code>0x</code> o <code>ABCDEF</code> para <code>0X</code>.</td>
</tr>

<tr>
<td class="org-left">u</td>
<td class="org-left"><code>int</code>; notacion decimal sin signo.</td>
</tr>

<tr>
<td class="org-left">c</td>
<td class="org-left"><code>int</code>; caracter sencillo, despues de la conversion a <code>unsigned char</code>.</td>
</tr>

<tr>
<td class="org-left">s</td>
<td class="org-left"><code>char *</code>; los caracteres de la cadena son impresos hasta que se alcanza un '\0' o hasta que ha sido impreso el numero de caracteres indicados por la precision.</td>
</tr>

<tr>
<td class="org-left">l</td>
<td class="org-left"><code>double</code>; notacion decimal de la forma <i>[-]mmm.ddd</i>, en donde el numero de <i>d</i> es especificado por la precision. La precision por omision es <code>6</code>; una precision <code>0</code> suprime el punto decimal.</td>
</tr>

<tr>
<td class="org-left">e,E</td>
<td class="org-left"><code>double</code>; notacion decimal de la forma <i>[-]m.dddddde±xx</i> o <i>[-]m.ddddddE±xx</i>, en donde el numero de <i>d</i> esta especificado por la precision. La precision por omision es <code>6</code>; una precision <code>0</code> suprime el punto decimal.</td>
</tr>

<tr>
<td class="org-left">g,G</td>
<td class="org-left"><code>double</code>; se usa <code>%e</code> o <code>%E</code> si el exponente es menor que <code>-4</code> o mayor o igual que la precision; de otra forma es usado <code>%f</code>. Los ceros y el punto decimal al final no son impresos.</td>
</tr>

<tr>
<td class="org-left">p</td>
<td class="org-left"><code>void *</code>; imprime como un apuntador (representacion dependiente de la implantacion).</td>
</tr>

<tr>
<td class="org-left">n</td>
<td class="org-left"><code>int *</code>; el numero de caracteres escritos hasta el momento por esta llamada a <a href="#org0458a76"><code>printf</code></a> es escrito en el argumento. No es convertido ningun argumento.</td>
</tr>

<tr>
<td class="org-left">%</td>
<td class="org-left">No es convertido ningun argumento; se imprime como <code>%</code>.</td>
</tr>
</tbody>
</table></dd>
</dl>
</div>
</div>

<div id="outline-container-org5e1c949" class="outline-5">
<h5 id="org5e1c949"><a id="org0458a76">=printf=</a></h5>
<div class="outline-text-5" id="text-org5e1c949">
<div class="org-src-container">
<pre class="src src-c"><span style="color: #98fb98;">int</span> <span style="color: #87cefa;">printf</span>(<span style="color: #00ffff;">const</span> <span style="color: #98fb98;">char</span> *<span style="color: #eedd82;">format</span>, ... )
</pre>
</div>

<p>
<code>printf(...)</code> es equivalente a <code>fprintf(stdout, ...)</code>.
</p>
</div>
</div>

<div id="outline-container-org93e4bac" class="outline-5">
<h5 id="org93e4bac"><a id="org44a4902">=sprintf=</a></h5>
<div class="outline-text-5" id="text-org93e4bac">
<div class="org-src-container">
<pre class="src src-c"><span style="color: #98fb98;">int</span> <span style="color: #87cefa;">sprintf</span>(<span style="color: #98fb98;">char</span> *<span style="color: #eedd82;">s</span>, <span style="color: #00ffff;">const</span> <span style="color: #98fb98;">char</span> *<span style="color: #eedd82;">format</span>, ... )
</pre>
</div>

<p>
<a href="#org44a4902"><code>sprintf</code></a> es lo mismo que <a href="#org0458a76"><code>printf</code></a> excepto que la salida es
escrita en la cadena <code>s</code>, terminada con '\0'. <code>s</code> debe ser
suficientemente grande para contener el resultado. La cuenta
regresada no incluye el '\0'.
</p>
</div>
</div>

<div id="outline-container-orgb858b18" class="outline-5">
<h5 id="orgb858b18"><a id="org4a030f4">=vprintf=</a></h5>
</div>
<div id="outline-container-orgd511460" class="outline-5">
<h5 id="orgd511460"><a id="org6018dca">=vfprintf=</a></h5>
</div>
<div id="outline-container-org12ee179" class="outline-5">
<h5 id="org12ee179"><a id="orgd1c58d2">=vsprintf=</a></h5>
<div class="outline-text-5" id="text-org12ee179">
<div class="org-src-container">
<pre class="src src-c"><span style="color: #87cefa;">vprintf</span>(<span style="color: #00ffff;">const</span> <span style="color: #98fb98;">char</span> *<span style="color: #eedd82;">format</span>, <span style="color: #98fb98;">valist</span> <span style="color: #eedd82;">arg</span>)
</pre>
</div>

<div class="org-src-container">
<pre class="src src-c"><span style="color: #87cefa;">vfprintf</span>(<span style="color: #98fb98;">FILE</span> *<span style="color: #eedd82;">stream</span>, <span style="color: #00ffff;">const</span> <span style="color: #98fb98;">char</span> *<span style="color: #eedd82;">format</span>, <span style="color: #98fb98;">va_list</span> <span style="color: #eedd82;">arg</span>)
</pre>
</div>

<div class="org-src-container">
<pre class="src src-c"><span style="color: #87cefa;">vsprintf</span>(<span style="color: #98fb98;">char</span> *<span style="color: #eedd82;">s</span>, <span style="color: #00ffff;">const</span> <span style="color: #98fb98;">char</span> *<span style="color: #eedd82;">format</span>, <span style="color: #98fb98;">va_list</span> <span style="color: #eedd82;">arg</span>)
</pre>
</div>

<p>
Las funciones <a href="#org4a030f4"><code>vprintf</code></a>, <a href="#org6018dca"><code>vfprintf</code></a>, y <a href="#orgd1c58d2"><code>vsprintf</code></a> son
equivalentes a las correspondientes funciones <a href="#org0458a76"><code>printf</code></a>, excepto
que la lista variable de argumentos es remplazada por <code>arg</code>, que
ha sido inicializado por la macro <code>va_start</code> y tal vez llamadas a
<code>va_arg</code>. Vease la exposicion de <code>&lt;stdarg.h&gt;</code> en la seccion <a href="#org34ff186">B7</a>.
</p>
</div>
</div>
</div>

<div id="outline-container-orgd054f48" class="outline-4">
<h4 id="orgd054f48">B1.3 Entrada con formato                                          <a id="orgbd30cf0"></a></h4>
<div class="outline-text-4" id="text-orgd054f48">
<p>
Las funciones <a href="#orgb47aa6e"><code>scanf</code></a> tratan con la conversion de entrada con
formato.
</p>
</div>

<div id="outline-container-org51de28c" class="outline-5">
<h5 id="org51de28c"><a id="org871b649">=fscanf=</a></h5>
<div class="outline-text-5" id="text-org51de28c">
<div class="org-src-container">
<pre class="src src-c"><span style="color: #98fb98;">int</span> <span style="color: #87cefa;">fscanf</span>(<span style="color: #98fb98;">FILE</span> *<span style="color: #eedd82;">stream</span>, <span style="color: #00ffff;">const</span> <span style="color: #98fb98;">char</span> *<span style="color: #eedd82;">format</span>, ... )
</pre>
</div>

<p>
<a href="#org871b649"><code>fscanf</code></a> lee del <code>stream</code> bajo el control de <code>format</code>, y asigna
los valores convertidos a traves de argumentos subsecuentes,
<i>cada uno de los cuales debe ser un apuntador</i>. Regresa cuando
<code>format</code> se ha agotado, <a href="#org871b649"><code>fscanf</code></a> regresa <code>EOF</code> si se encuentra
fin de archivo o un error antes de la conversion; de otra forma
regresa el numero de articulos de entrada convertidos y
asignados.
</p>

<p>
La cadena de formato generalmente contiene especificaciones de
conversion, que son utilizadas para dirigir la interpretacion de
la entrada. La cadena de formato puede contener:
</p>

<ul class="org-ul">
<li>Blancos o tabuladores, que son ignorados.</li>

<li>Caracteres ordinarios (no <code>%</code>), que se espera coincidan con
los siguientes caracteres que no son espacio en blanco del
flujo de entrada.</li>

<li>Especificaciones de conversion, consistentes en <code>%</code>, un
caracter optativo de supresion de asignacion <code>*</code>, un numero
optativo que especifica una amplitud maxima de campo, una <code>h</code>,
<code>l</code> o <code>L</code> optativa que indica la amplitud del objetivo, y un
caracter de conversion.</li>
</ul>


<p>
Una especificacion de conversion determina la conversion del
siguiente campo de entrada. Normalmente el resultado es situado
en la variable apuntada por el argumento correspondiente. Sin
embargo, si se indica supresion de asignacion con <code>*</code>, como en
<code>%*s</code>, el campo de entrada simplemente se salta; no se hace
asignacion. Un campo de entrada esta definido por una cadena de
caracteres diferentes de espacio en blanco; se extiende hasta el
siguiente caracter de espacio en blanco o hasta que se ha agotado
el ancho de campo, si esta especificado. Esto implica que <a href="#orgb47aa6e"><code>scanf</code></a>
leera mas alla de los limites de la linea para encontrar su
entrada, ya que las nuevas lineas son espacios en blanco. (Los
caracteres de espacio en blanco son blanco, tabulador, nueva
linea, retorno de carro, tabulador vertical y avance de linea.)
</p>

<p>
El caracter de conversion indica la interpretacion del campo de
entrada. El argumento correspondiente debe ser un apuntador. Los
caracteres de conversion legales se muestran en la <a href="#org9e61a62">tabla B-2</a>.
</p>

<p>
Los caracteres de conversion <code>d</code>, <code>i</code>, <code>n</code>, <code>o</code>, <code>u</code>, y <code>x</code>
pueden estar precedidos por <code>h</code> si el argumento es un apuntador a
<code>short</code> en vez de <code>int</code>, o por <code>l</code> (letra ele) si el argumento es
un apuntador a <code>long</code>. Los caracteres de conversion <code>e</code>, <code>f</code>, y
<code>g</code> pueden estar precedidos por <code>l</code> si en la lista de argumentos
hay un apuntador a <code>double</code> y no a <code>float</code>, y por <code>L</code> si hay un
apuntador a <code>long double</code>.
</p>

<dl class="org-dl">
<dt><a id="org9e61a62">TABLA B-2</a></dt><dd><p>
CONVERSIONES DE SCANF
</p>

<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-left" />

<col  class="org-left" />
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">CARACTER</th>
<th scope="col" class="org-left">Dato de Entrada; Tipo de Argumento</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left">d</td>
<td class="org-left">entero decimal; <code>int *</code>.</td>
</tr>

<tr>
<td class="org-left">i</td>
<td class="org-left">entero; <code>int *</code>. El entero puede estar en octal (iniciado con <code>0</code>) o hexadecimal (iniciado con <code>0x</code> o <code>0X</code>).</td>
</tr>

<tr>
<td class="org-left">o</td>
<td class="org-left">entero octal (con o sin cero al inicio); <code>int *</code>.</td>
</tr>

<tr>
<td class="org-left">u</td>
<td class="org-left">entero decimal sin signo; <code>unsigned int *</code>.</td>
</tr>

<tr>
<td class="org-left">x</td>
<td class="org-left">entero hexadecimal (con o sin <code>0x</code> o <code>0X</code> al inicio); <code>int *</code>.</td>
</tr>

<tr>
<td class="org-left">c</td>
<td class="org-left">caracteres; <code>char *</code>. Los siguientes caracteres de entrada se pondran en el arreglo indicado, hasta el numero dado por el ancho de campo; el valor por omision es 1. No se agrega '\0'. En este caso se suprime el salto normal sobre los caracteres de espacio en blanco; para leer el siguiente caracter que no sea blanco, use <code>%ls</code>.</td>
</tr>

<tr>
<td class="org-left">s</td>
<td class="org-left">cadena de caracteres que no es espacio en blanco (no entrecomillados); <code>char *</code>, apunta a un arreglo de caracteres suficientemente grande para contener la cadena y un '\0' terminal que se le agregara.</td>
</tr>

<tr>
<td class="org-left">e,f,g</td>
<td class="org-left">numero de punto flotante; <code>float *</code>. El formato de entrada para los <code>float</code> es un signo optativo, una cadena de numeros posiblemente con un punto decimal, y un campo optativo de exponente con una <code>E</code> o <code>e</code> seguida posiblemente de un entero con signo.</td>
</tr>

<tr>
<td class="org-left">p</td>
<td class="org-left">valor apuntador como se imprime por <code>printf("%p")</code>; <code>void *</code>.</td>
</tr>

<tr>
<td class="org-left">n</td>
<td class="org-left">escribe en el argumento el numero de caracteres escritos hasta el momento por esta llamada; <code>int *</code>. No se lee entrada alguna. La cuenta de elementos convertidos no se incrementa.</td>
</tr>

<tr>
<td class="org-left">[&#x2026;]</td>
<td class="org-left">coincide con la mayor cadena no vacia de caracteres de entrada del conjunto entre corchetes; <code>char *</code>. Se agrega un '\0'. <code>[]...]</code> incluye <code>]</code> en el conjunto.</td>
</tr>

<tr>
<td class="org-left">[^&#x2026;]</td>
<td class="org-left">coincide con la mayor cadena no vacia de caracteres de entrada que <i>no</i> sean del conjunto entre corchetes; <code>char *</code>. Se agrega un '\0'. <code>[^]...]</code> incluye <code>]</code> en el conjunto.</td>
</tr>

<tr>
<td class="org-left">%</td>
<td class="org-left">literal; no se hace ninguna asignacion.</td>
</tr>
</tbody>
</table></dd>
</dl>
</div>
</div>

<div id="outline-container-org0853adc" class="outline-5">
<h5 id="org0853adc"><a id="orgb47aa6e">=scanf=</a></h5>
<div class="outline-text-5" id="text-org0853adc">
<div class="org-src-container">
<pre class="src src-c"><span style="color: #98fb98;">int</span> <span style="color: #87cefa;">scanf</span>(<span style="color: #00ffff;">const</span> <span style="color: #98fb98;">char</span> *<span style="color: #eedd82;">format</span>, ...)
</pre>
</div>

<p>
<code>scanf(...)</code> es identica a <code>fscanf(stdin, ...)</code>.
</p>
</div>
</div>

<div id="outline-container-orgf775980" class="outline-5">
<h5 id="orgf775980"><a id="org704633d">=sscanf=</a></h5>
<div class="outline-text-5" id="text-orgf775980">
<div class="org-src-container">
<pre class="src src-c"><span style="color: #98fb98;">int</span> <span style="color: #87cefa;">sscanf</span>(<span style="color: #98fb98;">char</span> *<span style="color: #eedd82;">s</span>, <span style="color: #00ffff;">const</span> <span style="color: #98fb98;">char</span> *<span style="color: #eedd82;">format</span>, ...)
</pre>
</div>

<p>
<code>sscanf(s,...)</code> es equivalente a <code>scanf(...)</code> excepto que los
caracteres de entrada son tomados de la cadena <code>s</code>.
</p>
</div>
</div>
</div>

<div id="outline-container-org19260ec" class="outline-4">
<h4 id="org19260ec">B1.4 Funciones de entrada y salida de caracteres                  <a id="org27b597e"></a></h4>
<div class="outline-text-4" id="text-org19260ec">
</div>
<div id="outline-container-org20382a4" class="outline-5">
<h5 id="org20382a4"><a id="org57f234a">=fgetc=</a></h5>
<div class="outline-text-5" id="text-org20382a4">
<div class="org-src-container">
<pre class="src src-c"><span style="color: #98fb98;">int</span> <span style="color: #87cefa;">fgetc</span>(<span style="color: #98fb98;">FILE</span> *<span style="color: #eedd82;">stream</span>)
</pre>
</div>

<p>
<a href="#org57f234a"><code>fgetc</code></a> regresa el siguiente caracter de <code>stream</code> como <code>unsigned
     char</code> (convertido a un <code>int</code>), o <code>EOF</code> si se encontro el fin de
archivo u ocurre un error.
</p>
</div>
</div>

<div id="outline-container-orga692b8e" class="outline-5">
<h5 id="orga692b8e"><a id="org720aa41">=fgets=</a></h5>
<div class="outline-text-5" id="text-orga692b8e">
<div class="org-src-container">
<pre class="src src-c"><span style="color: #98fb98;">char</span> *<span style="color: #87cefa;">fgets</span>(<span style="color: #98fb98;">char</span> *<span style="color: #eedd82;">s</span>, <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">n</span>, <span style="color: #98fb98;">FILE</span> *<span style="color: #eedd82;">stream</span>)
</pre>
</div>

<p>
<a href="#org720aa41"><code>fgets</code></a> lee hasta los siguientes <code>n-1</code> caracteres en el arreglo
<code>s</code>, deteniendose si encuentra nueva linea; la nueva linea es
incluida en el arreglo, que es terminado por '\0'. <a href="#org720aa41"><code>fgets</code></a>
regresa <code>s</code>, o <code>NULL</code> si se encuentra fin de archivo u ocurre un
error.
</p>
</div>
</div>

<div id="outline-container-orgb923c81" class="outline-5">
<h5 id="orgb923c81"><a id="orga5b46b6">=fputc=</a></h5>
<div class="outline-text-5" id="text-orgb923c81">
<div class="org-src-container">
<pre class="src src-c"><span style="color: #98fb98;">int</span> <span style="color: #87cefa;">fputc</span>(<span style="color: #98fb98;">int</span> <span style="color: #eedd82;">c</span>, <span style="color: #98fb98;">FILE</span> *<span style="color: #eedd82;">stream</span>)
</pre>
</div>

<p>
<a href="#orga5b46b6"><code>fputc</code></a> escribe el caracter <code>c</code> (convertido a <code>unsigned char</code>) en
<code>stream</code>. Regresa el caracter escrito, o <code>EOF</code> en caso de error.
</p>
</div>
</div>

<div id="outline-container-org3ef7764" class="outline-5">
<h5 id="org3ef7764"><a id="org2ce723f">=fputs=</a></h5>
<div class="outline-text-5" id="text-org3ef7764">
<div class="org-src-container">
<pre class="src src-c"><span style="color: #98fb98;">int</span> <span style="color: #87cefa;">fputs</span>(<span style="color: #00ffff;">const</span> <span style="color: #98fb98;">char</span> *<span style="color: #eedd82;">s</span>, <span style="color: #98fb98;">FILE</span> *<span style="color: #eedd82;">stream</span>)
</pre>
</div>

<p>
<a href="#org2ce723f"><code>fputs</code></a> escribe la cadena <code>s</code> (que no necesita contener '\n') en
<code>stream</code>; regresa un valor no negativo, o <code>EOF</code> si hay error.
</p>
</div>
</div>

<div id="outline-container-orgae2a6aa" class="outline-5">
<h5 id="orgae2a6aa"><a id="org7181de4">=getc=</a></h5>
<div class="outline-text-5" id="text-orgae2a6aa">
<div class="org-src-container">
<pre class="src src-c"><span style="color: #98fb98;">int</span> <span style="color: #87cefa;">getc</span>(<span style="color: #98fb98;">FILE</span> *<span style="color: #eedd82;">stream</span>)
</pre>
</div>

<p>
<a href="#org7181de4"><code>getc</code></a> es equivalente a <a href="#org57f234a"><code>fgetc</code></a> excepto que si es una macro,
puede evaluar a <code>stream</code> mas de una vez.
</p>
</div>
</div>

<div id="outline-container-orgbf08755" class="outline-5">
<h5 id="orgbf08755"><a id="org4d38061">=getchar=</a></h5>
<div class="outline-text-5" id="text-orgbf08755">
<div class="org-src-container">
<pre class="src src-c"><span style="color: #98fb98;">int</span> <span style="color: #87cefa;">getchar</span>(<span style="color: #98fb98;">void</span>)
</pre>
</div>

<p>
<a href="#org4d38061"><code>getchar</code></a> es equivalente a <code>getc(stdin)</code>.
</p>
</div>
</div>

<div id="outline-container-orgae965ce" class="outline-5">
<h5 id="orgae965ce"><a id="org27cb039">=gets=</a></h5>
<div class="outline-text-5" id="text-orgae965ce">
<div class="org-src-container">
<pre class="src src-c"><span style="color: #98fb98;">char</span> *<span style="color: #87cefa;">gets</span>(<span style="color: #98fb98;">char</span> *<span style="color: #eedd82;">s</span>)
</pre>
</div>

<p>
<a href="#org27cb039"><code>gets</code></a> lee la siguiente linea de entrada y la deja en el arreglo
<code>s</code>; reemplaza el caracter nueva linea final con '\0'. Regresa
<code>s</code>, o <code>NULL</code> si ocurre fin de archivo o error.
</p>
</div>
</div>

<div id="outline-container-orgc7b63c8" class="outline-5">
<h5 id="orgc7b63c8"><a id="org38237ac">=putc=</a></h5>
<div class="outline-text-5" id="text-orgc7b63c8">
<div class="org-src-container">
<pre class="src src-c"><span style="color: #98fb98;">int</span> <span style="color: #87cefa;">putc</span>(<span style="color: #98fb98;">int</span> <span style="color: #eedd82;">c</span>, <span style="color: #98fb98;">FILE</span> *<span style="color: #eedd82;">stream</span>)
</pre>
</div>

<p>
<a href="#org38237ac"><code>putc</code></a> es equivalente a <a href="#orga5b46b6"><code>fputc</code></a> excepto que, si es una macro,
puede evaluar a <code>stream</code> mas de una vez.
</p>
</div>
</div>

<div id="outline-container-org4cd8139" class="outline-5">
<h5 id="org4cd8139"><a id="orgc7f0a8a">=putchar=</a></h5>
<div class="outline-text-5" id="text-org4cd8139">
<div class="org-src-container">
<pre class="src src-c"><span style="color: #98fb98;">int</span> <span style="color: #87cefa;">putchar</span>(<span style="color: #98fb98;">int</span> <span style="color: #eedd82;">c</span>)
</pre>
</div>

<p>
<code>putchar(c)</code> es equivalente a <code>putc(c, stdout)</code>.
</p>
</div>
</div>

<div id="outline-container-org132728a" class="outline-5">
<h5 id="org132728a"><a id="org039469f">=puts=</a></h5>
<div class="outline-text-5" id="text-org132728a">
<div class="org-src-container">
<pre class="src src-c"><span style="color: #98fb98;">int</span> <span style="color: #87cefa;">puts</span>(<span style="color: #00ffff;">const</span> <span style="color: #98fb98;">char</span> *<span style="color: #eedd82;">s</span>)
</pre>
</div>

<p>
<a href="#org039469f"><code>puts</code></a> escribe la cadena <code>s</code> y un nueva linea a <code>stdout</code>. Regresa
<code>EOF</code> si ocurre un error, de otra forma, un valor no negativo.
</p>
</div>
</div>

<div id="outline-container-orga388533" class="outline-5">
<h5 id="orga388533"><a id="org32f1014">=ungetc=</a></h5>
<div class="outline-text-5" id="text-orga388533">
<div class="org-src-container">
<pre class="src src-c"><span style="color: #98fb98;">int</span> <span style="color: #87cefa;">ungetc</span>(<span style="color: #98fb98;">int</span> <span style="color: #eedd82;">c</span>, <span style="color: #98fb98;">FILE</span> *<span style="color: #eedd82;">stream</span>)
</pre>
</div>

<p>
<a href="#org32f1014"><code>ungetc</code></a> regresa <code>c</code> (convertido en <code>unsigned char</code>) de nuevo al
<code>stream</code>, de donde sera regresado en la proxima lectura. Solo se
garantiza un caracter de regreso por flujo. <code>EOF</code> no puede ser
regresado. <a href="#org32f1014"><code>ungetc</code></a> devuelve el caracter regresado, o <code>EOF</code> en
caso de error.
</p>
</div>
</div>
</div>

<div id="outline-container-org4a69620" class="outline-4">
<h4 id="org4a69620">B1.5 Funciones de entrada y salida directa                        <a id="orgfb1e747"></a></h4>
<div class="outline-text-4" id="text-org4a69620">
</div>
<div id="outline-container-org75df545" class="outline-5">
<h5 id="org75df545"><a id="org46a18ec">=fread=</a></h5>
<div class="outline-text-5" id="text-org75df545">
<div class="org-src-container">
<pre class="src src-c"><span style="color: #98fb98;">size_t</span> <span style="color: #87cefa;">fread</span>(<span style="color: #98fb98;">void</span> *<span style="color: #eedd82;">ptr</span>, <span style="color: #98fb98;">size_t</span> <span style="color: #eedd82;">size</span>, <span style="color: #98fb98;">size_t</span> <span style="color: #eedd82;">nobj</span>, <span style="color: #98fb98;">FILE</span> *<span style="color: #eedd82;">stream</span>)
</pre>
</div>

<p>
<a href="#org46a18ec"><code>fread</code></a> lee de <code>stream</code> en el arreglo <code>ptr</code> hasta <code>nobj</code> objetos
de tamaño <code>size</code>. <a href="#org46a18ec"><code>fread</code></a> regresa el numero de objetos leidos;
esto puede ser menor que el numero solicitado. Para determinar el
estado deben utilizarse <code>feot</code> y <a href="#orgc3f53c8"><code>ferror</code></a>.
</p>
</div>
</div>

<div id="outline-container-org4cb521b" class="outline-5">
<h5 id="org4cb521b"><a id="org887abed">=fwrite=</a></h5>
<div class="outline-text-5" id="text-org4cb521b">
<div class="org-src-container">
<pre class="src src-c"><span style="color: #98fb98;">size_t</span> <span style="color: #87cefa;">fwrite</span>(<span style="color: #00ffff;">const</span> <span style="color: #98fb98;">void</span> *<span style="color: #eedd82;">ptr</span>, <span style="color: #98fb98;">size_t</span> <span style="color: #eedd82;">size</span>, <span style="color: #98fb98;">size_t</span> <span style="color: #eedd82;">nobj</span>, <span style="color: #98fb98;">FILE</span> *<span style="color: #eedd82;">stream</span>)
</pre>
</div>

<p>
<a href="#org887abed"><code>fwrite</code></a> escribe, del arreglo <code>ptr</code>, <code>nobj</code> objetos de tamaños
<code>size</code> en <code>stream</code>. Devuelve el numero de objetos escritos, que
es menor que <code>nobj</code> en caso de error.
</p>
</div>
</div>
</div>

<div id="outline-container-orgb266019" class="outline-4">
<h4 id="orgb266019">B1.6 Funciones de posicionamiento en archivos                     <a id="org6cc802c"></a></h4>
<div class="outline-text-4" id="text-orgb266019">
</div>
<div id="outline-container-org4583405" class="outline-5">
<h5 id="org4583405"><a id="org20f3c96">=fseek=</a></h5>
<div class="outline-text-5" id="text-org4583405">
<div class="org-src-container">
<pre class="src src-c"><span style="color: #98fb98;">int</span> <span style="color: #87cefa;">fseek</span>(<span style="color: #98fb98;">FILE</span> *<span style="color: #eedd82;">stream</span>, <span style="color: #98fb98;">long</span> <span style="color: #eedd82;">offset</span>, <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">origin</span>)
</pre>
</div>

<p>
<a href="#org20f3c96"><code>fseek</code></a> fija la posicion en el archivo para el <code>stream</code>; una
lectura o escritura posterior tendra acceso a datos que inician
en la nueva posicion. Para un archivo binario, la posicion se
fija a <code>offset</code> caracteres de <code>origin</code>, el cual puede ser
<code>SEEK_SET</code> (principio), <code>SEEK_CUR</code> (posicion actual), o
<code>SEEK_END</code> (fin del archivo). Para un <code>stream</code> de texto, <code>offset</code>
debe ser cero, o un valor regresado por <a href="#org5b43294"><code>ftell</code></a> (en tal caso
<code>origin</code> debe ser <code>SEEK_SET</code>.) <a href="#org20f3c96"><code>fseek</code></a> regresa un valor diferente
de cero en caso de error.
</p>
</div>
</div>

<div id="outline-container-orgbca3da5" class="outline-5">
<h5 id="orgbca3da5"><a id="org5b43294">=ftell=</a></h5>
<div class="outline-text-5" id="text-orgbca3da5">
<div class="org-src-container">
<pre class="src src-c"><span style="color: #98fb98;">long</span> <span style="color: #87cefa;">ftell</span>(<span style="color: #98fb98;">FILE</span> *<span style="color: #eedd82;">stream</span>)
</pre>
</div>

<p>
<a href="#org5b43294"><code>ftell</code></a> regresa la posicion actual de stream en el archivo, o
<code>-1</code> en caso de error.
</p>
</div>
</div>

<div id="outline-container-orgf50f9dd" class="outline-5">
<h5 id="orgf50f9dd"><a id="org78faf4a">=rewind=</a></h5>
<div class="outline-text-5" id="text-orgf50f9dd">
<div class="org-src-container">
<pre class="src src-c"><span style="color: #98fb98;">void</span> <span style="color: #87cefa;">rewind</span>(<span style="color: #98fb98;">FILE</span> *<span style="color: #eedd82;">stream</span>)
</pre>
</div>

<p>
<code>rewind(fp)</code> es equivalente a <code>fseek(fp, 0L, SEEK_SET)</code>;
<code>clearerr(fp)</code>.
</p>
</div>
</div>

<div id="outline-container-org310cefb" class="outline-5">
<h5 id="org310cefb"><a id="org8fba632">=fgetpos=</a></h5>
<div class="outline-text-5" id="text-org310cefb">
<div class="org-src-container">
<pre class="src src-c"><span style="color: #98fb98;">int</span> <span style="color: #87cefa;">fgetpos</span>(<span style="color: #98fb98;">FILE</span> *<span style="color: #eedd82;">stream</span>, <span style="color: #98fb98;">fpos_t</span> *<span style="color: #eedd82;">ptr</span>)
</pre>
</div>

<p>
<a href="#org8fba632"><code>fgetpos</code></a> graba en <code>*ptr</code> la posicion actual de <code>stream</code>, para
uso posterior de <a href="#org4563b21"><code>fsetpos</code></a>.  El tipo <code>fpos_t</code> es adecuado para
grabar tales valores, <a href="#org8fba632"><code>fgetpos</code></a> regresa un valor diferente de
cero en caso de error.
</p>
</div>
</div>

<div id="outline-container-org9ca8fb1" class="outline-5">
<h5 id="org9ca8fb1"><a id="org4563b21">=fsetpos=</a></h5>
<div class="outline-text-5" id="text-org9ca8fb1">
<div class="org-src-container">
<pre class="src src-c"><span style="color: #98fb98;">int</span> <span style="color: #87cefa;">fsetpos</span>(<span style="color: #98fb98;">FILE</span> *<span style="color: #eedd82;">stream</span>, <span style="color: #00ffff;">const</span> <span style="color: #98fb98;">fpos_t</span> *<span style="color: #eedd82;">ptr</span>)
</pre>
</div>

<p>
<a href="#org4563b21"><code>fsetpos</code></a> coloca <code>stream</code> en la posicion grabada en <code>*ptr</code> por
<a href="#org8fba632"><code>fgetpos</code></a>. En caso de error, <a href="#org4563b21"><code>fsetpos</code></a> regresa un valor diferente
de cero.
</p>
</div>
</div>
</div>

<div id="outline-container-org4753f1e" class="outline-4">
<h4 id="org4753f1e">B1.7 Funciones de error                                           <a id="org7c1fb2a"></a></h4>
<div class="outline-text-4" id="text-org4753f1e">
<p>
Muchas funciones de la biblioteca activan indicadores de estado
cuando ocurre un error o fin de archivo. Estos indicadores se
pueden fijar y probar explicitamente. Ademas, la expresion entera
<code>errno</code> (declarada en <code>&lt;errno.h&gt;</code>) puede contener un numero de
error que da informacion adicional acerca del error mas reciente.
</p>
</div>

<div id="outline-container-org97716e7" class="outline-5">
<h5 id="org97716e7"><a id="org2d81144">=clearerr=</a></h5>
<div class="outline-text-5" id="text-org97716e7">
<div class="org-src-container">
<pre class="src src-c"><span style="color: #98fb98;">void</span> <span style="color: #87cefa;">clearerr</span>(<span style="color: #98fb98;">FILE</span> *<span style="color: #eedd82;">stream</span>)
</pre>
</div>

<p>
<code>clearrer</code> limpia los indicadores de fin de archivo y error para
el <code>stream</code>.
</p>
</div>
</div>

<div id="outline-container-org0e82d41" class="outline-5">
<h5 id="org0e82d41"><a id="orga11314f">=feof=</a></h5>
<div class="outline-text-5" id="text-org0e82d41">
<div class="org-src-container">
<pre class="src src-c"><span style="color: #98fb98;">int</span> <span style="color: #87cefa;">feof</span>(<span style="color: #98fb98;">FILE</span> *<span style="color: #eedd82;">stream</span>)
</pre>
</div>

<p>
<a href="#orga11314f"><code>feof</code></a> regresa un valor diferente de cero si esta encendido el
indicador de fin de archivo para <code>stream</code>
</p>
</div>
</div>

<div id="outline-container-orge7d9b76" class="outline-5">
<h5 id="orge7d9b76"><a id="orgc3f53c8">=ferror=</a></h5>
<div class="outline-text-5" id="text-orge7d9b76">
<div class="org-src-container">
<pre class="src src-c"><span style="color: #98fb98;">int</span> <span style="color: #87cefa;">ferror</span>(<span style="color: #98fb98;">FILE</span> *<span style="color: #eedd82;">stream</span>)
</pre>
</div>

<p>
<a href="#orgc3f53c8"><code>ferror</code></a> regresa un valor diferente de cero si esta encendido el
indicador de error de <code>stream</code>.
</p>
</div>
</div>

<div id="outline-container-org7133a1d" class="outline-5">
<h5 id="org7133a1d"><a id="org597f01f">=perror=</a></h5>
<div class="outline-text-5" id="text-org7133a1d">
<div class="org-src-container">
<pre class="src src-c"><span style="color: #98fb98;">void</span> <span style="color: #87cefa;">perror</span>(<span style="color: #00ffff;">const</span> <span style="color: #98fb98;">char</span> *<span style="color: #eedd82;">s</span>)
</pre>
</div>

<p>
<code>perror(s)</code> imprime <code>s</code> y un mensaje de error definido por la
implantacion, correspondiente al entero que esta en <code>errno</code>, como
si fuera
</p>

<div class="org-src-container">
<pre class="src src-c"><span style="color: #87cefa;">fprintf</span> (stderr, <span style="color: #ffa07a;">"%s : %s\n"</span>, s, <span style="color: #ffa07a;">"mensaje de error"</span> )
</pre>
</div>

<p>
Ver <code>strerror</code> en la seccion <a href="#orgbc89691">B3</a>.
</p>
</div>
</div>
</div>
</div>

<div id="outline-container-org93c9679" class="outline-3">
<h3 id="org93c9679">B2   Pruebas de clasificacion de caracteres: <code>&lt;ctype.h&gt;</code>           <a id="org6358bb7"></a></h3>
<div class="outline-text-3" id="text-org93c9679">
<p>
El header <code>&lt;ctype.h&gt;</code> declara funciones para la prueba de
caracteres. Para cada funcion, el argumento es un <code>int</code> cuyo valor
debe ser <code>EOF</code> o representable por un <code>unsigned char</code>, y el valor
de retorno es un <code>int</code>. Las funciones regresan diferente de cero
(verdadero) si el argumento <code>c</code> satisface la condicion descrita, y
cero si no lo hace.
</p>

<dl class="org-dl">
<dt>isalnum(c) </dt><dd><code>isalpha(c)</code> o <code>isdigit(c)</code> es verdadero</dd>

<dt>isalpha(c) </dt><dd><code>isupper(c)</code> o <code>islower(c)</code> es verdadero</dd>

<dt>iscntrl(c) </dt><dd>caracter de control</dd>

<dt>isdigit(c) </dt><dd>digito decimal</dd>

<dt>isgraph(c) </dt><dd>caracter de impresion excepto espacio</dd>

<dt>islower(c) </dt><dd>letra minuscula</dd>

<dt>isprint(c) </dt><dd>caracter de impresion incluyendo espacio</dd>

<dt>ispunct(c) </dt><dd>caracter de impresion excepto espacio, letra o
digito.</dd>

<dt>isspace(c) </dt><dd>espacio, avance de linea, nueva linea, retorno de
carro, tabulador, tabulador vertical</dd>

<dt>isupper(c) </dt><dd>letra mayuscula</dd>

<dt>isxdigit(c)</dt><dd>digito hexadecimal</dd>
</dl>


<p>
En el conjunto de caracteres ASCII de siete bits, los caracteres de
impresion son de <code>0x20</code> (' ') a <code>0x7E</code> ('-'); los caracteres de
control son de <code>0</code> (<code>NUL</code>) a <code>0x1F</code> (<code>US</code>) y <code>0x7F</code> (<code>DEL</code>).
</p>

<p>
Ademas, hay dos funciones que convierten letras:
</p>

<dl class="org-dl">
<dt>int tolower(int c)</dt><dd>convierte <code>c</code> a minuscula</dd>

<dt>int toupper(int c)</dt><dd>convierte <code>c</code> a mayuscula</dd>
</dl>


<p>
Si <code>c</code> es una letra mayuscula, <code>tolower(c)</code> regresa la
correspondiente letra minuscula; en otro caso regresa <code>c</code>. Si <code>c</code>
es una letra minuscula, <code>toupper(c)</code> regresa la correspondiente
letra mayuscula; en otro caso regresa <code>c</code>.
</p>
</div>
</div>

<div id="outline-container-org2741370" class="outline-3">
<h3 id="org2741370">B3   Funciones para cadenas: <code>&lt;string.h&gt;</code>                          <a id="orgbc89691"></a></h3>
<div class="outline-text-3" id="text-org2741370">
<p>
Hay dos grupos de funciones para cadenas definidas en el header
<code>&lt;string.h&gt;</code>. Las primeras tienen nombres que comienzan con <code>str</code>;
las segundas tienen nombres que comienzan con <code>mem</code>. Excepto para
<code>memmove</code>, el comportamiento esta indefinido si la copia ocurre
entre objetos que se traslapan. Las funciones de comparacion tratan
los argumentos como matrices <code>unsigned char</code>.
</p>

<p>
En la siguiente tabla, las variables <code>s</code> y <code>t</code> son de tipo <code>char
   *</code>; <code>cs</code> y <code>ct</code> son de tipo <code>const char *</code>; <code>n</code> es de tipo
<code>size_t</code>; y <code>c</code> es un <code>int</code> convertido a <code>char</code>.
</p>

<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-left" />

<col  class="org-left" />
</colgroup>
<tbody>
<tr>
<td class="org-left"><code>char *strcpy(s,ct)</code></td>
<td class="org-left">copia la cadena <code>ct</code> a la cadena <code>s</code>, incluyendo '\0'; regresa <code>s</code>.</td>
</tr>

<tr>
<td class="org-left"><code>char *strncpy(s,ct,n)</code></td>
<td class="org-left">copia hasta <code>n</code> caracteres de la cadena <code>ct</code> a <code>s</code>; regresa <code>s</code>. Rellena con '\0' si <code>ct</code> tiene menos de <code>n</code> caracteres,</td>
</tr>

<tr>
<td class="org-left"><code>char *strcat(s,ct)</code></td>
<td class="org-left">concatena la cadena <code>ct</code> al final de la cadena <code>s</code>; regresa <code>s</code>;</td>
</tr>

<tr>
<td class="org-left"><code>char *strncat(s,ct,n)</code></td>
<td class="org-left">concatena hasta <code>n</code> caracteres de la cadena <code>ct</code> a la cadena <code>s</code>, terminando con '\0'; regresa <code>s</code>.</td>
</tr>

<tr>
<td class="org-left"><code>int strcmp(cs,ct)</code></td>
<td class="org-left">compara la cadena <code>cs</code> con la cadena <code>ct</code>; regresa &lt;0 si <code>cs&lt;ct</code>, 0 si <code>cs==ct</code>, o &gt;0 if <code>cs&gt;ct</code>.</td>
</tr>

<tr>
<td class="org-left"><code>int strncmp(cs,ct,n)</code></td>
<td class="org-left">compara hasta <code>n</code> caracteres de la cadena <code>cs</code> con la cadena <code>ct</code>; regresa &lt;0 si <code>cs&lt;ct</code>, 0 si <code>cs==ct</code>, o &gt;0 si <code>cs&gt;ct</code>.</td>
</tr>

<tr>
<td class="org-left"><code>char *strchr(cs,c)</code></td>
<td class="org-left">regresa un apuntador a la primera ocurrencia de <code>c</code> en <code>cs</code>, o <code>NULL</code> si no esta presente.</td>
</tr>

<tr>
<td class="org-left"><code>char *strrchr(cs,c)</code></td>
<td class="org-left">regresa un apuntador a la ultima ocurrencia de <code>c</code> en <code>cs</code>, o <code>NULL</code> si no esta presente.</td>
</tr>

<tr>
<td class="org-left"><code>size_t strspn(cs,ct)</code></td>
<td class="org-left">regresa la longitud del prefijo de <code>cs</code> que consiste en los caracteres en <code>ct</code>.</td>
</tr>

<tr>
<td class="org-left"><code>size_t strcspn(cs,ct)</code></td>
<td class="org-left">regresa la longitud del prefijo de <code>cs</code> que consiste en los caracteres que <i>no</i> estan en <code>ct</code>.</td>
</tr>

<tr>
<td class="org-left"><code>char *strpbrk(cs,ct)</code></td>
<td class="org-left">regresa un apuntador a la primera ocurrencia en la cadena <code>cs</code> de cualquier caracter de la cadena <code>ct</code>, o <code>NULL</code> si ninguno esta presente.</td>
</tr>

<tr>
<td class="org-left"><code>char *strstr(cs,ct)</code></td>
<td class="org-left">regresa un apuntador a la primera ocurrencia de la cadena <code>ct</code> en <code>cs</code>, o <code>NULL</code> si no esta presente.</td>
</tr>

<tr>
<td class="org-left"><code>size_t strlen(cs)</code></td>
<td class="org-left">regresa la longitud de <code>cs</code>.</td>
</tr>

<tr>
<td class="org-left"><code>char *strerror(n)</code></td>
<td class="org-left">regresa un apuntador a una cadena definida por la implantacion, correspondiente al error <code>n</code>.</td>
</tr>

<tr>
<td class="org-left"><code>char *strtok(s,ct)</code></td>
<td class="org-left"><code>strtok</code> busca en <code>s</code> tokens delimitados por caracteres de <code>ct</code>; ver abajo.</td>
</tr>
</tbody>
</table>

<p>
Una secuencia de llamadas a <code>strtok(s,ct)</code> divide <code>s</code> en tokens,
cada uno delimitado por un caracter de <code>ct</code>. La primer llamada en
la secuencia tiene una <code>s</code> no <code>NULL</code>, encuentra el primer token en
<code>s</code> que consiste en caracteres que no estan en <code>ct</code>; termina al
sobreescribir el siguiente caracter de <code>s</code> con '\0' y regresa un
apuntador al token. Cada llamada subsiguiente, indicada por un
valor <code>NULL</code> de <code>s</code>, regresa el token siguiente, buscando justo a
partir de final del anterior, <code>strtok</code> regresa <code>NULL</code> cuando ya no
encuentra tokens. La cadena <code>ct</code> puede ser diferente en cada
llamada.
</p>

<p>
La intencion de las funciones <code>mem...</code> es manipular objetos como
arreglos de caracteres; la intencion es lograr una interfaz para
rutinas eficientes. En la siguiente tabla, <code>s</code> y <code>t</code> son de lipo
<code>void *</code>; <code>cs</code> y <code>ct</code> son de tipo <code>const void *</code>; <code>n</code> es de tipo
<code>size_t</code>; y <code>c</code> es un <code>int</code> convertido a <code>unsigned char</code>.
</p>

<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-left" />

<col  class="org-left" />
</colgroup>
<tbody>
<tr>
<td class="org-left"><code>void *memcpy(s,ct,n)</code></td>
<td class="org-left">copia <code>n</code> caracteres de <code>ct</code> a <code>s</code>, y regresa <code>s</code>.</td>
</tr>

<tr>
<td class="org-left"><code>void *memmove(s,ct,n)</code></td>
<td class="org-left">lo mismo que <code>memcpy</code> excepto que funciona aun si los objetos se traslapan.</td>
</tr>

<tr>
<td class="org-left"><code>int memcmp(cs,ct,n)</code></td>
<td class="org-left">compara los primeros <code>n</code> caracteres de <code>cs</code> con <code>ct</code>; regresa lo mismo que <code>strcmp</code>.</td>
</tr>

<tr>
<td class="org-left"><code>void *memchr(cs,c,n)</code></td>
<td class="org-left">regresa un apuntador a la primera ocurrencia del caracter <code>c</code> en <code>cs</code>, o <code>NULL</code> si no esta presente entre los primeros <code>n</code> caracteres.</td>
</tr>

<tr>
<td class="org-left"><code>void *memset(s,c,n)</code></td>
<td class="org-left">coloca el caracter <code>c</code> en los primeros <code>n</code> caracteres de <code>s</code>, regresa <code>s</code>.</td>
</tr>
</tbody>
</table>
</div>
</div>

<div id="outline-container-org2429365" class="outline-3">
<h3 id="org2429365">B4   Funciones matematicas: &lt;math.h&gt;                               <a id="orgfde8c35"></a></h3>
<div class="outline-text-3" id="text-org2429365">
<p>
El header <code>&lt;math.h&gt;</code> declara funciones y macros matematicas.
</p>

<p>
Las macros <code>EDOM</code> y <code>ERANGE</code> (que se encuentran en <code>&lt;errno.h&gt;</code>) son
constantes enteras con valor diferente de cero que se usan para
señalar errores de dominio y de rango para las funciones;
<code>HUGE_VAL</code> es un valor positivo <code>double</code>. Un <i>error de dominio</i>
ocurre si un argumento esta fuera del dominio sobre el que esta
definida la funcion. En caso de un error de dominio, <code>errno</code> toma
el valor de <code>EDOM</code>; el valor regresado depende de la
implantacion. Un <i>error de rango</i> ocurre si el resultado de la
funcion no se puede representar como un <code>double</code>. Si el resultado
se desborda, la funcion regresa <code>HUGE_VAL</code> con el signo correcto, y
<code>errno</code> se hace <code>ERANGE</code>. Si el resultado es tan pequeño que no se
puede representar (underflow), la funcion regresa cero; el que
<code>errno</code> sea fijado a <code>ERANGE</code> depende de la implantacion.
</p>

<p>
En la tabla siguiente, <code>x</code> y <code>y</code> son de tipo <code>double</code>, <code>n</code> es un
<code>int</code>, y todas las funciones regresan <code>double</code>. Los angulos para
las funciones trigonometricas estan representados en radianes.
</p>

<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-left" />

<col  class="org-left" />
</colgroup>
<tbody>
<tr>
<td class="org-left"><code>sin(x)</code></td>
<td class="org-left">seno de x</td>
</tr>

<tr>
<td class="org-left"><code>cos(x)</code></td>
<td class="org-left">coseno de x</td>
</tr>

<tr>
<td class="org-left"><code>tan(x)</code></td>
<td class="org-left">tangente de x</td>
</tr>

<tr>
<td class="org-left"><code>asin(x)</code></td>
<td class="org-left">sin<sup>-1</sup> (x) en el rango [-pi/2,pi/2], x en [-1,1].</td>
</tr>

<tr>
<td class="org-left"><code>acos(x)</code></td>
<td class="org-left">cos<sup>-1</sup> (*) en el rango [0,pi], x en [-1,1].</td>
</tr>

<tr>
<td class="org-left"><code>atan(x)</code></td>
<td class="org-left">tan<sup>-1</sup> (x) en el rango [-pi/2,-pi/2]. -1</td>
</tr>

<tr>
<td class="org-left"><code>atan2(y,x)</code></td>
<td class="org-left">tan<sup>-1</sup> (y/x) en el rango [-pi,pi].</td>
</tr>

<tr>
<td class="org-left"><code>sinh(x)</code></td>
<td class="org-left">seno hiperbolico de x</td>
</tr>

<tr>
<td class="org-left"><code>cosh(x)</code></td>
<td class="org-left">coseno hiperbolico de x</td>
</tr>

<tr>
<td class="org-left"><code>tanh (x)</code></td>
<td class="org-left">tangente hiperbolica de x</td>
</tr>

<tr>
<td class="org-left"><code>exp(x)</code></td>
<td class="org-left">funcion exponencial e<sup>x</sup></td>
</tr>

<tr>
<td class="org-left"><code>log(x)</code></td>
<td class="org-left">logaritmo natural ln(x), x&gt;0.</td>
</tr>

<tr>
<td class="org-left"><code>log10(x)</code></td>
<td class="org-left">logaritmo base 10 log<sub>10</sub>(x), x&gt;0.</td>
</tr>

<tr>
<td class="org-left"><code>pow(x,y)</code></td>
<td class="org-left">x<sup>y</sup>. Ocurre un error de dominio si x=0 y y&lt;0, o si x&lt;0 y y no es un entero.</td>
</tr>

<tr>
<td class="org-left"><code>sqrt(x)</code></td>
<td class="org-left">raiz cuadrada de x, x&gt;0.</td>
</tr>

<tr>
<td class="org-left"><code>ceil(x)</code></td>
<td class="org-left">menor entero no menor que x, como <code>double</code>.</td>
</tr>

<tr>
<td class="org-left"><code>floor(x)</code></td>
<td class="org-left">mayor entero no mayor que x, como <code>double</code>.</td>
</tr>

<tr>
<td class="org-left"><code>fabs(x)</code></td>
<td class="org-left">valor absoluto x</td>
</tr>

<tr>
<td class="org-left"><code>ldexp(x,n)</code></td>
<td class="org-left">x*2<sup>n</sup></td>
</tr>

<tr>
<td class="org-left"><code>frexp(x, int *exp)</code></td>
<td class="org-left">divide x en una fraccion normalizada dentro del intervalo [1/2,1], que se regresa, y una potencia de 2, que se almacena en *exp. Si x es cero, ambas partes del resultado son cero.</td>
</tr>

<tr>
<td class="org-left"><code>modf(x, double *ip)</code></td>
<td class="org-left">divide x en parte entera y fraccionaria, cada una con el mismo signo que x. Almacena la parte entera en *ip, y regresa la parte fraccionaria.</td>
</tr>

<tr>
<td class="org-left"><code>fmod(x,y)</code></td>
<td class="org-left">residuo de punto flotante de x/y, con el mismo signo que x. Si y es cero, el resultado esta definido por la implantacion.</td>
</tr>
</tbody>
</table>
</div>
</div>

<div id="outline-container-org738460c" class="outline-3">
<h3 id="org738460c">B5   Funciones de utileria: &lt;stdlib.h&gt;                             <a id="orge762181"></a></h3>
<div class="outline-text-3" id="text-org738460c">
<p>
El header <code>&lt;stdlib.h&gt;</code> declara funciones para conversion numerica,
asignacion de memoria y tareas semejantes.
</p>
</div>

<div id="outline-container-org8b77f5f" class="outline-4">
<h4 id="org8b77f5f"><a id="org9f52a73">=atof=</a></h4>
<div class="outline-text-4" id="text-org8b77f5f">
<div class="org-src-container">
<pre class="src src-c"><span style="color: #98fb98;">double</span> <span style="color: #87cefa;">atof</span>(<span style="color: #00ffff;">const</span> <span style="color: #98fb98;">char</span> *<span style="color: #eedd82;">s</span>)
</pre>
</div>

<p>
<a href="#org9f52a73"><code>atof</code></a> convierte <code>s</code> a <code>double</code>; es equivalente a <code>strtod(s,
    (char**)NULL)</code>.
</p>
</div>
</div>

<div id="outline-container-org1d36cab" class="outline-4">
<h4 id="org1d36cab"><a id="orgdd02576">=atoi=</a></h4>
<div class="outline-text-4" id="text-org1d36cab">
<div class="org-src-container">
<pre class="src src-c"><span style="color: #98fb98;">int</span> <span style="color: #87cefa;">atoi</span>(<span style="color: #00ffff;">const</span> <span style="color: #98fb98;">char</span> *<span style="color: #eedd82;">s</span>)
</pre>
</div>

<p>
convierte <code>s</code> a <code>int</code>; es equivalente a <code>(int)strtol(s,
    (char**)NULL, 10)</code>.
</p>
</div>
</div>

<div id="outline-container-org0dbd981" class="outline-4">
<h4 id="org0dbd981"><a id="org7a43a47">=atol=</a></h4>
<div class="outline-text-4" id="text-org0dbd981">
<div class="org-src-container">
<pre class="src src-c"><span style="color: #98fb98;">long</span> <span style="color: #87cefa;">atol</span>(<span style="color: #00ffff;">const</span> <span style="color: #98fb98;">char</span> *<span style="color: #eedd82;">s</span>)
</pre>
</div>

<p>
convierte <code>s</code> a <code>long</code>; es equivalente a <code>strtol(s, (char**)NULL,
    10)</code>.
</p>
</div>
</div>

<div id="outline-container-org451520d" class="outline-4">
<h4 id="org451520d"><a id="org0e7a8dc">=strtod=</a></h4>
<div class="outline-text-4" id="text-org451520d">
<div class="org-src-container">
<pre class="src src-c"><span style="color: #98fb98;">double</span> <span style="color: #87cefa;">strtod</span>(<span style="color: #00ffff;">const</span> <span style="color: #98fb98;">char</span> *<span style="color: #eedd82;">s</span>, <span style="color: #98fb98;">char</span> **<span style="color: #eedd82;">endp</span>)
</pre>
</div>

<p>
<a href="#org0e7a8dc"><code>strtod</code></a> conviene el prefijo de <code>s</code> a <code>double</code>, ignorando el
espacio en blanco inicial; almacena en <code>*endp</code> un apuntador a
cualquier sufijo no cubierto salvo cuando <code>endp</code> es <code>NULL</code>. Si la
respuesta se desborda, regresa <code>HUGE_VAL</code> con el signo apropiado;
si el resultado fuera tan pequeño que no se pueda representar
(underflow), se regresa cero. En cualquier caso <code>errno</code> toma el
valor <code>ERANGE</code>.
</p>
</div>
</div>

<div id="outline-container-orge9f0f95" class="outline-4">
<h4 id="orge9f0f95"><a id="orge761d6c">=strtol=</a></h4>
<div class="outline-text-4" id="text-orge9f0f95">
<div class="org-src-container">
<pre class="src src-c"><span style="color: #98fb98;">long</span> <span style="color: #87cefa;">strtol</span>(<span style="color: #00ffff;">const</span> <span style="color: #98fb98;">char</span> *<span style="color: #eedd82;">s</span>, <span style="color: #98fb98;">char</span> **<span style="color: #eedd82;">endp</span>, <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">base</span>)
</pre>
</div>

<p>
<a href="#orge761d6c"><code>strtol</code></a> convierte el prefijo de <code>s</code> a <code>long</code>, ignorando los
espacios en blanco iniciales; almacena un apuntador en <code>*endp</code> a
cualquier sufijo no cubierto a menos de que <code>endp</code> sea <code>NULL</code>. Si
<code>base</code> esta entre <code>2</code> y <code>36</code>, la conversion se realiza suponiendo
que la entrada es escrita en esa base. Si <code>base</code> es cero, la base
es <code>8</code>, <code>10</code>, o <code>16</code>; los <code>0</code> iniciales implican octal, mientras
que <code>0x</code> y <code>0X</code>, hexadecimal. Las letras, ya sean mayusculas o
minusculas, representan digitos desde <code>10</code> hasta <code>base-1</code>; en base
16 se permite iniciar con <code>0x</code> o <code>0X</code>. Si el sultado se desborda,
se regresa <code>LONG_MAX</code> o <code>LONG_MIN</code>, dependiendo del signo del
resultado, y <code>errno</code> se hace <code>ERANGE</code>.
</p>
</div>
</div>

<div id="outline-container-org2f9ccda" class="outline-4">
<h4 id="org2f9ccda"><a id="orge2dd421">=strtoul=</a></h4>
<div class="outline-text-4" id="text-org2f9ccda">
<div class="org-src-container">
<pre class="src src-c"><span style="color: #98fb98;">unsigned</span> <span style="color: #98fb98;">long</span> <span style="color: #87cefa;">strtoul</span>(<span style="color: #00ffff;">const</span> <span style="color: #98fb98;">char</span> *<span style="color: #eedd82;">s</span>, <span style="color: #98fb98;">char</span> **<span style="color: #eedd82;">endp</span>, <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">base</span>)
</pre>
</div>

<p>
<a href="#orge2dd421"><code>strtoul</code></a> es lo mismo que <a href="#orge761d6c"><code>strtol</code></a> excepto que el resultado es
<code>unsigned long</code> y el valor de error es <code>ULONG_MAX</code>.
</p>
</div>
</div>

<div id="outline-container-orgd634f5a" class="outline-4">
<h4 id="orgd634f5a"><a id="orge269335">=rand=</a></h4>
<div class="outline-text-4" id="text-orgd634f5a">
<div class="org-src-container">
<pre class="src src-c"><span style="color: #98fb98;">int</span> <span style="color: #87cefa;">rand</span>(<span style="color: #98fb98;">void</span>)
</pre>
</div>

<p>
<a href="#orge269335"><code>rand</code></a> devuelve un entero pseudoaleatorio en el rango de <code>0</code> a
<code>RAND_MAX</code>, que es al menos <code>32767</code>.
</p>
</div>
</div>

<div id="outline-container-orge954c0e" class="outline-4">
<h4 id="orge954c0e"><a id="org6315f08">=srand=</a></h4>
<div class="outline-text-4" id="text-orge954c0e">
<div class="org-src-container">
<pre class="src src-c"><span style="color: #98fb98;">void</span> <span style="color: #87cefa;">srand</span>(<span style="color: #98fb98;">unsigned</span> <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">seed</span>)
</pre>
</div>

<p>
<a href="#org6315f08"><code>srand</code></a> utiliza <code>seed</code> como semilla para una nueva secuencia de
numeros pseudoaleatorios. La semilla inicial es <code>1</code>.
</p>
</div>
</div>

<div id="outline-container-org393ee21" class="outline-4">
<h4 id="org393ee21"><a id="org1970706">=calloc=</a></h4>
<div class="outline-text-4" id="text-org393ee21">
<div class="org-src-container">
<pre class="src src-c"><span style="color: #98fb98;">void</span> *<span style="color: #87cefa;">calloc</span>(<span style="color: #98fb98;">size_t</span> <span style="color: #eedd82;">nobj</span>, <span style="color: #98fb98;">size_t</span> <span style="color: #eedd82;">size</span>)
</pre>
</div>

<p>
<a href="#org1970706"><code>calloc</code></a> devuelve un apuntador al espacio para un arreglo de
<code>nobj</code> objetos, cada uno de tamaño <code>size</code>, o <code>NULL</code> si la
solicitud no puede satisfacerse. El espacio se inicializa a bytes
con cero.
</p>
</div>
</div>

<div id="outline-container-orga14c41c" class="outline-4">
<h4 id="orga14c41c"><a id="org292ad05">=malloc=</a></h4>
<div class="outline-text-4" id="text-orga14c41c">
<div class="org-src-container">
<pre class="src src-c"><span style="color: #98fb98;">void</span> *<span style="color: #87cefa;">malloc</span>(<span style="color: #98fb98;">size_t</span> <span style="color: #eedd82;">size</span>)
</pre>
</div>

<p>
<a href="#org292ad05"><code>malloc</code></a> regresa un apuntador al espacio para un objeto de tamaño
<code>size</code>, o <code>NULL</code> si la solicitud no se puede satisfacer. El
espacio no se inicializa.
</p>
</div>
</div>

<div id="outline-container-orgd58718c" class="outline-4">
<h4 id="orgd58718c"><a id="orga2f2afe">=realloc=</a></h4>
<div class="outline-text-4" id="text-orgd58718c">
<div class="org-src-container">
<pre class="src src-c"><span style="color: #98fb98;">void</span> *<span style="color: #87cefa;">realloc</span>(<span style="color: #98fb98;">void</span> *<span style="color: #eedd82;">p</span>, <span style="color: #98fb98;">size_t</span> <span style="color: #eedd82;">size</span>)
</pre>
</div>

<p>
<a href="#orga2f2afe"><code>realloc</code></a> cambia el tamaño del objeto apuntado por <code>p</code> a
<code>size</code>. El contenido no cambiara sino hasta el minimo de los
tamaños viejo y nuevo. Si el nuevo tamaño es mayor, el espacio
nuevo no se inicializa. <a href="#orga2f2afe"><code>realloc</code></a> regresa un apuntador al nuevo
espacio, o <code>NULL</code> si la solicitud no se puede satisfacer; en tal
caso <code>*p</code> no cambia.
</p>
</div>
</div>

<div id="outline-container-orgbb71da8" class="outline-4">
<h4 id="orgbb71da8"><a id="org0a5a9fe">=free=</a></h4>
<div class="outline-text-4" id="text-orgbb71da8">
<div class="org-src-container">
<pre class="src src-c"><span style="color: #98fb98;">void</span> <span style="color: #87cefa;">free</span>(<span style="color: #98fb98;">void</span> *<span style="color: #eedd82;">p</span>)
</pre>
</div>

<p>
<a href="#org0a5a9fe"><code>free</code></a> desasigna el espacio apuntado por <code>p</code>; si <code>p</code> es <code>NULL</code>, no
hace nada, <code>p</code> debe ser un apuntador a un espacio previamente
asignado por <a href="#org1970706"><code>calloc</code></a>, <a href="#org292ad05"><code>malloc</code></a>, o <a href="#orga2f2afe"><code>realloc</code></a>.
</p>
</div>
</div>

<div id="outline-container-orged3e936" class="outline-4">
<h4 id="orged3e936"><a id="orgd3a6c72">=abort=</a></h4>
<div class="outline-text-4" id="text-orged3e936">
<div class="org-src-container">
<pre class="src src-c"><span style="color: #98fb98;">void</span> <span style="color: #87cefa;">abort</span>(<span style="color: #98fb98;">void</span>)
</pre>
</div>

<p>
<a href="#orgd3a6c72"><code>abort</code></a> ocasiona que el programa termine anormalmente, como con
<code>raise(SIGABRT).</code>
</p>
</div>
</div>

<div id="outline-container-org49ff291" class="outline-4">
<h4 id="org49ff291"><a id="org394ccc4">=exit=</a></h4>
<div class="outline-text-4" id="text-org49ff291">
<div class="org-src-container">
<pre class="src src-c"><span style="color: #98fb98;">void</span> <span style="color: #87cefa;">exit</span>(<span style="color: #98fb98;">int</span> <span style="color: #eedd82;">status</span>)
</pre>
</div>

<p>
<a href="#org394ccc4"><code>exit</code></a> ocasiona la terminacion normal del programa. Las funciones
<a href="#org020c132"><code>atexit</code></a> se llaman en orden inverso del registrado, los archivos
abiertos se vacian, los flujos abiertos se cierran, y el control
se regresa al entorno. Como se regresa <code>status</code> al entorno depende
de la implantacion, pero indica cero cuando la terminacion tiene
exito. Se pueden utilizar tambien los valores <code>EXIT_SUCCESS</code> y
<code>EXIT_FAILURE</code>
</p>
</div>
</div>

<div id="outline-container-orgdfa56d3" class="outline-4">
<h4 id="orgdfa56d3"><a id="org020c132">=atexit=</a></h4>
<div class="outline-text-4" id="text-orgdfa56d3">
<div class="org-src-container">
<pre class="src src-c"><span style="color: #98fb98;">int</span> <span style="color: #87cefa;">atexit</span>(<span style="color: #98fb98;">void</span> (*<span style="color: #87cefa;">fcn</span>)(<span style="color: #98fb98;">void</span>))
</pre>
</div>

<p>
<a href="#org020c132"><code>atexit</code></a> registra a la funcion <code>fcn</code> para que sea llamada cuando
el programa termina normalmente; regresa un valor diferente de
cero cuando no se puede hacer el registro.
</p>
</div>
</div>

<div id="outline-container-orgb70001b" class="outline-4">
<h4 id="orgb70001b"><a id="org2bcae28">=system=</a></h4>
<div class="outline-text-4" id="text-orgb70001b">
<div class="org-src-container">
<pre class="src src-c"><span style="color: #98fb98;">int</span> <span style="color: #87cefa;">system</span>(<span style="color: #00ffff;">const</span> <span style="color: #98fb98;">char</span> *<span style="color: #eedd82;">s</span>)
</pre>
</div>

<p>
<a href="#org2bcae28"><code>system</code></a> pasa la cadena <code>s</code> al entorno para que se ejecute. Si <code>s</code>
es <code>NULL</code>, <a href="#org2bcae28"><code>system</code></a> regresa un valor diferente de cero si hay un
procesador de ordenes. Si <code>s</code> no es <code>NULL</code>, el valor regresado
depende de la implantacion.
</p>
</div>
</div>

<div id="outline-container-orga9cfb5c" class="outline-4">
<h4 id="orga9cfb5c"><a id="org32ce981">=getenv=</a></h4>
<div class="outline-text-4" id="text-orga9cfb5c">
<div class="org-src-container">
<pre class="src src-c"><span style="color: #98fb98;">char</span> *<span style="color: #87cefa;">getenv</span>(<span style="color: #00ffff;">const</span> <span style="color: #98fb98;">char</span> *<span style="color: #eedd82;">name</span>)
</pre>
</div>

<p>
<a href="#org32ce981"><code>getenv</code></a> regresa la cadena del entorno asociada con <code>name</code>, o
<code>NULL</code> si no existe. Los detalles dependen de la implantacion.
</p>
</div>
</div>

<div id="outline-container-org9080cdf" class="outline-4">
<h4 id="org9080cdf"><a id="org37eeea9">=bsearch=</a></h4>
<div class="outline-text-4" id="text-org9080cdf">
<div class="org-src-container">
<pre class="src src-c"><span style="color: #98fb98;">void</span> *<span style="color: #87cefa;">bsearch</span>(<span style="color: #00ffff;">const</span> <span style="color: #98fb98;">void</span> *<span style="color: #eedd82;">key</span>, <span style="color: #00ffff;">const</span> <span style="color: #98fb98;">void</span> *<span style="color: #eedd82;">base</span>, <span style="color: #98fb98;">size_t</span> <span style="color: #eedd82;">n</span>, <span style="color: #98fb98;">size_t</span> <span style="color: #eedd82;">size</span>,
              <span style="color: #98fb98;">int</span> (*<span style="color: #87cefa;">cmp</span>)(<span style="color: #00ffff;">const</span> <span style="color: #98fb98;">void</span> *<span style="color: #eedd82;">keyval</span>, <span style="color: #00ffff;">const</span> <span style="color: #98fb98;">void</span> *<span style="color: #eedd82;">datum</span>))
</pre>
</div>

<p>
<a href="#org37eeea9"><code>bsearch</code></a> busca en <code>base[0]...base[n-1]</code> un elemento que coincida
con <code>*key</code>. La funcion <code>emp</code> debe regresar un valor negativo si su
primer argumento (la llave de busqueda) es menor que su segundo
(una entrada en la tabla), cero si es igual, y positivo para
mayor.  Los elementos del arreglo base deben estar en orden
ascendente, <a href="#org37eeea9"><code>bsearch</code></a> regresa un apuntador al elemento
coincidente, o <code>NULL</code> si no existe.
</p>
</div>
</div>

<div id="outline-container-org73f94dc" class="outline-4">
<h4 id="org73f94dc"><a id="org2fd9ddd">=qsort=</a></h4>
<div class="outline-text-4" id="text-org73f94dc">
<div class="org-src-container">
<pre class="src src-c"><span style="color: #98fb98;">void</span> <span style="color: #87cefa;">qsort</span>(<span style="color: #98fb98;">void</span> *<span style="color: #eedd82;">base</span>, <span style="color: #98fb98;">size_t</span> <span style="color: #eedd82;">n</span>, <span style="color: #98fb98;">size_t</span> <span style="color: #eedd82;">size</span>,
           <span style="color: #98fb98;">int</span> (*<span style="color: #87cefa;">cmp</span>)(<span style="color: #00ffff;">const</span> <span style="color: #98fb98;">void</span> *, <span style="color: #00ffff;">const</span> <span style="color: #98fb98;">void</span> *))
</pre>
</div>

<p>
<a href="#org2fd9ddd"><code>qsort</code></a> clasifica en orden ascendente un arreglo
<code>base[0]...base[n-1]</code> de objetos de tamaño <code>size</code>. La funcion de
comparacion <code>emp</code> es como en <a href="#org37eeea9"><code>bsearch</code></a>.
</p>
</div>
</div>

<div id="outline-container-orgc384539" class="outline-4">
<h4 id="orgc384539"><a id="org3dfcf97">=abs=</a></h4>
<div class="outline-text-4" id="text-orgc384539">
<div class="org-src-container">
<pre class="src src-c"><span style="color: #98fb98;">int</span> <span style="color: #87cefa;">abs</span>(<span style="color: #98fb98;">int</span> <span style="color: #eedd82;">n</span>)
</pre>
</div>

<p>
<a href="#org3dfcf97"><code>abs</code></a> regresa el valor absoluto de su argumento <code>int</code>.
</p>
</div>
</div>

<div id="outline-container-orgd65fe31" class="outline-4">
<h4 id="orgd65fe31"><a id="org2c890a8">=labs=</a></h4>
<div class="outline-text-4" id="text-orgd65fe31">
<div class="org-src-container">
<pre class="src src-c"><span style="color: #98fb98;">long</span> <span style="color: #87cefa;">labs</span>(<span style="color: #98fb98;">long</span> <span style="color: #eedd82;">n</span>)
</pre>
</div>

<p>
<a href="#org2c890a8"><code>labs</code></a> regresa el valor absoluto de su argumento <code>long</code>.
</p>
</div>
</div>

<div id="outline-container-org24351e5" class="outline-4">
<h4 id="org24351e5"><a id="orgd98b17e">=div=</a></h4>
<div class="outline-text-4" id="text-org24351e5">
<div class="org-src-container">
<pre class="src src-c"><span style="color: #98fb98;">div_t</span> <span style="color: #87cefa;">div</span>(<span style="color: #98fb98;">int</span> <span style="color: #eedd82;">num</span>, <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">denom</span>)
</pre>
</div>

<p>
<a href="#orgd98b17e"><code>div</code></a> calcula el cociente y el residuo de <code>num/denom</code>. Los
resultados se almacenan en los miembros de tipo <code>int</code> <code>quot</code> y
<code>rem</code> de una estructura de tipo <code>div_t</code>.
</p>
</div>
</div>

<div id="outline-container-org3992958" class="outline-4">
<h4 id="org3992958"><a id="org7cac271">=ldiv=</a></h4>
<div class="outline-text-4" id="text-org3992958">
<div class="org-src-container">
<pre class="src src-c"><span style="color: #98fb98;">ldiv_t</span> <span style="color: #87cefa;">ldiv</span>(<span style="color: #98fb98;">long</span> <span style="color: #eedd82;">num</span>, <span style="color: #98fb98;">long</span> <span style="color: #eedd82;">denom</span>)
</pre>
</div>

<p>
<a href="#org7cac271"><code>ldiv</code></a> calcula el cociente y el residuo de <code>num/denom</code>. Los
resultados son almacenados en los miembros de tipo <code>long</code> <code>quot</code> y
<code>rem</code> de una estructura de tipo <code>ldiv_t</code>.
</p>
</div>
</div>
</div>

<div id="outline-container-orgb109509" class="outline-3">
<h3 id="orgb109509">B6   Diagnosticos: <code>&lt;assert.h&gt;</code>                                    <a id="org218fbcc"></a></h3>
<div class="outline-text-3" id="text-orgb109509">
<p>
La macro <a href="#org2edcd5f"><code>assert</code></a> es usada para agregar diagnosticos a los
programas:
</p>
</div>

<div id="outline-container-orgdc2b15a" class="outline-4">
<h4 id="orgdc2b15a"><a id="org2edcd5f">=assert=</a></h4>
<div class="outline-text-4" id="text-orgdc2b15a">
<div class="org-src-container">
<pre class="src src-c"><span style="color: #98fb98;">void</span> <span style="color: #87cefa;">assert</span>(<span style="color: #98fb98;">int</span> <span style="color: #eedd82;">expression</span>)
</pre>
</div>

<p>
Si <i>expression</i> es cero cuando
</p>

<div class="org-src-container">
<pre class="src src-c"><span style="color: #87cefa;">assert</span> (expression)
</pre>
</div>

<p>
se ejecuta, la macro <a href="#org2edcd5f"><code>assert</code></a> imprimira en <code>stderr</code> un mensaje,
como
</p>

<div class="BLOCK">
<p>
<code>Assertion failed:</code> <i>expression</i>, <code>file</code> <i>filename</i>, <code>line</code> <i>nnn</i>
</p>

</div>

<p>
Despues llama a <a href="#orgd3a6c72"><code>abort</code></a> para terminar la ejecucion. El archivo
fuente <code>filename</code> y el numero de linea viene de las macros
<code>__FILE__</code> y <code>__LINE__</code> del preprocesador.
</p>

<p>
Si <code>NDEBUG</code> esta definido cuando se incluyo <code>&lt;assert.h&gt;</code> se ignora
la macro <a href="#org2edcd5f"><code>assert</code></a>.
</p>
</div>
</div>
</div>

<div id="outline-container-orgfb09ed2" class="outline-3">
<h3 id="orgfb09ed2">B7   Listas de argumentos variables: &lt;stdarg.h&gt;                    <a id="org34ff186"></a></h3>
<div class="outline-text-3" id="text-orgfb09ed2">
<p>
El header <code>&lt;stdarg.h&gt;</code> proporciona recursos para recorrer una lista
de argumentos de funcion de tamaño y tipo desconocido.
</p>

<p>
Supongase que <code>lastarg</code> es el ultimo parametro nombrado de una
funcion <code>f</code> con un numero variable de argumentos. Entonces se
declara dentro de <code>f</code> una variable <code>ap</code> de tipo <code>va_list</code> que
apuntara a cada argumento en orden:
</p>

<div class="org-src-container">
<pre class="src src-c"><span style="color: #98fb98;">va_list</span> <span style="color: #eedd82;">ap</span>;
</pre>
</div>

<p>
<code>ap</code> se debe inicializar una vez con la macro <code>va_start</code> antes de
tener acceso a cualquier argumento no nombrado:
</p>

<div class="org-src-container">
<pre class="src src-c"><span style="color: #87cefa;">va_start</span>(<span style="color: #98fb98;">va_list</span> <span style="color: #eedd82;">ap</span>, lastarg);
</pre>
</div>

<p>
Despues de eso, cada ejecucion de la macro <code>va_arg</code> producira un
valor que tiene el tipo y valor del siguiente argumento no
nombrado, y modificara tambien <code>ap</code> de modo que el proximo uso de
<code>va_arg</code> devuelva el argumento siguiente:
</p>

<pre class="example">
type va_arg(va_list ap, type);
</pre>

<p>
La macro
</p>

<div class="org-src-container">
<pre class="src src-c"><span style="color: #98fb98;">void</span> <span style="color: #87cefa;">va_end</span>(<span style="color: #98fb98;">va_list</span> <span style="color: #eedd82;">ap</span>);
</pre>
</div>

<p>
se debe llamar una vez despues de que han sido procesados los
argumentos, pero antes de haber salido de <code>f</code>.
</p>
</div>
</div>

<div id="outline-container-org5f475fc" class="outline-3">
<h3 id="org5f475fc">B8   Saltos no locales: <code>&lt;setjmp.h&gt;</code>                               <a id="orgc19ca4e"></a></h3>
<div class="outline-text-3" id="text-org5f475fc">
<p>
Las declaraciones que estan en <code>&lt;setjmp.h&gt;</code> proporcionan una forma
de evitar la secuencia normal de llamada y regreso de funciones,
tipicamente para permitir un regreso inmediato de una llamada a una
funcion profundamente anidada.
</p>
</div>

<div id="outline-container-org05c7918" class="outline-4">
<h4 id="org05c7918"><a id="org3c10792">=setjmp=</a></h4>
<div class="outline-text-4" id="text-org05c7918">
<div class="org-src-container">
<pre class="src src-c"><span style="color: #98fb98;">int</span> <span style="color: #87cefa;">setjmp</span>(<span style="color: #98fb98;">jmp_buf</span> <span style="color: #eedd82;">env</span>)
</pre>
</div>

<p>
La macro <a href="#org3c10792"><code>setjmp</code></a> guarda la informacion del estado que se tiene en
<code>env</code> para ser usada por <a href="#org9319002"><code>longjmp</code></a>. El retorno es cero desde una
llamada directa de <a href="#org3c10792"><code>setjmp</code></a> y diferente de cero desde una llamada
subsiguiente a <a href="#org9319002"><code>longjmp</code></a>. Solo puede ocurrir una llamada a
<a href="#org3c10792"><code>setjmp</code></a> dentro de ciertos contextos, basicamente la prueba de
<code>if</code>, <code>switch</code>, y ciclos, y solo en expresiones de relacion
simples.
</p>

<div class="org-src-container">
<pre class="src src-c"><span style="color: #00ffff;">if</span> (setjmp(env) == 0)
  <span style="color: #ff4500;">/* </span><span style="color: #ff4500;">llega aqui en una llamada directa </span><span style="color: #ff4500;">*/</span>
<span style="color: #00ffff;">else</span>
   <span style="color: #ff4500;">/* </span><span style="color: #ff4500;">llega aqui por una llamada de longjmp </span><span style="color: #ff4500;">*/</span>
</pre>
</div>
</div>
</div>

<div id="outline-container-org130f1a5" class="outline-4">
<h4 id="org130f1a5"><a id="org9319002">=longjmp=</a></h4>
<div class="outline-text-4" id="text-org130f1a5">
<div class="org-src-container">
<pre class="src src-c"><span style="color: #98fb98;">void</span> <span style="color: #87cefa;">longjmp</span>(<span style="color: #98fb98;">jmp_buf</span> <span style="color: #eedd82;">env</span>, <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">val</span>)
</pre>
</div>

<p>
<a href="#org9319002"><code>longjmp</code></a> restablece el estado guardado por la llamada mas
reciente de <a href="#org3c10792"><code>setjmp</code></a>, utilizando la informacion almacenada en
<code>env</code>; la ejecucion continua como si la funcion <a href="#org3c10792"><code>setjmp</code></a> solo
hubiera sido llamada y hubiera regresado un valor de <code>val</code>
diferente de cero. La funcion que contiene <a href="#org3c10792"><code>setjmp</code></a> no debe haber
terminado. Los objetos accesibles tienen los valores que tenian en
el momento en que <a href="#org9319002"><code>longjmp</code></a> fue llamada; los valores no son
guardados por <a href="#org3c10792"><code>setjmp</code></a>.
</p>
</div>
</div>
</div>

<div id="outline-container-orgb780161" class="outline-3">
<h3 id="orgb780161">B9   Señales: <code>&lt;signal.h&gt;</code>                                         <a id="org9620aaa"></a></h3>
<div class="outline-text-3" id="text-orgb780161">
<p>
El <i>header</i> <code>&lt;signal.h&gt;</code> proporciona facilidades para manejar
condiciones excepcionales que aparecen durante la ejecucion, tal
como una señal de interrupcion de una fuente externa o un error en
la ejecucion.
</p>
</div>

<div id="outline-container-org7aa0e98" class="outline-4">
<h4 id="org7aa0e98"><a id="org6fd619f">=signal=</a></h4>
<div class="outline-text-4" id="text-org7aa0e98">
<div class="org-src-container">
<pre class="src src-c"><span style="color: #98fb98;">void</span> (*signal(<span style="color: #98fb98;">int</span> <span style="color: #eedd82;">sig</span>, <span style="color: #98fb98;">void</span> (*<span style="color: #87cefa;">handler</span>)(<span style="color: #98fb98;">int</span>)))(<span style="color: #98fb98;">int</span>)
</pre>
</div>

<p>
<a href="#org6fd619f"><code>signal</code></a> determina como se manejaran las señales subsiguientes. Si
<code>handler</code> es <code>SIG_DFL</code>, se usa el comportamiento predefinido por
la implantacion; si es <code>SIG_IGN</code>, la señal se ignora; de otra
manera, se llamara a la funcion apuntada por <code>handler</code>, con los
argumentos del tipo de la señal. Las señales validas incluyen
</p>

<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-left" />

<col  class="org-left" />
</colgroup>
<tbody>
<tr>
<td class="org-left"><code>SIGABRT</code></td>
<td class="org-left">terminacion anormal, p. ej., por <code>abort</code></td>
</tr>

<tr>
<td class="org-left"><code>SIGFPE</code></td>
<td class="org-left">error aritmetico, p. ej., division entre cero o sobreflujo</td>
</tr>

<tr>
<td class="org-left"><code>SIGILL</code></td>
<td class="org-left">imagen de funcion ilegal, p. ej., instruccion ilegal</td>
</tr>

<tr>
<td class="org-left"><code>SIGINT</code></td>
<td class="org-left">atencion ilegal al almacenamiento; p. ej., acceso fuera de los limites</td>
</tr>

<tr>
<td class="org-left"><code>SIGSEGV</code></td>
<td class="org-left">acceso ilegal al almacenamiento, p. ej., acceso fuera de los limites de memoria</td>
</tr>

<tr>
<td class="org-left"><code>SIGTERM</code></td>
<td class="org-left">solicitud de terminacion enviada a este programa</td>
</tr>
</tbody>
</table>

<p>
<a href="#org6fd619f"><code>signal</code></a> regresa el valor previo de <code>handler</code> para la señal
especifica, o <code>SIG_ERR</code> si ocurre un error.
</p>

<p>
Cuando ocurre subsecuentemente una señal <code>sig</code>, la señal se
regresa a su comportamiento predeterminado; luego se llama a la
funcion manejadora de la señal, como si se ejecutara
<code>(*handler)(sig)</code>. Si el manejador regresa, la ejecucion
continuara donde se encontraba cuando ocurrio la señal.
</p>

<p>
El estado inicial de las señales esta definido por la
implantacion.
</p>
</div>
</div>

<div id="outline-container-org1cbd907" class="outline-4">
<h4 id="org1cbd907"><a id="org22feecd">=raise=</a></h4>
<div class="outline-text-4" id="text-org1cbd907">
<div class="org-src-container">
<pre class="src src-c"><span style="color: #98fb98;">int</span> <span style="color: #87cefa;">raise</span>(<span style="color: #98fb98;">int</span> <span style="color: #eedd82;">sig</span>)
</pre>
</div>

<p>
<a href="#org22feecd"><code>raise</code></a> envia la señal <code>sig</code> al programa; regresa un valor
diferente de cero cuando no tiene exito.
</p>
</div>
</div>
</div>

<div id="outline-container-orga2e5f0a" class="outline-3">
<h3 id="orga2e5f0a">B10  Funciones de fecha y hora <code>&lt;time.h&gt;</code>                          <a id="org2b9b115"></a></h3>
<div class="outline-text-3" id="text-orga2e5f0a">
<p>
El <i>header</i> <code>&lt;time.h&gt;</code> declara los tipos y funciones para
manipulacion de fecha y hora. Algunas funciones procesan la <i>hora
local</i>, que puede diferir de la del calendario, por ejemplo, debido
a la zona horaria. <code>clock_t</code> y <code>time_t</code> son tipos aritmeticos que
representan tiempos, y <code>struct tm</code> mantiene las componentes de un
calendario:
</p>

<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-left" />

<col  class="org-left" />
</colgroup>
<tbody>
<tr>
<td class="org-left"><code>int tm_sec</code>;</td>
<td class="org-left">segundos despues del minuto (0,61)</td>
</tr>

<tr>
<td class="org-left"><code>int tm_min</code>;</td>
<td class="org-left">minutos despues de la hora (0,59)</td>
</tr>

<tr>
<td class="org-left"><code>int tm_hour</code>;</td>
<td class="org-left">horas desde la medianoche (0,23)</td>
</tr>

<tr>
<td class="org-left"><code>int tm_mday</code>;</td>
<td class="org-left">dia del mes (1,31)</td>
</tr>

<tr>
<td class="org-left"><code>int tm_mon</code>;</td>
<td class="org-left">meses desde enero (0,11)</td>
</tr>

<tr>
<td class="org-left"><code>int tm_year</code>;</td>
<td class="org-left">años desde 1900</td>
</tr>

<tr>
<td class="org-left"><code>int tm_wday</code>;</td>
<td class="org-left">dias desde el domingo (0,6)</td>
</tr>

<tr>
<td class="org-left"><code>int tm_yday</code>;</td>
<td class="org-left">dias desde enero 1 (0,365)</td>
</tr>

<tr>
<td class="org-left"><code>int tm_isdst</code>;</td>
<td class="org-left">bandera de Horario de Ahorro de Energia (Dayligth Saving Time)</td>
</tr>
</tbody>
</table>

<p>
<code>tm_isdst</code> es positiva si Horario de Ahorro de Energia esta en
efecto, cero si no lo esta y negativa si la informacion no esta
disponible.
</p>
</div>

<div id="outline-container-org8ba1343" class="outline-4">
<h4 id="org8ba1343"><a id="org2c32cbb">=clock=</a></h4>
<div class="outline-text-4" id="text-org8ba1343">
<div class="org-src-container">
<pre class="src src-c"><span style="color: #98fb98;">clock_t</span> <span style="color: #87cefa;">clock</span>(<span style="color: #98fb98;">void</span>)
</pre>
</div>

<p>
<a href="#org2c32cbb"><code>clock</code></a> regresa el tiempo de procesador empleado por el programa
desde el inicio de su ejecucion, o <code>-1</code> si no esta
disponible. <code>clock()/CLK_PER_SEC</code> es el tiempo en segundos.
</p>
</div>
</div>

<div id="outline-container-org8681d60" class="outline-4">
<h4 id="org8681d60"><a id="org4ff452b">=time=</a></h4>
<div class="outline-text-4" id="text-org8681d60">
<div class="org-src-container">
<pre class="src src-c"><span style="color: #98fb98;">time_t</span> <span style="color: #87cefa;">time</span>(<span style="color: #98fb98;">time_t</span> *<span style="color: #eedd82;">tp</span>)
</pre>
</div>

<p>
<a href="#org4ff452b"><code>time</code></a> regresa la fecha y hora actual del calendario, o <code>-1</code> si no
esta disponible. Si <code>tp</code> no es <code>NULL</code>, el valor de retorno tambien
es asignado a <code>*tp</code>.
</p>
</div>
</div>

<div id="outline-container-org164a7ce" class="outline-4">
<h4 id="org164a7ce"><a id="orgf92b994">=difftime=</a></h4>
<div class="outline-text-4" id="text-org164a7ce">
<div class="org-src-container">
<pre class="src src-c"><span style="color: #98fb98;">double</span> <span style="color: #87cefa;">difftime</span>(<span style="color: #98fb98;">time_t</span> <span style="color: #eedd82;">time2</span>, <span style="color: #98fb98;">time_t</span> <span style="color: #eedd82;">time1</span>)
</pre>
</div>

<p>
<code>diiitime</code> regresa <code>time2-time1</code> expresado en segundos.
</p>
</div>
</div>

<div id="outline-container-orge1c018e" class="outline-4">
<h4 id="orge1c018e"><a id="org631f284">=mktime=</a></h4>
<div class="outline-text-4" id="text-orge1c018e">
<div class="org-src-container">
<pre class="src src-c"><span style="color: #98fb98;">time_t</span> <span style="color: #87cefa;">mktime</span>(<span style="color: #00ffff;">struct</span> <span style="color: #98fb98;">tm</span> *<span style="color: #eedd82;">tp</span>)
</pre>
</div>

<p>
<a href="#org631f284"><code>mktime</code></a> convierte la fecha y hora local de la estructura <code>*tp</code> a
fecha y hora del calendario en la misma representacion utilizada
por <a href="#org4ff452b"><code>time</code></a>. Los componentes tendran valores dentro de los rangos
mostrados, <a href="#org631f284"><code>mktime</code></a> regresa la fecha y hora del calendario, o <code>-1</code>
si no puede ser representada.
</p>

<p>
Las siguientes cuatro funciones regresan apuntadores a objetos
estaticos que pueden ser sobrescritos por otras llamadas.
</p>
</div>
</div>

<div id="outline-container-org8cd5afe" class="outline-4">
<h4 id="org8cd5afe"><a id="org035578e">=asctime=</a></h4>
<div class="outline-text-4" id="text-org8cd5afe">
<div class="org-src-container">
<pre class="src src-c"><span style="color: #98fb98;">char</span> *<span style="color: #87cefa;">asctime</span>(<span style="color: #00ffff;">const</span> <span style="color: #00ffff;">struct</span> <span style="color: #98fb98;">tm</span> *<span style="color: #eedd82;">tp</span>)
</pre>
</div>

<p>
<a href="#org035578e"><code>asctime</code></a> convierte la hora de la estructura <code>*tp</code> a una cadena de
la forma
</p>

<pre class="example">
Sun Jan  3 15:14:13 1988\n\0
</pre>
</div>
</div>

<div id="outline-container-orga73b0a1" class="outline-4">
<h4 id="orga73b0a1"><a id="orgac352a5">=ctime=</a></h4>
<div class="outline-text-4" id="text-orga73b0a1">
<div class="org-src-container">
<pre class="src src-c"><span style="color: #98fb98;">char</span> *<span style="color: #87cefa;">ctime</span>(<span style="color: #00ffff;">const</span> <span style="color: #98fb98;">time_t</span> *<span style="color: #eedd82;">tp</span>)
</pre>
</div>

<p>
<a href="#orgac352a5"><code>ctime</code></a> convierte la hora del calendario <code>*tp</code> a hora local; es
equivalente a
</p>

<div class="org-src-container">
<pre class="src src-c"><span style="color: #87cefa;">asctime</span>(<span style="color: #98fb98;">localtime</span>(<span style="color: #eedd82;">tp</span>))
</pre>
</div>
</div>
</div>

<div id="outline-container-orgb4d4246" class="outline-4">
<h4 id="orgb4d4246"><a id="org0a2e495">=gmtime=</a></h4>
<div class="outline-text-4" id="text-orgb4d4246">
<div class="org-src-container">
<pre class="src src-c"><span style="color: #00ffff;">struct</span> <span style="color: #98fb98;">tm</span> *<span style="color: #87cefa;">gmtime</span>(<span style="color: #00ffff;">const</span> <span style="color: #98fb98;">time_t</span> *<span style="color: #eedd82;">tp</span>)
</pre>
</div>

<p>
<a href="#org0a2e495"><code>gmtime</code></a> convierte la hora del calendario <code>*tp</code> a Hora Coordinada
Universal (Coordinated Universal Time &#x2013;UTC). Regresa <code>NULL</code> si
<code>UTC</code> no esta disponible. El nombre <a href="#org0a2e495"><code>gmtime</code></a> tiene significado
historico.
</p>
</div>
</div>

<div id="outline-container-orge2b8274" class="outline-4">
<h4 id="orge2b8274"><a id="orge349763">=localtime=</a></h4>
<div class="outline-text-4" id="text-orge2b8274">
<div class="org-src-container">
<pre class="src src-c"><span style="color: #00ffff;">struct</span> <span style="color: #98fb98;">tm</span> *<span style="color: #87cefa;">localtime</span>(<span style="color: #00ffff;">const</span> <span style="color: #98fb98;">time_t</span> *<span style="color: #eedd82;">tp</span>)
</pre>
</div>

<p>
<a href="#orge349763"><code>localtime</code></a> convierte la hora del calendario <code>*tp</code> a hora local.
</p>
</div>
</div>

<div id="outline-container-org44519fe" class="outline-4">
<h4 id="org44519fe"><a id="org122fd9c">=strftime=</a></h4>
<div class="outline-text-4" id="text-org44519fe">
<div class="org-src-container">
<pre class="src src-c"><span style="color: #98fb98;">size_t</span> <span style="color: #87cefa;">strftime</span>(<span style="color: #98fb98;">char</span> *<span style="color: #eedd82;">s</span>, <span style="color: #98fb98;">size_t</span> <span style="color: #eedd82;">smax</span>, <span style="color: #00ffff;">const</span> <span style="color: #98fb98;">char</span> *<span style="color: #eedd82;">fmt</span>, <span style="color: #00ffff;">const</span> <span style="color: #00ffff;">struct</span> <span style="color: #98fb98;">tm</span> *<span style="color: #eedd82;">tp</span>)
</pre>
</div>

<p>
<a href="#org122fd9c"><code>strftime</code></a> da formato a la hora y fecha de <code>*tp</code> en <code>s</code> de acuerdo
con <code>fmt</code>, que es analogo al formato <a href="#org0458a76"><code>printf</code></a>. Los caracteres
ordinarios (incluyendo la terminacion '\0') se copian dentro de
<code>s</code>. Cada <code>%c</code> se reemplaza como se describe abajo, utilizando los
valores apropiados del entorno. En <code>s</code> no se colocan mas de <code>smax</code>
caracteres, <a href="#org122fd9c"><code>strftime</code></a> regresa el numero de caracteres, excluyendo
el '\0', o cero si fueron producidos mas de <code>smax</code> caracteres.
</p>

<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-left" />

<col  class="org-left" />
</colgroup>
<tbody>
<tr>
<td class="org-left"><code>%a</code></td>
<td class="org-left">nombre abreviado del dia de la semana.</td>
</tr>

<tr>
<td class="org-left"><code>%A</code></td>
<td class="org-left">nombre completo de la semana.</td>
</tr>

<tr>
<td class="org-left"><code>%b</code></td>
<td class="org-left">nombre abreviado del mes.</td>
</tr>

<tr>
<td class="org-left"><code>%B</code></td>
<td class="org-left">nombre completo del mes.</td>
</tr>

<tr>
<td class="org-left"><code>%c</code></td>
<td class="org-left">representacion local de fecha y hora.</td>
</tr>

<tr>
<td class="org-left"><code>%d</code></td>
<td class="org-left">dia del mes (01-31).</td>
</tr>

<tr>
<td class="org-left"><code>%H</code></td>
<td class="org-left">hora (reloj de 24 horas) (00-23).</td>
</tr>

<tr>
<td class="org-left"><code>%I</code></td>
<td class="org-left">hora (reloj de 12 horas) (01-12).</td>
</tr>

<tr>
<td class="org-left"><code>%j</code></td>
<td class="org-left">dia del año (001-366).</td>
</tr>

<tr>
<td class="org-left"><code>%m</code></td>
<td class="org-left">mes (01-12).</td>
</tr>

<tr>
<td class="org-left"><code>%M</code></td>
<td class="org-left">minuto (00-59).</td>
</tr>

<tr>
<td class="org-left"><code>%p</code></td>
<td class="org-left">equivalencia local de AM o PM.</td>
</tr>

<tr>
<td class="org-left"><code>%S</code></td>
<td class="org-left">segundos (00-61).</td>
</tr>

<tr>
<td class="org-left"><code>%U</code></td>
<td class="org-left">numero de semana del año (domingo es el primer dia de la semana) (00-53).</td>
</tr>

<tr>
<td class="org-left"><code>%w</code></td>
<td class="org-left">dia de la semana (0-6, domingo es 0).</td>
</tr>

<tr>
<td class="org-left"><code>%W</code></td>
<td class="org-left">numero de semana del año (lunes es el primer dia de la semana) (00-53).</td>
</tr>

<tr>
<td class="org-left"><code>%x</code></td>
<td class="org-left">representacion local de la fecha.</td>
</tr>

<tr>
<td class="org-left"><code>%X</code></td>
<td class="org-left">representacion local de la hora.</td>
</tr>

<tr>
<td class="org-left"><code>%y</code></td>
<td class="org-left">año sin el siglo (00-99).</td>
</tr>

<tr>
<td class="org-left"><code>%Y</code></td>
<td class="org-left">año con el siglo.</td>
</tr>

<tr>
<td class="org-left"><code>%Z</code></td>
<td class="org-left">nombre de la zona horaria, si existe.</td>
</tr>

<tr>
<td class="org-left"><code>%%</code></td>
<td class="org-left">%.</td>
</tr>
</tbody>
</table>
</div>
</div>
</div>

<div id="outline-container-orgbdb4c59" class="outline-3">
<h3 id="orgbdb4c59">B11  Limites definidos en la implantacion: <code>&lt;limits.h&gt;</code> y <code>&lt;float.h&gt;</code>  <a id="orgd03f2b9"></a></h3>
<div class="outline-text-3" id="text-orgbdb4c59">
<p>
El <i>header</i> <code>&lt;limits.h&gt;</code> define constantes para el tamaño de los
tipos enteros. Los valores mostrados son magnitudes minimas
aceptables; se pueden emplear valores mayores.
</p>

<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-left" />

<col  class="org-right" />

<col  class="org-left" />
</colgroup>
<tbody>
<tr>
<td class="org-left"><code>CHAR_BIT</code></td>
<td class="org-right">8</td>
<td class="org-left">bits en un <code>char</code></td>
</tr>

<tr>
<td class="org-left"><code>CHAR_MAX</code></td>
<td class="org-right"><code>UCHAR_MAX</code> or <code>SCHAR_MAX</code></td>
<td class="org-left">valor maximo de <code>char</code></td>
</tr>

<tr>
<td class="org-left"><code>CHAR_MIN</code></td>
<td class="org-right">0 or <code>SCHAR_MIN</code></td>
<td class="org-left">valor minimo de <code>char</code></td>
</tr>

<tr>
<td class="org-left"><code>INT_MAX</code></td>
<td class="org-right">+32767</td>
<td class="org-left">valor maximo de <code>int</code></td>
</tr>

<tr>
<td class="org-left"><code>INT_MIN</code></td>
<td class="org-right">-32767</td>
<td class="org-left">valor minimo de <code>int</code></td>
</tr>

<tr>
<td class="org-left"><code>LONG_MAX</code></td>
<td class="org-right">+2147483647</td>
<td class="org-left">valor maximo de <code>long</code></td>
</tr>

<tr>
<td class="org-left"><code>LONG_MIN</code></td>
<td class="org-right">-2147483647</td>
<td class="org-left">valor minimo de <code>long</code></td>
</tr>

<tr>
<td class="org-left"><code>SCHAR_MAX</code></td>
<td class="org-right">+127</td>
<td class="org-left">valor maximo de <code>signed char</code></td>
</tr>

<tr>
<td class="org-left"><code>SCHAR_MIN</code></td>
<td class="org-right">-127</td>
<td class="org-left">valor minimo de <code>signed char</code></td>
</tr>

<tr>
<td class="org-left"><code>SHRT_MAX</code></td>
<td class="org-right">+32767</td>
<td class="org-left">valor maximo de <code>short</code></td>
</tr>

<tr>
<td class="org-left"><code>SHRT_MIN</code></td>
<td class="org-right">-32767</td>
<td class="org-left">valor minimo de <code>short</code></td>
</tr>

<tr>
<td class="org-left"><code>UCHAR_MAX</code></td>
<td class="org-right">255</td>
<td class="org-left">valor maximo de <code>unsigned char</code></td>
</tr>

<tr>
<td class="org-left"><code>UINT_MAX</code></td>
<td class="org-right">65535</td>
<td class="org-left">valor maximo de <code>unsigned int</code></td>
</tr>

<tr>
<td class="org-left"><code>ULONG_MAX</code></td>
<td class="org-right">4294967295</td>
<td class="org-left">valor maximo de <code>unsigned long</code></td>
</tr>

<tr>
<td class="org-left"><code>USHRT_MAX</code></td>
<td class="org-right">65535U</td>
<td class="org-left">valor maximo de <code>unsigned short</code></td>
</tr>
</tbody>
</table>

<p>
Los nombres de la tabla siguiente, subconjunto de <code>&lt;float.h&gt;</code>, son
constantes relacionadas con la aritmetica de punto flotante. Cuando
se da un valor, representa la magnitud minima para la cantidad
correspondiente. Cada implantacion define los valores apropiados.
</p>

<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-left" />

<col  class="org-right" />

<col  class="org-left" />
</colgroup>
<tbody>
<tr>
<td class="org-left"><code>FLT_RADIX</code></td>
<td class="org-right">2</td>
<td class="org-left">radical de la representacion exponencial, p. ej., 2, 16</td>
</tr>

<tr>
<td class="org-left"><code>FLT_ROUNDS</code></td>
<td class="org-right">&#xa0;</td>
<td class="org-left">modo de redondeo de punto flotante para adicion</td>
</tr>

<tr>
<td class="org-left"><code>FLT_DIG</code></td>
<td class="org-right">6</td>
<td class="org-left">digitos decimales de precision</td>
</tr>

<tr>
<td class="org-left"><code>FLT_EPSILON</code></td>
<td class="org-right">1E-5</td>
<td class="org-left">menor numero x tal que 1.0 + x &ne; 1.0</td>
</tr>

<tr>
<td class="org-left"><code>FLT_MANT_DIG</code></td>
<td class="org-right">&#xa0;</td>
<td class="org-left">numero de digitos de base <code>FLT_RADIX</code> en la mantisa</td>
</tr>

<tr>
<td class="org-left"><code>FLT_MAX</code></td>
<td class="org-right">1E+37</td>
<td class="org-left">maximo numero de punto flotante</td>
</tr>

<tr>
<td class="org-left"><code>FLT_MAX_EXP</code></td>
<td class="org-right">&#xa0;</td>
<td class="org-left">maximo n tal que ~FLT<sub>RADIX</sub>~<sup>n</sup>-1 es representable</td>
</tr>

<tr>
<td class="org-left"><code>FLT_MIN</code></td>
<td class="org-right">1E-37</td>
<td class="org-left">minimo numero normalizado de punto flotante</td>
</tr>

<tr>
<td class="org-left"><code>FLT_MIN_EXP</code></td>
<td class="org-right">&#xa0;</td>
<td class="org-left">minimo n tal que 10<sup>n</sup> es un numero normalizado</td>
</tr>

<tr>
<td class="org-left"><code>DBL_DIG</code></td>
<td class="org-right">10</td>
<td class="org-left">digitos decimales de precision</td>
</tr>

<tr>
<td class="org-left"><code>DBL_EPSILON</code></td>
<td class="org-right">1E-9</td>
<td class="org-left">menor numero x tal que 1.0 + x &ne; 1.0</td>
</tr>

<tr>
<td class="org-left"><code>DBL_MANT_DIG</code></td>
<td class="org-right">&#xa0;</td>
<td class="org-left">numero de digitos de base <code>FLT_RADIX</code> en la mantisa</td>
</tr>

<tr>
<td class="org-left"><code>DBL_MAX</code></td>
<td class="org-right">1E+37</td>
<td class="org-left">maximo numero double de punto flotante</td>
</tr>

<tr>
<td class="org-left"><code>DBL_MAX_EXP</code></td>
<td class="org-right">&#xa0;</td>
<td class="org-left">maximo n tal que ~FLT<sub>RADIX</sub>~<sup>n</sup>-1 es representable</td>
</tr>

<tr>
<td class="org-left"><code>DBL_MIN</code></td>
<td class="org-right">1E-37</td>
<td class="org-left">minimo numero double normalizado de punto flotante</td>
</tr>

<tr>
<td class="org-left"><code>DBL_MIN_EXP</code></td>
<td class="org-right">&#xa0;</td>
<td class="org-left">minimo n tal que 10<sup>n</sup> es un numero normalizado</td>
</tr>
</tbody>
</table>
</div>
</div>
</div>

<div id="outline-container-org38daa93" class="outline-2">
<h2 id="org38daa93">Apendice C: Resumen de modificaciones                               <a id="org2311eb8"></a></h2>
<div class="outline-text-2" id="text-org38daa93">
<p>
Desde la publicacion de la primera edicion de este libro, la
definicion del lenguaje C ha sufrido modificaciones. Casi todas
fueron extensiones al lenguaje original, y fueron diseñadas
cuidadosamente para permanecer compatibles con la practica
existente; algunas repararon ambigüedades de la descripcion
original, y otras representan modificaciones de la practica
existente. Muchas de las nuevas caracteristicas se anunciaron en los
documentos que acompañan a los compiladores disponibles de AT&amp;T, y
posteriormente se han adoptado por otros proveedores de compiladores
del lenguaje C. Recientemente, el comite ANSI incorporo mas de esos
cambios estandarizando el lenguaje, y tambien introdujo otras
modificaciones significativas. Su reporte fue en parte anticipado
por algunos compiladores comerciales aun antes de la publicacion del
estandar formal.
</p>

<p>
Este apendice resume las diferencias entre el lenguaje definido por
la primera edicion de este libro, y lo esperado como la definicion
del estandar final. Trata solamente al lenguaje en si, no a su
entorno ni a su biblioteca; aunque esas son partes importantes del
estandar, hay poco con que compararlas, puesto que en la primera
edicion no se intento definirlas.
</p>

<ul class="org-ul">
<li>El preprocesamiento esta definido mas cuidadosamente en el
Estandar que en la primera edicion, y esta extendido: esta
explicitamete basado en tokens (simbolos); existen nuevos
operadores para la concatenacion de tokens (<code>##</code>) y creacion de
cadenas (<code>#</code>); hay nuevas lineas de control como <code>#elif</code> y
<code>#pragma</code>; esta explicitamente permitida la redeclaracion de
macros por la misma secuencia de tokens; ya no se reemplazan los
parametros que estan dentro de cadenas. La separacion de lineas
por <code>\</code> esta permitida en cualquier lugar, no solo en definiciones
de cadenas y macros. Vease <a href="#orgc912dbd">A12</a>.</li>

<li>El significado minimo al mas pequeño de todos los identificadores
internos se incremento a 31 caracteres; permitido para
identificadores con enlace externo permanece en 6 letras, sin
importar sin son mayusculas o minusculas (muchas implantaciones
proporcionan mas).</li>

<li>Las secuencias trigraficas introducidas por <code>??</code> permiten la
representacion de caracteres que no se encuentran en algunos
conjuntos. Estan definidos los escapes para <code>#\^[]{}|~</code> Vease
<a href="#org3e9aa75">A12.1</a>. Observese que la introduccion de trigrafos puede cambiar
el significado de cadenas que contengan la secuencia <code>??</code>.</li>

<li>Se introdujeron nuevas palabras reservadas (<code>void</code>, <code>const</code>,
<code>volatile</code>, <code>signed</code>, <code>enum</code>). La palabra reservada <code>entry</code>, que
nunca se puso en uso, fue retirada.</li>

<li>Se definen nuevas secuencias de escape para uso dentro de
constantes de caracter y cadenas literales. El efecto de seguir
<code>\</code> con un caracter que no sea parte de una secuencia de escape
aprobada esta indefinido. Vease <a href="#org4b66d10">A2.5.2</a>.</li>

<li>El trivial cambio favorito de todos: 8 y 9 no son digitos
octales.</li>

<li>El estandar introduce un conjunto mas grande de sufijos para
hacer explicito el tipo de constantes: <code>U</code> o <code>L</code> para enteros, <code>F</code>
o <code>L</code> para flotantes. Tambien afina las reglas para el uso de
constantes sin sufijo (<a href="#orgec95c5f">A2.5</a>).</li>

<li>Las cadenas literales adyacentes se concatenan.</li>

<li>Existe una notacion para cadenas literales amplias de caracteres
y constantes de caracter. Vease <a href="#org3acb960">A2.6</a>.</li>

<li>Los caracteres, asi como otros tipos, pueden ser explicitamente
declarados para tener o no signo, utilizando las palabras
reservadas <code>signed</code> o <code>unsigned</code>. Se retiro la locucion <code>long
    float</code> como un sinonimo para <code>double</code>, pero <code>long double</code> puede
ser utilizada para declarar una cantidad flotante de precision
extra.</li>

<li>Por algun tiempo, el tipo <code>unsigned char</code> ha estado
disponible. El estandar introduce la palabra reservada <code>signed</code>
para hacer explicito el signo para char y otros objetos enteros.</li>

<li>Por algunos años, el tipo <code>void</code> ha estado disponible en algunas
implantaciones. El estandar introduce el uso del tipo <code>void *</code>
como un tipo de apuntador generico; anteriormente <code>char *</code>
desempeño este papel. Al mismo tiempo, se crearon reglas
explicitas contra la mezcla de apuntadores y enteros, y de
apuntadores de diferente tipo, sin el uso de operadores cast.</li>

<li>El estandar fija minimos explicitos en los rangos de tipos
aritmeticos y delega a los archivos <i>header</i> (<code>&lt;limits.h&gt;</code> y
<code>&lt;float.h&gt;</code>) el dar las caracteristicas de cada implantacion
particular.</li>

<li>Las enumeraciones son algo nuevo desde la primera edicion de este
libro.</li>

<li>El estandar adopta de C++ la nocion de calificador de tipo, por
ejemplo, <code>const</code> (<a href="#org963fdbc">A8.2</a>).</li>

<li>Las cadenas ya no son modificables, por lo que pueden situarse en
memoria de solo lectura.</li>

<li>Se cambiaron las "convenciones aritmeticas usuales",
esencialmente de "para enteros, <code>unsigned</code> siempre gana; para
punto flotante, siempre use <code>double</code>" a "promueva al tipo mas
pequeño de suficiente capacidad". Vease <a href="#orga718883">A6.5</a>.</li>

<li>Los antiguos operadores de asignacion como <code>=+</code> realmente
desaparecieron. Tambien, los operadores de asignacion son ahora
tokens sencillos; en la primera edicion fueron parejas y se podian
separar por espacio en blanco.</li>

<li>Se cancelo la licencia del compilador para tratar a los
operadores matematicamente asociativos como computacionalmente
asociativos.</li>

<li>Se introdujo un operador unario <code>+</code> por simetria con el <code>-</code>
unario.</li>

<li>Un apuntador a una funcion se puede utilizar como un designador
de funcion sin un operador <code>*</code> explicito. Vease <a href="#org2308e57">A7.3.2</a>.</li>

<li>Las estructuras se pueden asignar, pasar a funciones, y regresar
por funciones.</li>

<li>Esta permitido aplicar el operador "direccion de" a arreglos, y
el resultado es un apuntador al arreglo.</li>

<li>El operador <code>sizeof</code>, en la primera edicion, daba el tipo <code>int</code>;
posteriormente, muchas implantaciones lo hicieron <code>unsigned</code>. El
estandar hace el tipo explicitamente dependiente de la
implantacion pero requiere que el tipo <code>size_t</code> sea definido en un
<i>header</i> estandar (<code>&lt;stddef.h&gt;</code>). Un cambio semejante ocurre en el
tipo (<code>ptrdiff_t</code>) de la diferencia entre apuntadores. Vease
<a href="#org4f5a9fa">A7.4.8</a> y <a href="#org3e54edb">A7.7</a>.</li>

<li>El operador <code>&amp;</code> ("direccion de") no se puede aplicar a un objeto
declarado <code>register</code>, aun si la implantacion decide no mantener al
objeto en un registro.</li>

<li>El tipo de una expresion de corrimiento es el del operando de la
izquierda; el operando de la derecha no puede promover el
resultado. Vease <a href="#org680c1fc">A7.8</a>.</li>

<li>El estandar legaliza la creacion de un apuntador justo mas alla
del fin de un arreglo y permite aritmetica y relaciones sobre el;
Vease <a href="#org3e54edb">A7.7</a>.</li>

<li>El estandar introduce (tomandolo de C++) la nocion de declaracion
de una funcion prototipo que incorpora los tipos de los
parametros, e incluye un reconocimiento explicito de funciones con
listas variables de argumentos, junto con una forma aprobada de
tratarlas. Vease <a href="#org2308e57">A7.3.2</a>, <a href="#org0d15d1b">A8.6.3</a> y <a href="#org34ff186">B7</a>. El estilo antiguo todavia se
acepta, con restricciones.</li>

<li>Las declaraciones vacias, que no tienen declaradores y no
declaran al menos a una estructura, union o enumeracion, estan
prohibidas por el estandar. Por otro lado, una declaracion con
solo un rotulo de estructura o de union, redeclara ese rotulo aun
si fue declarado en un alcance mas externo.</li>

<li>Estan prohibidas las declaraciones externas sin ningun
especificador o calificador (con solo el declarador).</li>

<li>Algunas implantaciones, cuando examinan una declaracion <code>extern</code>
en un bloque mas interno, podian exportar la declaracion al resto
del archivo. El estandar hace claro que el alcance de tal
declaracion es solo el bloque.</li>

<li>El alcance de los parametros se introduce en la proposicion
compuesta de una funcion, asi que las declaraciones de variables
en el nivel superior de la funcion no pueden ocultar los
parametros.</li>

<li>Los espacios de nombre de los identificadores son algo
diferentes. El estandar pone todos los rotulos en un espacio
sencillo de nombre, y tambien introduce un espacio separado de
nombres para etiquetas; vease <a href="#org5acc4e3">A11.1</a>. Los nombres de miembros
tambien estan asociados con la estructura o union de la que son
parte (esto ha sido practica comun por algun tiempo).</li>

<li>Las uniones se pueden inicializar; el inicializador se refiere al
primer miembro.</li>

<li>Las estructuras, uniones y arreglos automaticos se puede
inicializar, aunque en una forma restringida.</li>

<li>Los arreglos de caracteres con tamaño explicito se pueden
inicializar con una cadena literal con exactamente la misma
cantidad de caracteres (el \0 se excluye calladamente).</li>

<li>La expresion de control y las etiquetas de las alternativas de un
<code>switch</code>, pueden tener cualquier tipo entero.</li>
</ul>
</div>
</div>
</div>
</body>
</html>
