<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Go on nba - GNU&#39;s Rock</title>
    <link>https://nasciiboy.github.io/tags/go/</link>
    <description>Recent content in Go on nba - GNU&#39;s Rock</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>es</language>
    <copyright>GPL v3.0</copyright>
    <lastBuildDate>Wed, 28 Mar 2018 14:53:20 -0600</lastBuildDate>
    
        <atom:link href="https://nasciiboy.github.io/tags/go/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>GDP</title>
      <link>https://nasciiboy.github.io/prog/gdp/</link>
      <pubDate>Wed, 28 Mar 2018 14:53:20 -0600</pubDate>
      
      <guid>https://nasciiboy.github.io/prog/gdp/</guid>
      <description>

&lt;p&gt;&lt;strong&gt;Go Design Patterns&lt;/strong&gt;, es un libro enfocado en los patrones de diseño
implementados en Go&amp;hellip;&lt;/p&gt;

&lt;p&gt;El material de esta ocacion, viene (o lo encontre) en presentacion de pdf, con
una extencion de aproximadamente 400 paginas en letra grande.&lt;/p&gt;

&lt;p&gt;El primer 15% es un sobrevuelo de las caracteristicas del lenguaje de
programacion Go. Nada profundo, pero viene bien como recordatorio de como es
esto de Go&lt;/p&gt;

&lt;p&gt;El siguiente 55% nos muestran la implementacion de los &amp;ldquo;clasicos&amp;rdquo; patrones
includidos en el GoF y el resto ilustra maneras de aprovechar las
caracteristicas concurrentes del lenguaje (gorutinas y canales) reimplementando
algunos patrones y mostrando un par especificos de esta tematica&lt;/p&gt;

&lt;p&gt;La ideologia programacional-didactica que imparte el autor se llama
&lt;a href=&#34;https://es.wikipedia.org/wiki/Desarrollo_guiado_por_pruebas&#34;&gt;TDD&lt;/a&gt; (Test-driven
development). Aunque me parece algo aburrida y monotona (hacer la prueba,
fallar, refactorizar, hacer la prueba, acercarse al comportamiento,
refactorizar, etc, etc) conicido en que las pruebas son un buen punto de
referencia para afrontar un problema, pues:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;Si es dificil realizar una prueba a tu codigo, seguramente este mal planteado,
ya sea por realizar demaciadas cosas, recibir demaciados parametros, regresar
variados resultados&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Son una garantia de que las nuevas modificaciones no rompan con el comportamiento
establecido&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;aun asi, el TDD como mantra sigue sin convencerme. Por la demas, cada patron
se divide mas o menos en las secciones Descripcion, Objetivos, Criterios de
aceptacion, Pruebas de unidad, Implementacion y &amp;ldquo;resumen-reflexion-o-algo&amp;rdquo;.&lt;/p&gt;

&lt;p&gt;El acercamiento que tome, por resultarme tedioso y aburrido lo relacionado con
la TDD, fue leer todo ignorando criterios de aceptacion y pruebas de unidad para
ir directamente al codigo, descifrarlo y verlo funcionar, luego ante alguna duda
ya leer la seccion de implementacion y pasar al resumen-o-algo&lt;/p&gt;

&lt;p&gt;Los primeros capitulos, dedicados a los patrones estructurales y de creacion,
son bastante desabridos. Basicamente se podrian resumir en simples
interfaces. Pero cuando se llega a los patrones de comportamiento, el codigo se
convierte en ludicos rompecabezas (no frustrantes) y con concurrencia mejoran
aun mas. La implemantacion del patron &lt;code&gt;Pipeline&lt;/code&gt; es una gozada de sencilles y
genialidad que unicamente podria implementarse en Go con tanta genialidad
(aunque creo que en el TGPL lo muestran aun mejor implementando una pasteleria)&lt;/p&gt;

&lt;p&gt;mencionar que el codigo fuente no incluye ni un puñetero comentario, yeee! este
sujeto es de mi escuela de pensamiento&amp;hellip; No temais, entre los nombres, tipos,
funciones del paquete en conjuncion con las acciones dentro de las pruebas es
suficiente para entender lo que se esta intentando demostrar. Diria que en caso
de amnesias mentales, en lugar de revisitar el libro, es mas interesante ir
directo al codigo, y si tienes la suficiente determinacion, ni siquiera hace
falta leer el libro&lt;/p&gt;

&lt;p&gt;por la demas, la lectura es amena y rapida, no se esfuersa en repetir lo que en
otros libros (como el mismo GoF) encontrarias mas y mejor detallado, se decanta
por enseñar formas idiomaticas de aprovechar el lenguaje&lt;/p&gt;

&lt;h2 id=&#34;notas&#34;&gt;Notas&lt;/h2&gt;

&lt;p&gt;el codigo fuente, del libro esta disponible en
&lt;a href=&#34;https://github.com/PacktPublishing/Go-Design-Patterns&#34;&gt;github&lt;/a&gt; pero aunque la
mayoria esta listo para compilar/probar uno que otro tiene fallos, no se si
intencionales, como por ejemplo en el penultimo capitulo, para ejecutar el
codigo es necesario renombrarlo, reorganizarlo y ocacionalmente modificar y/o
agregar alguna funcion o libreria. Ya en el capitulo 10 ni se molestan
(literalmente) en terminar la escritura, el primer fichero trae una funcion a
medio hacer y poco mas&amp;hellip; coloque una
&lt;a href=&#34;https://github.com/PacktPublishing/Go-Design-Patterns/issues/1&#34;&gt;issue&lt;/a&gt;,
esperando que corrijan el asunto&amp;hellip; pero no espero nada, es un libro &amp;ldquo;de
maquila&amp;rdquo;, con mas de un año en el mercado, un mercado inundado de material
generico donde apenas alguien tiene interes en ellos y las unicas ventas,
ocurren casi por equivocacion, ja, ja, ja, la ruleta rusa de los libros!&lt;/p&gt;

&lt;p&gt;el primer error que detecte en el codigo, esta en &lt;code&gt;Chapter02/prototype.go&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;func GetShirtsCloner() ShirtCloner {
    return nil
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;el asunto, es que la funcion regresa un &lt;code&gt;nil&lt;/code&gt; para una interfaz que tiene como
contrato una funcion &lt;code&gt;GetClone(m int) (ItemInfoGetter, error)&lt;/code&gt; que solo es
cumplida por la estructura &lt;code&gt;ShirtsCache&lt;/code&gt; por su metodo &lt;code&gt;GetClone&lt;/code&gt; aplicado en
un puntero a la funcion&amp;hellip;&lt;/p&gt;

&lt;p&gt;Al principio me jodio la mente pensando en que dicho codigo pudiera funsionar.
Comor? un nil convirtiendose en una interfaz para una estructura que no se
declara explicitamente? Go hace este tipo de magia (me pregunte) &amp;hellip; y nop,
para que la cosa funcione &lt;code&gt;GetShirtsCloner&lt;/code&gt; debe regresar &lt;code&gt;new(ShirtsCache)&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;En el capitulo 8, fue necesario aislar un par de ficheros para ejecutar el patron
singleton (concurrente con canales)&lt;/p&gt;

&lt;p&gt;En el capitulo 9, hubo que reorganizar todos los ficheros y modificarlos un poco&lt;/p&gt;

&lt;p&gt;Y el 10 directamente no esta hecho. Me habia planteado terminarlos, sin embargo,
como la metodolagia que habia adoptado era ir directamente al codigo, esta vez
inexistente, y mi forma de aproximarme al libro fue con una traduccion no
humana, no fui capaz (ni me esforce) en enterder que demonios decia. Es una
lastima, por que dicho capitulo mostraba (creo) como limitar la cantidad de gorutinas
en ejecucion, como finalizar la ejecucion de una gorutina y un codigo final que
incluia de todo un poco&lt;/p&gt;

&lt;p&gt;Como nota final en una parte del patron State, mencionan un FSM que al parecer
no solo se refiere al buen &lt;strong&gt;monstruo de espagueti volador&lt;/strong&gt; o
&lt;a href=&#34;https://en.wikipedia.org/wiki/Flying_Spaghetti_Monster&#34;&gt;FSM&lt;/a&gt; si no tambien a
una maquina de estados finitos (&lt;a href=&#34;https://es.wikipedia.org/wiki/Aut%C3%B3mata_finito&#34;&gt;finite-state machine&lt;/a&gt;)&lt;/p&gt;

&lt;h2 id=&#34;cobaya&#34;&gt;cobaya&lt;/h2&gt;

&lt;p&gt;Aunque cobayizar un material es un entretenimiento &amp;ldquo;mecanico&amp;rdquo;, cada vez, me da
mas pereza tener que aplicarlo a tristes PDFs. Pero para optener una traduccion
&amp;ldquo;express&amp;rdquo; es lo mas sencillo que encuentro, y bueno &lt;code&gt;¯\_(ツ)_/¯&lt;/code&gt; aunque sea poco, material a
material van refinando las ideas del lenguaje de documentacion
imaginario. Por ejemplo, esta vez hicieron evidente un fallo en el
reconocimiento de listas alfabeticas (y numericas) que se resolvio modificando
chapuseramente una regex (aunque no subire el cambio al repo hasta el siguiente refactorizado)&lt;/p&gt;

&lt;p&gt;Hem, el material tenia pocos retos y apenas incluia imagenes. Lo mas complicado
fue dar formato al codigo, tambien inferir donde demonios terminabas los TIPs y
darle la jerarquia adecuada a los encabezados&lt;/p&gt;

&lt;p&gt;Los bloques donde se mostraba la salida de las pruebas no la afine del todo, y
en la lectura del libro no me percate del hecho de su no correcta indentacion
hasta luego de la mitad&lt;/p&gt;

&lt;p&gt;en el &lt;a href=&#34;https://github.com/nasciiboy/gdp&#34;&gt;repo cobayizado&lt;/a&gt; encontraran el fuente,
una exportacion a html sin interes ni esfuerzo, y la version (mal) traducida
automaticamente. Dicha traduccion, no tiene ni tabla de indice, ni los
encabezados tienen el orden correcto (miestras la leia, iba corrigiendo la
version en ingles), ademas seguramente el html este bastante
roto por toquetearlo bastante a mano y con regexes&amp;hellip; y asi se quedara, esta
ocacion no hay una version &amp;ldquo;fuente&amp;rdquo; en español, es mucho curro y prefiero
ponerme a practicar los patrones&lt;/p&gt;

&lt;p&gt;felices trazos!&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>blackfriday</title>
      <link>https://nasciiboy.github.io/prog/blackfriday/</link>
      <pubDate>Fri, 27 Oct 2017 17:42:32 -0500</pubDate>
      
      <guid>https://nasciiboy.github.io/prog/blackfriday/</guid>
      <description>

&lt;p&gt;&lt;img src=&#34;https://nasciiboy.github.io/img/bf.jpg&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;Durante la modificacion del morg, habia escrito esto junto con otras notas
vagas en una bitocora de abordo que trata de ser FIFO, aunque si no mantengo la
constancia comienza a crecer y crecer hasta volverse incomoda. Asi pues (y como
el post anterior) a despejar algunas de esas divagaciones&lt;/p&gt;

&lt;h2 id=&#34;como-no-construir-un-parser-para-un-lenguaje-de-marcas-ligeras&#34;&gt;Como (no) construir un parser para un lenguaje de marcas (ligeras)&lt;/h2&gt;

&lt;p&gt;con &lt;em&gt;morg&lt;/em&gt; (parser y lenguaje de marcas ligueras inventado por yo) la
construccion al igual que casi todas mis mierdas, fue fruto de reinventar la
rueda + prueba y error constantes, tratando de mantener una cierta sencilles&amp;hellip;
mientras la raices de la incertidubre sobre si el proyecto llegaria a ser
funcional o quedaria truncado por la ignorancia y malas deciciones de diseño
orientadas en su mayoria por la aleatoriedad, me consumen lentamente&lt;/p&gt;

&lt;p&gt;una de las primeras deciciones luego de la mudanza a Go, fue trabajar con
strings o slices de bytes, los primeros son inmutables, peeero todas las
funciones que trabajan con documentos (de la libreria estandar y mas alla) optan
por utilizar slices de bytes.&lt;/p&gt;

&lt;p&gt;En principo me parecio que los strings son mejor opcion, pues me aseguro de no
fastidiar lo que el usuario envie a el exportador, ademas que hacer recorridos
por la cadena mediante &lt;code&gt;range&lt;/code&gt;s es muy sencillo, con el agregado de
soportar unicode.&lt;/p&gt;

&lt;p&gt;Por el otro lado, trabajar con bytes, evita una conversion extra (de bytes a
strings) y supuestamente son mas eficientes, pero venido como soy de C, donde se
suponque que las cadenas constantes son mas eficientes, la duda sigue presente&lt;/p&gt;

&lt;p&gt;Otro tema y creo que mas crucial es como recorer y diseccionar los
datos de entrada, opteniendo los supuestos componentes del lenguaje,
encabezados, parrafos, notas, resaltado, listas, definiciones, etc, y casi igual
de importante como organizarlos en una forma conveniente tanto para yo como
programador, como para yo como usuario del programa y de ser posible lanzar
advertencias cuando se localicen datos de entrada erroneos&lt;/p&gt;

&lt;p&gt;ante tal reto y sin &amp;ldquo;documentos tecnicos&amp;rdquo; que conosca (o entienda), la unica
opcion en el corto plazo, no es otra que meterse a lo bruto con algun proyecto
de programacion que ofresca descaradamente su codigo a todo mundo, aqui es donde
entra la libreria &lt;a href=&#34;https://github.com/russross/blackfriday&#34;&gt;blackfriday&lt;/a&gt; de un
tal &lt;em&gt;russross&lt;/em&gt; para parsear markdown, escrita en Go&amp;hellip; lol, hace tiempo intente
con cosas en C y python&amp;hellip; donde el codigo me resulto incomprensible&amp;hellip;&lt;/p&gt;

&lt;h2 id=&#34;como-lo-hace-russross&#34;&gt;como lo hace russross&lt;/h2&gt;

&lt;p&gt;utiliza slices de bytes, en lugar de cadenas, buffers del paquetes &lt;code&gt;bytes&lt;/code&gt; como
contenedores del resultado, tanto en llamadas internas como en los
&lt;em&gt;renderizadores&lt;/em&gt; del documento parceado e igual que morg no regresa error
alguno, solo slices vacios (&lt;code&gt;nil&lt;/code&gt;)&lt;/p&gt;

&lt;p&gt;interesante es su parseo en si, asigno funciones con caracteres &amp;ldquo;centinela&amp;rdquo;
para identificar los objetos, envia el slice de datos a la funcion respectiva,
junto con la estructura del documento y esta almacena el resultado y regeresa la
longitud de bytes leeidos que se suponen forman parte del elemento&lt;/p&gt;

&lt;p&gt;mas interesante, es que toma dos pasos de parseo sobre el documento, la primera
para normalizar el docuemento (quitar los saltos de linea a lo windows &lt;code&gt;\r\n&lt;/code&gt;,
cosa que no hare por asco a windows y trabajar solo con saltos unix &lt;code&gt;\n&lt;/code&gt;),
extraer referencias, normalizar bloques de codigo y copiar el resto tal cual,
todo byte a byte o a slices, en el buffer. El segundo reccorido por el documento
es para el parseo &amp;ldquo;serio&amp;rdquo; donde corta y renderiza el resto de cosas.&lt;/p&gt;

&lt;p&gt;Me llama la atencion, que aunque utiliza &lt;code&gt;bytes.Buffer&lt;/code&gt;, no los haga crecer
desde un inicio para disminuir las asignaciones de memoria, no es que sea
realmente necesario&amp;hellip; je, optimizacion premutura, el mal!&lt;/p&gt;

&lt;p&gt;otra desicion relevante toma cuando al llamar al parser del documento, hay que
enviarle un &lt;em&gt;renderizador&lt;/em&gt; que es una interfaz con 31 funciones, la cual se
encarga en unica instancia de entregar el resultado como texto plano en forma de
slice de bytes, bueno, eficiente o practico? dificil saberlo, blacfriday entrega
un render para HTML y otro experimental para latex, aunque por la naturazela de
markdown dificimente sera satisfactorio, pero siendo markdown, un mero
&lt;em&gt;facilitador&lt;/em&gt; de HTML, no hay necesidad de generar otra cosa que no sea HTML, un
poco futil ecuentro la cortecia de entregar &amp;ldquo;renders&amp;rdquo; en blackfriday, cuando el
parseo y exportacion van juntos, unidos, en las entrañas del parser.&lt;/p&gt;

&lt;p&gt;En morg, no lo tenia (ni tengo) muy claro, en la primer version, el parser y el
render son entes separados, unidos solo por la estructura &amp;ldquo;organizada&amp;rdquo; que
entrega el primero, deje en manos del render hacer lo que le venga en gana con
la estructura, sin embargo, al cambiar constantemente esta, hay que hacer una
labor de actualizacion en los &lt;em&gt;n&lt;/em&gt; renders, en &lt;em&gt;n&lt;/em&gt; cambios, quiza un punto
intermedio vendria bien, para la siguiente version; que te entrege la estructura
en bruto y cuente con una interfaz que trabaje como plantilla de exportacion,
aunque, las sutilezas del lenguaje de marcado a exportar, vuelven a esto un
rigido inconveniente, pese a lo sencillo de definir unas cuantas reglas
genericas&lt;/p&gt;

&lt;p&gt;creo que pandoc, cuando examina un docuemnto, lo convierte a una estructura
&amp;ldquo;maestra&amp;rdquo; y luego con ella ya se lo manda a sus renders, me siento mas comodo con esta
opcion, pero como aun no le hago al haskell, tendre que esperar para comprobarlo
de primera mano&lt;/p&gt;

&lt;h2 id=&#34;conclucion&#34;&gt;conclucion&lt;/h2&gt;

&lt;p&gt;tentado estoy a trabajar con bytes, aunque creo que trabajar con &lt;code&gt;bytes.Buffer&lt;/code&gt;
no representa una gran mejora y obliga a incluir un paquete extra, je, je, tengo
algun complejo muuu grande con incluir librerias, aunque sean las estandar,
tengo un problema&amp;hellip; repite tu mantra, esta en la libreria estandar, es bueno y
necesario, en la libreria estandar esta, necesario y bueno es usarlo&lt;/p&gt;

&lt;p&gt;utilizar bytes, requiere modificaciones drasticas en regexp4 que solo maneja
strings, o un monton de conversiones de ida y vuelta.&lt;/p&gt;

&lt;p&gt;que hacer? bytes y strings, dos caras de la misma moneda, separadas por la no
conversion de tipos automatica, para la ocultacion de cadenas como punteros, en
estas deciciones Go-leanas es cuando extraño a C, cuando aparecen estas
estructuras que no estoy seguro si se replican a cada copia/asignacion o
trabajan con los mismos datos de fondo&lt;/p&gt;

&lt;p&gt;en resumen blackfriday (digo, luego de tres intentos por comprenderla hasta no
terminar de leer seriamente el TGPL), no era tan alien, ni complejo como parecia
en un principio, que esta furtemente atado a las limitaciones de markdown, al
igual que sus renderes y por ello no se ve forzado a implementar una estructura
que almacene el documento, pues no maneja elementos, anidados sobre elementos
anidados, sobre elementos aninados, peroooo dentro de sus limitaciones tecnicas,
hace bien su labor&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>benchmarks dentro de un programa en go</title>
      <link>https://nasciiboy.github.io/prog/gomark/</link>
      <pubDate>Fri, 06 Oct 2017 21:03:55 -0500</pubDate>
      
      <guid>https://nasciiboy.github.io/prog/gomark/</guid>
      <description>

&lt;p&gt;en Go podemos realizar benchmarks dentro de los ficheros &lt;code&gt;_test.go&lt;/code&gt;, sin embargo
realizar comparativas dentro de en un programa &amp;ldquo;regular&amp;rdquo; no es (era) tan
sencillo hasta la llegada de la version 1.9&lt;/p&gt;

&lt;h2 id=&#34;cgo&#34;&gt;cgo&lt;/h2&gt;

&lt;p&gt;la primer opcion es echar mano de la libreria &lt;code&gt;time&lt;/code&gt; de C. Esta libreria
contiene la funcion &lt;code&gt;clock&lt;/code&gt; que nos regresa una aproximacion a la cantidad de tiempo
del procesador que ha utilizado el programa desde su ejecucion.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;package main

//#include &amp;lt;time.h&amp;gt;
import &amp;quot;C&amp;quot;

import &amp;quot;fmt&amp;quot;

const top = 1 &amp;lt;&amp;lt; 12

func main(){
  init := CpuTime()

  // prueba &amp;gt;
  for x, str := 0, &amp;quot;&amp;quot;; x &amp;lt; top; x++ { str += &amp;quot;1234567890&amp;quot; }
  // &amp;lt; prueba

  fmt.Printf( &amp;quot;CpuTime %dms\n&amp;quot;, DiffCpuTimeByMS( init, CpuTime() ) )
}

func CpuTime() uint64 {
  return uint64(C.clock())
}

func DiffCpuTimeByMS( begin, end uint64 ) uint64 {
  return (end - begin) *  1000 / uint64(C.CLOCKS_PER_SEC)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;resultado:&lt;/strong&gt; &lt;code&gt;CpuTime 55ms&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;solo hay que cambiar el codigo dentro de las comentaarios &amp;ldquo;prueba&amp;rdquo;, es
importante mantener la linea con &lt;code&gt;//#include &amp;lt;time.h&amp;gt;&lt;/code&gt; tal cual, pues es una
(obscura) indicacion para decirle al compilador de Go que incluya dicha libreria
de C. Por supuesto tambien hay que mantener la importacion de &lt;code&gt;&amp;quot;C&amp;quot;&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;Para la compilacion no hace falta pasar ningun parametro adicicional, basta con
un simple &lt;code&gt;go build main.go&lt;/code&gt;&lt;/p&gt;

&lt;h2 id=&#34;testing&#34;&gt;testing&lt;/h2&gt;

&lt;p&gt;la segunda opcion para realizar un benchmark es invocar a &lt;code&gt;testing&lt;/code&gt; desde codigo
regular con una funcion literal&amp;hellip; lo se, no es intiuitivo, pero hay esta y
funciona&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;package main

import &amp;quot;fmt&amp;quot;
import &amp;quot;testing&amp;quot;
import &amp;quot;time&amp;quot;

const top = 1 &amp;lt;&amp;lt; 12

func main(){

  result := testing.Benchmark(func(b *testing.B) {
    b.N = 1 // numero de repeticiones de la prueba
    for i := 0; i &amp;lt; b.N; i++ {
      // prueba &amp;gt;
      for x, str := 0, &amp;quot;&amp;quot;; x &amp;lt; top; x++ { str += &amp;quot;1234567890&amp;quot; }
      // &amp;lt; prueba
    }
  })

  fmt.Printf( &amp;quot;tiempo %s\n&amp;quot;, result.T / time.Duration(result.N) )
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;resultado:&lt;/strong&gt; &lt;code&gt;tiempo 67.861708ms&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;esta prueba toma mucho mas tiempo que con la version anterior, la diferencia se
origina en el propio &lt;code&gt;testing.B&lt;/code&gt;, ya que realiza metricas adicionales, como el numero de
asignaciones de memoria, bytes utilizados, gorutinas y otras cosas&lt;/p&gt;

&lt;h2 id=&#34;time&#34;&gt;time&lt;/h2&gt;

&lt;p&gt;por ultimo la prueba del tiempo se puede realizar con la libreria estandar de
Go, aunque esto no es asi para verciones del compilador inferiores a 1.9 ya que
antes de estos no se media el timpo &amp;ldquo;monolitico&amp;rdquo; de ejecucion (lo que hace
&lt;code&gt;clock&lt;/code&gt; de la libreria &lt;code&gt;time&lt;/code&gt; de C)&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;package main

import &amp;quot;time&amp;quot;
import &amp;quot;fmt&amp;quot;

const top = 1 &amp;lt;&amp;lt; 12

func main(){
  start   := time.Now()
  for x, str := 0, &amp;quot;&amp;quot;; x &amp;lt; top; x++ { str += &amp;quot;1234567890&amp;quot; }
  elapsed := time.Since( start )

  fmt.Printf( &amp;quot;tiempo %s\n&amp;quot;, elapsed )
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;resultado:&lt;/strong&gt; &lt;code&gt;tiempo 59.746755ms&lt;/code&gt;&lt;/p&gt;

&lt;h2 id=&#34;conclusion&#34;&gt;conclusion&lt;/h2&gt;

&lt;p&gt;en pruebas personales, con &lt;code&gt;clock&lt;/code&gt; (de C) los resultados son mas constantes y con
menor variacion que en las demas opciones, mas la version con &lt;code&gt;time&lt;/code&gt; nativo no
dista demaciado de esta, ademas por ser la opcion con codigo nativo y sin
dependencias externas es la que recomiendo y utilizo. Reservaria como segunda
opcion y para pruebas mas exigentes la que utiliza &lt;code&gt;testing.B&lt;/code&gt;, siempre asumiendo
una consumo superior de recursos&lt;/p&gt;

&lt;h2 id=&#34;referencias&#34;&gt;referencias&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;https://www.reddit.com/r/golang/comments/6u4xhs/how_make_a_benchmark_in_a_regular_program_no/&#34;&gt;https://www.reddit.com/r/golang/comments/6u4xhs/how_make_a_benchmark_in_a_regular_program_no/&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://golang.org/pkg/time/&#34;&gt;https://golang.org/pkg/time/&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>
